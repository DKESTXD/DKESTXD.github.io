<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>机器人导论</title>
    <link href="/2025/12/11/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AF%BC%E8%AE%BA/"/>
    <url>/2025/12/11/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AF%BC%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>python项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>[置顶]lol英雄时刻</title>
    <link href="/2025/12/10/%E7%BD%AE%E9%A1%B6-lol%E8%8B%B1%E9%9B%84%E6%97%B6%E5%88%BB/"/>
    <url>/2025/12/10/%E7%BD%AE%E9%A1%B6-lol%E8%8B%B1%E9%9B%84%E6%97%B6%E5%88%BB/</url>
    
    <content type="html"><![CDATA[<p>帅就完事了</p><span id="more"></span><p><video src="/img/lol/15-24_NJ100-900753126805_01.mp4" position="absolute" width="100%" height="100%" controls="controls"></video></p><p><video src="/img/lol/15-24_NJ100-900749425741_01.mp4" position="absolute" width="100%" height="100%" controls="controls"></video></p><p><video src="/img/lol/15-21_NJ100-900703218126_01.MP4" position="absolute" width="100%" height="100%" controls="controls"></video></p>]]></content>
    
    
    <categories>
      
      <category>enjoy yourself</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>从信号角度实现音乐和人声分离</title>
    <link href="/2025/12/10/%E4%BB%8E%E4%BF%A1%E5%8F%B7%E8%A7%92%E5%BA%A6%E5%AE%9E%E7%8E%B0%E9%9F%B3%E4%B9%90%E5%92%8C%E4%BA%BA%E5%A3%B0%E5%88%86%E7%A6%BB/"/>
    <url>/2025/12/10/%E4%BB%8E%E4%BF%A1%E5%8F%B7%E8%A7%92%E5%BA%A6%E5%AE%9E%E7%8E%B0%E9%9F%B3%E4%B9%90%E5%92%8C%E4%BA%BA%E5%A3%B0%E5%88%86%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<p>施工中。。。细节可见<a href="https://github.com/DKESTXD/my-university-life">DKESTXD&#x2F;my-university-life</a></p><span id="more"></span>]]></content>
    
    
    <categories>
      
      <category>matlab</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>传感与检测学习笔记(一)</title>
    <link href="/2025/12/09/%E4%BC%A0%E6%84%9F%E4%B8%8E%E6%A3%80%E6%B5%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/"/>
    <url>/2025/12/09/%E4%BC%A0%E6%84%9F%E4%B8%8E%E6%A3%80%E6%B5%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<p>垃圾课。。。</p><span id="more"></span><h1 id="传感与检测"><a href="#传感与检测" class="headerlink" title="传感与检测"></a>传感与检测</h1><h2 id="1-检测技术基础"><a href="#1-检测技术基础" class="headerlink" title="1 检测技术基础"></a>1 检测技术基础</h2><h3 id="1-1-检测技术基本概念"><a href="#1-1-检测技术基本概念" class="headerlink" title="1.1 检测技术基本概念"></a>1.1 检测技术基本概念</h3><p><strong>检测</strong>:使用专门的工具,通过实验和计算,进行比较,找出被测参数的量值或判定被测参数的有无。可能是一个具体的量值，可能是“有”或“无”</p><p><strong>测量</strong>:完全以确定被测对象量值为目的的操作。（“检测”和“测量”基本可以通用）</p><p><strong>检测技术</strong>:研究如何获取被测参数信息的一门科学,涉及数学、物理、化学、生物、材料、机械、电子、信号处理和计算机等很多学科。</p><h3 id="1-2-检测仪表基本概念"><a href="#1-2-检测仪表基本概念" class="headerlink" title="1.2 检测仪表基本概念"></a>1.2 检测仪表基本概念</h3><h4 id="1-2-1-定义"><a href="#1-2-1-定义" class="headerlink" title="1.2.1 定义"></a>1.2.1 定义</h4><p><strong>检测仪表</strong>：检测的过程就是用敏感元件将被测参数的信息转换成另一种形式的信息,通过显示或其他形式被人们所认识。所以敏感元件和显示装置构成了检测仪表的基本组成部分。一般来说，一台检测仪表是一个相对独立使用的整体,它能实现某个参数的检测。“–对应”关系。当然，也有“多参数检测仪表”(集成化的专用检测系统)</p><p><strong>检测系统</strong>：利用若干个检测仪表实现某一个或多个参数测量所构成的系统称为检测系统。<br>一台检测仪表，可能是一个检测系统;也可以是检测系统的一个环节。检测仪表和检测系统之间没有明显的界限</p><p><strong>检测装置</strong>:检测仪表或检测系统及其必需的辅助设备所构成的总体，称为检测装置,</p><p><img src="/img/chuangan/6b2cb2d7e45d41e4250e48da8fda0da1.png"></p><p><strong>相关术语</strong>：</p><p>① 敏感元件(sensing element)<br>② 传感器(sensor)仪器&#x2F;仪表(Instrument)<br>③变送器(transmitter)标准信号输出<br>④ 被测参数(measured parameter) 也称被测量,是指敏感元件直接感受的测量参数。<br>⑤ 待测参数(parameter to be measured) 也称待测量,是指需要获取的测量参数。在大多数情况下,被测参数就是待测参数,例如用铜电阻测量温度,温度既是被测参数,也是待测参数。但在间接测量中,两者就有不同的含义,<br>⑥ 直接测量(direct measurement)<br>⑦ 间接测量(indirect measurement) 通过测量与待测参数有函数关系(甚至没有函数关系)的其他量,经一定的数学处理才能得到待测参数的量值。在这种情况下,被测参数一般就不是待测参数。例如,通过测量长度确定矩形面积,长度是被测量,面积是待测量,这种通过用长度测量来获得面积的方法称为间接测量。</p><h4 id="1-2-2-分类"><a href="#1-2-2-分类" class="headerlink" title="1.2.2 分类"></a>1.2.2 分类</h4><p>①按被测参数分类：温度检测仪表(简称温度仪表)、压力检测仪表、流量检测仪表、物位检测仪表<br>②按对被测参数的响应形式分类：连续式检测仪表、开关式检测仪表<br>③按仪表中使用的能源和主要信息的类型分类：<br>机械式仪表–一般不需要外部能源，带动机械结构，就地指示&#x2F;现场指示居多<br>电式仪表–绝大部分气动仪表一安全防爆，信号滞后，衰减(检测仪表气动的少了)<br>光式仪表一光电结合<br>④ 按是否具有远传功能分类：就地显示仪表、远传式仪表<br>⑤ 按信号的输出(显示)形式分类：模拟式仪表、数字式仪表(以及带模拟显示的数字仪表)<br>⑥ 按应用的场所,检测仪表也有各种分类方法：<br>根据安装场所有无易燃易爆气体及危险程度：有普通型、隔爆型及本安型。<br>根据使用的领域：有民用的、工业用的和军事用的。<br>⑦ 按仪表的结构形式分类：开环结构仪表、闭环结构仪表</p><p>开环结构：</p><p><img src="/img/chuangan/4dd1e626e2970c2aadeecde6b2b14ce4.png"></p><p>闭环结构：</p><p><img src="/img/chuangan/ScreenShot_2025-10-06_191025_733.png"></p><p><img src="/img/chuangan/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20251006191055_276_49.png"></p><h4 id="1-2-3-检测仪表的基本性能"><a href="#1-2-3-检测仪表的基本性能" class="headerlink" title="1.2.3 检测仪表的基本性能"></a>1.2.3 检测仪表的基本性能</h4><h5 id="1-2-3-1-测量范围和量程"><a href="#1-2-3-1-测量范围和量程" class="headerlink" title="1.2.3.1 测量范围和量程"></a>1.2.3.1 测量范围和量程</h5><p>测量范围<br>测量上限、测量下限是量程（量程范围是区间，量程是值，现在不怎么提了）</p><p>要选定可测范围，要根据测量仪器的元器件关于输入的输出曲线，可测范围一定是单调的，另外该怎么选则要根据各个范围的线性程度以及放大倍数选择。</p><h5 id="1-2-3-2-输入-输出特性"><a href="#1-2-3-2-输入-输出特性" class="headerlink" title="1.2.3.2 输入-输出特性"></a>1.2.3.2 输入-输出特性</h5><p>灵敏度：仪表输入-输出特性曲线的斜率;灵敏度和准确度的关系;变送器的灵敏度</p><p>死区：检测仪表输入量的变化不致引起输出量可察觉变化的有限区间;也叫不灵敏区</p><p>线性度：仪表的线性度是表示仪表的输入-输出特性曲线对相应理论直线的偏离程度;非线性误差</p><p>回差：检测仪表在全量程范围内对于同一被测量在其上升和下降时对应输出值间的最大误差（压力表，弹性元件，温度计）</p><h5 id="1-2-3-3-误差"><a href="#1-2-3-3-误差" class="headerlink" title="1.2.3.3 误差"></a>1.2.3.3 误差</h5><p>①<strong>绝对误差</strong>：仪表输出值与被测参数真值之间的差值</p><p>②<strong>相对误差</strong>：仪表的绝对误差与约定真值比的百分数，</p><p>③<strong>引用误差</strong>：仪表的绝对误差与仪表的量程比的百分数</p><p>④<strong>仪表基本误差</strong>：在标准条件下,仪表全量程范围内各输出值误差中<strong>最大的绝对误差</strong>称为仪表的基本误差。（绝对值最大）(给定的仪表，1个基本误差)    （**最大误差绝对值，但是有正负吗？**最大误差绝对值定义一个误差上限）</p><p>⑤ <strong>仪表满刻度相对误差</strong>：<strong>仪表基本误差</strong>与仪表量程比的百分数。</p><p>⑥<strong>允许误差</strong>：这是仪表制造单位为仪表设定的一个误差限值,其大小稍大于仪表基本误差。仪表在正常使用时误差不应超过仪表的允许误差。为了合理地显示检测仪表的输出,通常规定仪表标尺的最小分格值或数字显示值不能小于仪表允许误差绝对值。</p><p>⑦<strong>分辨率</strong>：最小可测输入变化</p><p><img src="/img/chuangan/ScreenShot_2025-10-06_205453_921.png"></p><p>因为检测仪表在应用时被测量不宜过小,一般希望接近于仪表的上限值，</p><h5 id="1-2-3-4-准确度与准确性等级"><a href="#1-2-3-4-准确度与准确性等级" class="headerlink" title="1.2.3.4 准确度与准确性等级"></a>1.2.3.4 准确度与准确性等级</h5><p>准确度：仪表给出接近于真值的响应能力，通常是用<strong>仪表满刻度相对误差的大小来衡量</strong>。准确度常常也称精度或精确度。</p><p>准确度等级：..,0.05,0.1,0.25,0.35,0.5,1.0,1.5,2.5,4.0….越小，表示精度越高</p><p>准确度只有等级没有值，等级越小精度越高，准确度是衡量仪表性能的重要指标之一</p><p>如果是给仪表定级：算出来仪表满刻度相对误差后应该<strong>向上取最近</strong>的，如0.8取1</p><p>如果是选表：算出来所需的相对误差上限后应该<strong>向下取最近</strong>的，如0.8取0.5</p><p>量程乘准确度等级%确定误差上限</p><h5 id="1-2-3-5-动态响应特性"><a href="#1-2-3-5-动态响应特性" class="headerlink" title="1.2.3.5 动态响应特性"></a>1.2.3.5 动态响应特性</h5><p><strong>稳态(静态)特性</strong>：量程、误差、准确度等级等<br>仪表的<strong>动态响应特性</strong>则反映仪表输出值跟随被测量随时间变化的能力。一般用被测量<strong>初始值为零作单位阶跃变化时,仪表输出值达到或接近稳定值的时间</strong>进行评价。如果规定仪表<strong>输出值变化量达到稳定值的63.2%,则所需要的时间称仪表的响应时间,也称仪表的时间常数T</strong>。3T对应95.0%,5T对应99.3%。这个时间短,说明仪表的动态响应特性好。</p><p>一般不会产生动态误差。</p><p><img src="/img/chuangan/ScreenShot_2025-10-07_133149_861.png"></p><h5 id="1-2-3-6-稳定性"><a href="#1-2-3-6-稳定性" class="headerlink" title="1.2.3.6 稳定性"></a>1.2.3.6 稳定性</h5><p>① 时间稳定性：它表示在工作条件保持恒定时,仪表输出值在一段时间内随机变动量的大小。</p><p>② 工作条件稳定性：它表示仪表在规定的工作条件内某个条件的变化对仪表输出的影响。以仪表的供电电压影响为例,如果仪表规定的使用电源电压为(220+20)VAC,则实际电压在200~240VAC内可用电源每变化1V 时仪表输出值的变化量来表示仪表对电源电压的稳定性。</p><h5 id="1-2-3-7-重复性与再现性"><a href="#1-2-3-7-重复性与再现性" class="headerlink" title="1.2.3.7 重复性与再现性"></a>1.2.3.7 重复性与再现性</h5><p>①重复性：在相同的测量条件下,对同一被测量,按同一方向(由小到大或由大到小)多次测量时,检测仪表提供相近输出值的能力称为检测仪表的重复性。</p><p>② 再现性：是指在相同的测量条件下,在规定的相对较长的时间内,对同一被测量从两个方向(由小到大以及由大到小)上重复测量时,检测仪表的各输出值之间的一致程度。</p><p>重复性和再现性的优良只是保证仪表准确度的必要条件</p><p>重复性不包括回差,它是衡量仪表不受随机干扰的能力,而再现性包括了回差,也包括了重复性</p><h5 id="1-2-3-8-可靠性"><a href="#1-2-3-8-可靠性" class="headerlink" title="1.2.3.8 可靠性"></a>1.2.3.8 可靠性</h5><p>衡量检测仪表的可靠性,目前主要有三个指标来描述：<strong>保险期</strong>、<strong>有效性</strong>和<strong>狭义可靠性</strong>。</p><p>①保险期：仪表使用后能有效地完成规定任务的期限,超过了这一期限可靠性就逐渐降低。<br>②有效性：仪表在规定时间内能正常工作的概率。概率的大小取决于系统故障率的高低、发现故障的快慢和故障修复时间的长短<br>③狭义可靠性：由结构可靠性和性能可靠性两部分组成。前者指仪表在工作时不出故障的概率,后者指仪表能满足原定要求的概率。</p><p><img src="/img/chuangan/ScreenShot_2025-10-07_133841_305.png"></p><p>定量描述检测仪表可靠性的度量指标有<strong>可靠度</strong>、<strong>故障率</strong>、<strong>平均无故障工作时间</strong>、<strong>平均故障修复时间</strong>等</p><p>①<strong>可靠度R(t)<strong>是指仪表在规定工作时间内无故障的概率。如有100台同样的仪表,工作了1000h后只坏了一台,就可以说这批仪表在1000h后的可靠度是99%。反之这批仪表的不可靠度F(t)就是1%。显然R(t)&#x3D;1-F(t)<br>②</strong>故障率λ</strong>是指仪表工作到t时刻时单位时间内发生故障的概率。可靠度和故障率的关系是 $$R(t)&#x3D;e^{-\lambda t}$$<br>③<strong>平均无故障工作时间</strong>是仪表在相邻两次故障间隔内有效工作时的平均时间,用MTBF(Mean Timebetween Failure)来代表。<br>对于不可修复的产品来说,把从开始工作到发生故障前的平均工作时间用MTTF(MeanTime toFailure)代表<br>④<strong>平均寿命</strong>:MTBF MTTF统称为平均寿命，它的倒数就是故障率<br>⑤<strong>平均故障修复时间</strong>MTTR (Mean Time to Repair)是仪表出现故障到恢复工作时的平均时间,</p><p>评价一个仪表最重要指标<strong>灵敏度</strong>、<strong>准确度</strong>、<strong>可靠性</strong>。</p><h4 id="1-2-4-误差"><a href="#1-2-4-误差" class="headerlink" title="1.2.4 误差"></a>1.2.4 误差</h4><p>研究被测参数的测量值与真值的不一致程度,并给予恰当的估计,于是就产生了“测量误差”这个基本概念。</p><p>但是真值只是一个理想概念。于是用<strong>约定真值</strong></p><p><strong>约定真值</strong>的获取方法：</p><p>①<strong>标准表法</strong>：用准确度等级较高的标准表测得的值。所谓准确度等级较高是指该标准表的基本误差应小于被检定检测仪表的基本误差(或被测参数允许绝对误差)的13。</p><p>②<strong>计量器具法</strong>：计量器具是用来测量并能得到被测对象精确值的一种技术工具或装置</p><p>③<strong>平均值法（数学期望）</strong>：在没有标准表及计量器具的情况下,可用等精度测量条件下多次重复测量的平均值作为约定真值。(对于随机误差较大的情况，比较适用)</p><h5 id="1-2-4-1-误差分析要点1"><a href="#1-2-4-1-误差分析要点1" class="headerlink" title="1.2.4.1 误差分析要点1"></a>1.2.4.1 误差分析要点1</h5><p>测量：对一个各态历经（与抽样获得的曲线无关）平稳（与抽样时间无关）随机过程的抽样</p><p>工程上采样定理一般要大于3-5倍。</p><p>随机误差统计特性：<br>①有界性：随机误差的绝对值是有界的。<br>②对称性：绝对值相等的正、负随机误差出现的概率几乎相等<br>③单峰性：绝对值越小的随机误差在测量中出现的概率越大。<br>④抵偿性：随测量次数N的增加，随机误差的代数和趋向于零，即当N→∞时，$$\Sigma^N_{i&#x3D;1}e_i→0$$</p><p>可以用数理统计的方法对随机误差进行分析和处理</p><h5 id="1-2-4-2-误差分析要点2"><a href="#1-2-4-2-误差分析要点2" class="headerlink" title="1.2.4.2 误差分析要点2"></a>1.2.4.2 误差分析要点2</h5><p>科学实验和工程实践都证明，大多数随机误差服从正态分布规律，其分布概率密度函数p(e)可表为:<br>$$<br>p(e)&#x3D;\frac{1}{\sqrt{2\pi}\sigma}exp({-\frac{e^2}{2\sigma^2}})<br>$$<br>式中，e&#x3D;x-μ，为测量值与真值之间的随机误差。σ为标准差(也常称为标准偏差或均方根误差)。</p><p>相应地，测量值x的分布也服从正态分布，其概率密度函数为:<br>$$<br>p(e)&#x3D;\frac{1}{\sqrt{2\pi}\sigma}exp({-\frac{(x-\mu)^2}{2\sigma^2}})<br>$$<br>随机误差分析的两个关键统计量：真值(均值&#x2F;数学期望)μ和标准差σ</p><h3 id="1-3-误差基本概念"><a href="#1-3-误差基本概念" class="headerlink" title="1.3 误差基本概念"></a>1.3 误差基本概念</h3><h4 id="1-3-1-测量误差分类与测量不确定度"><a href="#1-3-1-测量误差分类与测量不确定度" class="headerlink" title="1.3.1 测量误差分类与测量不确定度"></a>1.3.1 测量误差分类与测量不确定度</h4><p>没有第三方提供真值时不谈系统误差，只随机误差。</p><p>①按误差不能说因次分类：决定误差，相对误差</p><p>②按误差出现的规律分类：</p><ol><li><p>系统误差：在同一条件下,对同一被测参数进行多次重复测量时,所出现的数值、符号都相同的,或者按一定规律变化的误差称为系统误差。分为 恒值系统误差 和 变值系统误差</p><p>测量原理或测量方法的不完善，标准量值的不准确，仪表本身的缺陷等引起的误差</p><p>规律较明确：修正、甚至消除。不太明确:可以补偿，难以消除</p></li><li><p>随机误差：在同一测量条件下,多次重复测量同一被测量时,其绝对值和符号以不可预定的方式变化,即具有随机性的误差称为随机误差。</p><p>随机误差的产生：偶然因素引起。仪表中传动部件的间隙和摩擦、连接件的弹性形变、使用的环境条件,如温度、湿度、气压、振动、电磁场等的波动、各种噪声等都会对测量系统产生影响</p><p>随机误差的特点:虽然就每次测量而言,测量误差是没有规律的,以随机方式出现,但在多次重复测量中其总体是符合统计规律的。当测量次数为无限多,误差的算术平均值趋近于零。</p></li><li><p>粗大误差：超出在规定条件下预期的误差称为粗大误差。此误差值较大,明显表现为测量结果异常。</p><p>导致粗大误差的原因:主观原因主要是指测量人员的操作失误、错误读数、指示或记录等;客观原因主要是指测量条件或工作环境意外发生变化,例如突然的机械冲击、偶发的剧烈震动(或电磁干扰)等含粗大误差的测量结果毫无意义应该剔除。</p></li></ol><p>③按使用的工作条件分类：基本误差，附加误差<br>基本误差：仪表在标准(额定)条件下所产生的误差。(准确度等级由基本误差来决定)<br>附加误差：当仪表的使用条件偏离标准(额定)工作条件，就会出现附加误差(在估计测量误差时需都考虑)</p><p>④按误差的特性分类：静态误差(稳态)，动态误差</p><p>测量不确定度：估计误差可能变动的区间，估计误差限。表征合理地赋予被测量之值的分散性，与测量结构相联系的参数。是评定测量结果质量高低的一个重要指标。</p><p>测量误差与测量不确定度：<br>①相同点：评定测量结果的准确度<br>②不同点：测量误差是基础，不确定度是补充</p><p>分类：A类不确定度，B类不确定度</p><h4 id="1-3-2-误差的估计和评价处理方法"><a href="#1-3-2-误差的估计和评价处理方法" class="headerlink" title="1.3.2 误差的估计和评价处理方法"></a>1.3.2 误差的估计和评价处理方法</h4><h5 id="1-3-2-1-随机误差的估计与统计处理"><a href="#1-3-2-1-随机误差的估计与统计处理" class="headerlink" title="1.3.2.1 随机误差的估计与统计处理"></a>1.3.2.1 随机误差的估计与统计处理</h5><p>测量列，如不包含系统、粗大误差，概率密度分布</p><p>服从正态分布：误差的单峰性、对称性、有界性、抵偿性，次数越大理论上算数平均值趋于0。</p><p>三σ原则：$$P(\Delta \leq \sigma)&#x3D;68.26%,P(\Delta \leq 2\sigma)&#x3D;95.44%,P(\Delta \leq 3\sigma)&#x3D;99.73%$$，3σ作为极限误差</p><h5 id="1-3-2-2-粗大误差的判别"><a href="#1-3-2-2-粗大误差的判别" class="headerlink" title="1.3.2.2 粗大误差的判别"></a>1.3.2.2 粗大误差的判别</h5><p>判别：给定一个显著性水平，按一定的分布确定临界值,凡超过临界值的误差 就判定为粗大误差,应予剔除</p><p>①拉依达法：计算实验标准差；在测量列中，发现有大于3σ的残余误差的测量值被认为含有粗大误差；删除后重新计算，直到未发现为止；n&gt;30时用之</p><p>②格拉布斯法：计算实验标准差；|残差|&gt;λ(α，n)×σ则认为含有粗大误差；剔除后重新计算；n较小时也可用，Xσ的X是变的，更具一般性</p><h5 id="1-3-2-3-系统误差估计与判别"><a href="#1-3-2-3-系统误差估计与判别" class="headerlink" title="1.3.2.3 系统误差估计与判别"></a>1.3.2.3 系统误差估计与判别</h5><p>产生原因：检测装置方面的因素；测量环境、测量方法、测量人员等各方面的因素</p><p>判别方法：<br>(1)实验对比法：用“标准表”来比对；或相同等级仪表来比对。适合于发现恒值误差<br>(2)残余误差观察法：根据测量列中各数据残余误差大小和符号的变化规律,直接由误差数掘或误差曲线来判断是否存在系统误差。适合于发现有规律变化的“变值系统误差<br>(3)标准差判据：在工程实际中,对等精度测量的测量列,可用不同的公式计算其标准差σ，如贝赛尔公式，Peters公式。看两者之间的相对变化量[(σ2-σ1)&#x2F;σ1]。如大于一定的值，则怀疑</p><h5 id="1-3-2-4-误差的合成"><a href="#1-3-2-4-误差的合成" class="headerlink" title="1.3.2.4 误差的合成"></a>1.3.2.4 误差的合成</h5><p>误差合成：从各分项误差对所研究的被测量的误差总和进行最可信估计。分析和综合各种误差因素,研究单项误差与所构成的总项误差的关系,并正确表述这些误差的综合影响，</p><p>意义：减小测量误差，保证测量准确度。</p><p>(1)系统误差合成：</p><p><img src="/img/chuangan/ScreenShot_2025-11-02_171438_040.png"></p><p>(2)随机误差合成：相同条件下重复实验，得m各标准差，求综合随机误差。</p><p>(3)误差的总合成：随机误差表示法：极限误差；总合成误差&#x3D;sqrt(系统误差平方+随机误差平方)</p><h4 id="1-3-3-消除和减少误差的一般方法"><a href="#1-3-3-消除和减少误差的一般方法" class="headerlink" title="1.3.3 消除和减少误差的一般方法"></a>1.3.3 消除和减少误差的一般方法</h4><h5 id="1-3-3-1-减少随机误差方法"><a href="#1-3-3-1-减少随机误差方法" class="headerlink" title="1.3.3.1 减少随机误差方法"></a>1.3.3.1 减少随机误差方法</h5><p>来源不可完全预知性和不可克服性,是不可以消除的；服从统计规律,具有抵偿性,是它最本质的特征；提高检测系统准确度、抑制干扰和统计处理等方法来减少</p><p>(1)提高检测系统准确度：从检测系统的原理、设计和结构上考虑；尽量逝免采用存在摩擦的可动部分、减少可动部分器件的重量；采用负反馈结构的平衡式测量和应用无间隙传动链等</p><p>(2)对测量结果统计处理：估计随机误差影响的可能变化区间；提高测量次数,可提高算术平均值和标准差的估计准确度</p><p>(3)抑制噪声干扰：屏蔽、接地、选频、去耦、隔离传输和滤波；中值滤波,低通滤波器、高通滤波器、带通滤波器、带阻滤波器以及自适应滤波器等</p><h5 id="1-3-3-2-减少和消除系统误差方法"><a href="#1-3-3-2-减少和消除系统误差方法" class="headerlink" title="1.3.3.2 减少和消除系统误差方法"></a>1.3.3.2 减少和消除系统误差方法</h5><p>恒值或者一定规律变化的误差</p><p>(1)消除误差源法：适用于明确误差来源</p><p>(2)引入修正值法：适用于只知道分布规律。根据误差表或误差曲线，分析分布规律，进行校正；是最常用的方法<br>计算机程序:将获得的系统误差规律和相应的修正值(修正值、修正曲线和修正图表等)存入微机存储器<br>难以完全补偿，残余系统误差，可视为随机误差进行抑制</p><h5 id="1-3-3-3-减少和消除粗大误差的方法"><a href="#1-3-3-3-减少和消除粗大误差的方法" class="headerlink" title="1.3.3.3 减少和消除粗大误差的方法"></a>1.3.3.3 减少和消除粗大误差的方法</h5><p>特点：在规定条件下明显超出预期的误差,表现为测量结果显著异常；如不处理，可能会导致相应控制系统的剧烈震荡甚至失效</p><p>办法：<br>(1)如果由主观原因引起：提高操作人员责任心，减少人为因素的失误；辅以报警系统来提示</p><p>(2)如果由客观因素引起：有不可预测性、偶发性、时效性</p><p>软测量模型：根据已有数据计算获得一个预测测量值；如果不是粗大误差则存入，如果是就不用该测量值而用软测量值来代替。</p><p>软测量模型：</p><p><img src="/img/chuangan/ScreenShot_2025-11-03_164354_587.png"></p><h2 id="2-检测技术与检测元件"><a href="#2-检测技术与检测元件" class="headerlink" title="2 检测技术与检测元件"></a>2 检测技术与检测元件</h2><h3 id="2-1-检测技术一般原理"><a href="#2-1-检测技术一般原理" class="headerlink" title="2.1 检测技术一般原理"></a>2.1 检测技术一般原理</h3><p>典型的检测系统：敏感元件、转换元件、显示装置（可测范围、测量准确度、使用条件、使用场合等）</p><p><img src="/img/chuangan/ScreenShot_2025-11-03_182023_997.png"></p><p><img src="/img/chuangan/ScreenShot_2025-11-03_182105_759.png"></p><p>敏感元件选择：同一方法可以测量不同的参数，同一参数可以用不同的方法测量。适用范围、测量范围、输出特性、静&#x2F;动态误差</p><h3 id="2-2-机械式检测元件"><a href="#2-2-机械式检测元件" class="headerlink" title="2.2 机械式检测元件"></a>2.2 机械式检测元件</h3><p>将被测量转换为机械量信号输出具有结构简单、使用安全可靠、抗干扰能力强等特点。</p><h4 id="2-2-1-弹性式检测元件"><a href="#2-2-1-弹性式检测元件" class="headerlink" title="2.2.1 弹性式检测元件"></a>2.2.1 弹性式检测元件</h4><p>弹性变形：在外力作用下，物体的形状和尺寸会发生变化，若去掉外力，物体能恢复原来的形状和尺寸，这种变形就称为弹性变形。</p><h5 id="2-2-1-1-弹性特性"><a href="#2-2-1-1-弹性特性" class="headerlink" title="2.2.1.1 弹性特性"></a>2.2.1.1 弹性特性</h5><p>弹性元件输出与输入量的关系</p><p>①刚度：产生单位形变所需的外加作用力$$k&#x3D;\frac{dF}{dx}$$</p><p>②灵敏度：单位输入量所引起的输出量$$S&#x3D;\frac{dx}{dF}$$，希望k和S为常数</p><h5 id="2-2-1-2-弹性效应"><a href="#2-2-1-2-弹性效应" class="headerlink" title="2.2.1.2 弹性效应"></a>2.2.1.2 弹性效应</h5><p>(1)滞弹性效应：微塑性变形时胡可定律不满足</p><p>①弹性滞后：加载和卸载时应力σ和应变ε曲线不重合，最大相对滞后百分数$$r&#x3D;\frac{\Delta \epsilon_{max}}{\epsilon_{max}}\times 100%$$</p><p><img src="/img/chuangan/ScreenShot_2025-11-04_095300_765.png"><img src="/img/chuangan/ScreenShot_2025-11-04_095427_644.png"></p><p>②弹性后效：σ不变时。ε随时间延续缓慢变化，弹性后效值$$N_{15}&#x3D;\frac{\epsilon_{15}-\epsilon_0}{\epsilon_0}$$，其中ε15为应力保持15min后的应变</p><p>③应力松弛：ε不变时，σ随时间延续逐渐降低，应力松弛率$$r_{\sigma}&#x3D;\frac{\sigma_0-\sigma_t}{\sigma_0}\times 100%$$</p><p>(2)热弹性效应：弹性模量温度系数，谐振频率温度系数，线膨胀系数</p><p>(3)固有频率：弹性元件本身具有质量，具有弹性和弹性后效，它们共同决定了弹性元件的固有频率。</p><p>弹性元件的动态特性，即输出对动态变化输入量的响应与它的固有频率是密切相关的。固有频率越高，则弹性元件响应越快。</p><h5 id="2-2-1-3-材料"><a href="#2-2-1-3-材料" class="headerlink" title="2.2.1.3 材料"></a>2.2.1.3 材料</h5><ul><li>良好的机械性能及机械加工、热处理性能</li><li>良好的弹性特性：稳定的输入输出关系、很小的滞弹性效应</li><li>良好的温度特性：弹性模量的温度系数小且稳定</li><li>良好的化学性能：较强的抗氧化性和抗腐蚀性</li></ul><p>材料有：</p><ol><li>马氏体弥散硬化不锈钢：高弹性、耐久性、抗微塑变形能力，焊接性能好，无磁性，并对很多种介质有很强的抗腐蚀能力。</li><li>Ni基弥散硬化恒弹性合金：弹性高、弹性和漂移小；恒弹性温度范围一般在-60~80℃。</li><li>Nb恒弹性合金：高温恒弹性合金，无磁、耐蚀、弹性模量低、弹性极限高，适合于制造高温、高灵敏度的精密弹性敏感元件</li><li>铍青铜：抗磁、耐疲劳、加工和焊接性能好等优点，但适用温度范围较窄(150°C以下)，弹性模量温度系数较大。</li><li>石英晶体：很高的机械强度和稳定的机械性能，抗微塑变形能力极强滞后和蠕变极小，是一种理想的弹性敏感元件材料。</li><li>半导体硅材料：硅具有非常好的电学性质、机械性能，抗微塑变形能力强，滞后和蠕变极小，并且动态响应快。</li><li>陶瓷材料：良好的热稳定性、机械性能、化学稳定性较好、使用温度范围宽，其综合性能略次于石英和硅。</li></ol><h5 id="2-2-1-4-种类"><a href="#2-2-1-4-种类" class="headerlink" title="2.2.1.4 种类"></a>2.2.1.4 种类</h5><p>(1)弹簧管：</p><p><img src="/img/chuangan/ScreenShot_2025-11-04_102511_424.png"></p><p>(2)薄壁圆管</p><p><img src="/img/chuangan/ScreenShot_2025-11-04_102737_431.png"><br>$$<br>\sigma_x&#x3D;\frac{r_0}{2h}p \ \ \ \ \ \ \ \ \ \ \epsilon_x&#x3D;\frac{r_0}{2Eh}(1-2\mu)p\<br>\sigma_{\tau}&#x3D;\frac{r_0}{h}p \ \ \ \ \ \ \ \ \ \ \epsilon_{\tau}&#x3D;\frac{r_0}{2Eh}(2-\mu)p\<br>$$<br>(3)波纹管</p><p><img src="/img/chuangan/ScreenShot_2025-11-04_102743_881.png"><br>$$<br>d&#x3D;pA(\frac{1-\mu^2}{Eh_0})\frac{n}{A_0-\alpha A_1+\alpha^2 A_2+B_0\frac{h_0^2}{R_B^2}}<br>$$<br>(4)膜片、膜盒</p><p><img src="/img/chuangan/ScreenShot_2025-11-04_102753_707.png"></p><h4 id="2-2-2-振动式检测元件"><a href="#2-2-2-振动式检测元件" class="headerlink" title="2.2.2 振动式检测元件"></a>2.2.2 振动式检测元件</h4><p>被测量(如力、压力、密度等)的变化转换为谐振元件的固有频率的变化<br>由于输出信号为频率信号，因此易于直接与数字式检测系统配套使用<br>具有体积小、重量轻、分辨率高、精度高，便于信号的传输和处理等特点。</p><h5 id="2-2-2-1-振弦式"><a href="#2-2-2-1-振弦式" class="headerlink" title="2.2.2.1 振弦式"></a>2.2.2.1 振弦式</h5><p><img src="/img/chuangan/ScreenShot_2025-11-04_105226_714.png"></p><p>差动式振弦传感器<img src="/img/chuangan/ScreenShot_2025-11-04_105247_654.png">，可用于车辆动态称重</p><h5 id="2-2-2-2-振筒式"><a href="#2-2-2-2-振筒式" class="headerlink" title="2.2.2.2 振筒式"></a>2.2.2.2 振筒式</h5><p><img src="/img/chuangan/ScreenShot_2025-11-04_105549_641.png"></p><p>机械式检测元件能将难以直接测量的物理量(如压力流量、温度等)转换成便于测量的长度、角度、频率等参量，应用非常广泛。</p><h3 id="2-3-电阻式检测元件"><a href="#2-3-电阻式检测元件" class="headerlink" title="2.3 电阻式检测元件"></a>2.3 电阻式检测元件</h3><p>通过电阻参数的变化来实现物理量测量的传感器统称为电阻式传感器</p><h4 id="2-3-1-应变式检测元件"><a href="#2-3-1-应变式检测元件" class="headerlink" title="2.3.1 应变式检测元件"></a>2.3.1 应变式检测元件</h4><p>导体材料在外界拉力或压力作用下会发生机械形变，导致电阻率和几何因子发生改变，从而引起电阻阻值变化，这种现象称为“应变效应“<br>$$<br>R&#x3D;\rho\frac{l}{A}\<br>dR&#x3D;\frac{l}{A}d\rho+\frac{\rho}{A}dl-\frac{\rho l}{A^2}dA\<br>\frac{dA}{A}&#x3D;\frac{2dr}{r}\<br>\frac{\Delta R}{R}&#x3D;\frac{\Delta\rho}{\rho}+\frac{\Delta l}{l}-2\frac{\Delta r}{r}<br>$$<br>轴向应变$$\frac{\Delta l}{l}&#x3D;\epsilon$$，径向应变$$\frac{\Delta r}{r}&#x3D;-\mu \frac{\Delta l}{l}&#x3D;-\mu\epsilon$$，其中μ是泊松比，对大多数金属位于0.3~0.5<br>$$<br>\frac{\Delta R}{R}&#x3D;(1+2\mu)\epsilon+\frac{\Delta\rho}{\rho}\<br>灵敏度K&#x3D;\frac{\Delta R&#x2F;R}{\epsilon}&#x3D;(1+2\mu)+\frac{\Delta \rho&#x2F;\rho}{\epsilon}<br>$$</p><h5 id="2-3-1-1-应变片种类与结构"><a href="#2-3-1-1-应变片种类与结构" class="headerlink" title="2.3.1.1 应变片种类与结构"></a>2.3.1.1 应变片种类与结构</h5><p>(1)金属应变片</p><p>金属材料的电阻率相对变化正比于体积的相对变化$$\frac{\Delta \rho}{\rho}&#x3D;C\frac{dV}{V}&#x3D;C\frac{d(lA)}{lA}&#x3D;C(1-2\mu)\epsilon$$</p><p>C是与金属导体晶格结构相关的比例系数，由材料和加工方式决定<br>$$<br>\frac{\Delta R}{R}&#x3D;[(1+2\mu)+C(1-2\mu)]\epsilon&#x3D;K_m\epsilon\<br>$$<br>对于康铜μ&#x3D;0.33，C&#x3D;1</p><p><img src="/img/chuangan/ScreenShot_2025-11-04_112621_874.png"></p><p>①丝式应变片</p><p><img src="/img/chuangan/ScreenShot_2025-11-04_113308_922.png"></p><p>②箔式应变片</p><p><img src="/img/chuangan/ScreenShot_2025-11-04_113325_348.png"></p><p>③膜式应变片</p><p><img src="/img/chuangan/ScreenShot_2025-11-04_113330_982.png"></p><p>(2)半导体应变片</p><p>半导体材料在某一方向受到作用力时，电阻率会发生明显变化，这种现象称为压阻效应<br>$$<br>\frac{\Delta \rho}{\rho}&#x3D;\pi \sigma&#x3D;\pi E\epsilon,\pi为压阻系数\<br>\frac{\Delta R}{R}&#x3D;[(1+2\mu)+\pi E]\epsilon&#x3D;K_s\epsilon\<br>\pi&#x3D;(40\to 80)\times 10^{-11}m^2&#x2F;N\ \ \ \ \  \ \ \ \ E&#x3D;1.87\times 10^{11}N&#x2F;m^2<br>$$<br><img src="/img/chuangan/ScreenShot_2025-11-04_114202_112.png"></p><h5 id="2-3-1-2-测量电路"><a href="#2-3-1-2-测量电路" class="headerlink" title="2.3.1.2  测量电路"></a>2.3.1.2  测量电路</h5><p><img src="/img/chuangan/ScreenShot_2025-11-04_115326_896.png"></p><h6 id="2-3-1-2-1-单臂工作电桥"><a href="#2-3-1-2-1-单臂工作电桥" class="headerlink" title="2.3.1.2.1 单臂工作电桥"></a>2.3.1.2.1 单臂工作电桥</h6><p><img src="/img/chuangan/ScreenShot_2025-11-04_122305_001.png"><br>$$<br>U_0 &#x3D; U_I\left(\frac{R_1 + \Delta R_1}{R_1 + \Delta R_1 + R_2} - \frac{R_4}{R_3 + R_4}\right)&#x3D; U_I\frac{\Delta R_1 R_3}{(R_1 + \Delta R_1 + R_2)(R_3 + R_4)}\<br>U_0 &#x3D; U_I\frac{\frac{\Delta R_1}{R_1}}{\left(1 + \frac{\Delta R_1}{R_1} + \frac{R_2}{R_1}\right)\left(1 + \frac{R_4}{R_3}\right)}<br>$$<br>设桥臂比$$R_2&#x2F;R_1&#x3D;R_3&#x2F;R_4&#x3D;n$$，由于$$\Delta R_1&lt;&lt;R_1$$可以忽略它<br>$$<br>U_0 &#x3D; U_I\frac{\frac{\Delta R_1}{R_1}}{\left(1 + \frac{\Delta R_1}{R_1} + \frac{R_2}{R_1}\right)\left(1 + \frac{R_4}{R_3}\right)}&#x3D;U_I\frac{n}{(1+n)^2}\frac{\Delta R_1}{R_1}&#x3D;K_u\frac{\Delta R_1}{R_1}\<br>K_u&#x3D;\frac{U_I}{4}\ \ \ \ \  \ \ \  \ \ \ U_o&#x3D;\frac{U_I}{4}K_{\epsilon}<br>$$</p><p>$$<br>U_0’ &#x3D; U_I\frac{\frac{\Delta R_1}{R_1}}{\left(1 + n + \frac{\Delta R_1}{R_1}\right)\left(1 + \frac{1}{n}\right)} &#x3D; U_I\frac{\frac{\Delta R_1}{R_1} \cdot n}{\left(1 + n + \frac{\Delta R_1}{R_1}\right)\left(1 + n\right)}<br>$$</p><p>非线性误差为： $$\gamma &#x3D; \frac{U_0 - U_0’}{U_0} &#x3D; \frac{\frac{\Delta R_1}{R_1}}{\left(1 + n + \frac{\Delta R_1}{R_1}\right)}$$ </p><p>当( n &#x3D; 1 )时 $$\gamma &#x3D; \frac{\frac{\Delta R_1}{R_1}}{\left(2 + \frac{\Delta R_1}{R_1}\right)}$$</p><h6 id="2-3-1-2-2-双臂工作电桥"><a href="#2-3-1-2-2-双臂工作电桥" class="headerlink" title="2.3.1.2.2 双臂工作电桥"></a>2.3.1.2.2 双臂工作电桥</h6><p><img src="/img/chuangan/ScreenShot_2025-11-04_122326_716.png"></p><p>两个完全相同的应变片，在外力作用下其中一片受压，而另一片受拉。<br>$$<br>U_O &#x3D; U_I\left(\frac{R_1 + \Delta R_1}{R_1 + \Delta R_1 + R_2 - \Delta R_2} - \frac{R_4}{R_3 + R_4}\right)<br>$$</p><p>对于等臂电桥，$$( R_1 &#x3D; R_2 &#x3D; R_3 &#x3D; R_4 )$$，且$$( \Delta R_1 &#x3D; \Delta R_2 )$$时： $$U_O &#x3D; \frac{U_I}{2} \cdot \frac{\Delta R_1}{R_1} &#x3D; \frac{U_I}{2}K\varepsilon$$</p><h6 id="2-3-1-2-3-全臂工作电桥"><a href="#2-3-1-2-3-全臂工作电桥" class="headerlink" title="2.3.1.2.3 全臂工作电桥"></a>2.3.1.2.3 全臂工作电桥</h6><p><img src="/img/chuangan/ScreenShot_2025-11-04_123707_453.png"></p><h5 id="2-3-1-3-温度补偿效应"><a href="#2-3-1-3-温度补偿效应" class="headerlink" title="2.3.1.3 温度补偿效应"></a>2.3.1.3 温度补偿效应</h5><p><img src="/img/chuangan/ScreenShot_2025-11-04_124010_412.png"><img src="/img/chuangan/ScreenShot_2025-11-04_124017_074.png"></p><h5 id="2-3-1-4-应变片主要特性"><a href="#2-3-1-4-应变片主要特性" class="headerlink" title="2.3.1.4 应变片主要特性"></a>2.3.1.4 应变片主要特性</h5><ul><li>电阻值：测量电路应与电阻值的大小相配合(60、120、200……Ω)</li><li>灵敏系数：$$K&#x3D;\frac{\Delta R&#x2F;R}{\Delta l&#x2F; l}$$，康铜K&#x3D;1.9<del>2.1，铁铬铝合金K&#x3D;2.4</del>2.6</li><li>绝缘电阻：应变计的敏感栅和引线与被测件之间的电阻(500-5000MΩ)</li><li>零漂和蠕变<br>零漂:不承受机械应变时，指示应变值随时间变化<br>蠕变:承受恒定的应变时，指示应变值随时间变化</li><li>允许电流：应变片不因电流放热而影响测量所允许的最大电流</li><li>应变极限：$$\delta&#x3D;\frac{|真实应变-指示应变|}{真实应变}\times 100%$$，应变极限是$$\delta\leq 10%$$时的最大真实应变</li></ul><h5 id="2-3-1-5-应用"><a href="#2-3-1-5-应用" class="headerlink" title="2.3.1.5 应用"></a>2.3.1.5 应用</h5><p>位移传感器</p><p>力传感器：悬臂梁型，轮辐型</p><p>压力传感器</p><p>加速度传感器</p><h4 id="2-3-2-热电阻检测元件"><a href="#2-3-2-热电阻检测元件" class="headerlink" title="2.3.2 热电阻检测元件"></a>2.3.2 热电阻检测元件</h4><p>原理：热电阻效应，导体或半导体的电阻率随温度变化</p><p>应用：工业测温，灵敏度高，稳定性、互换性好，精度高;中、低温度(-200~650℃)范围</p><p>类型：正的电阻温度系数，今每升高1℃电阻约增加0.4%<del>0.6%；负温度系数，温度每升高1℃，电阻约减小2%</del>6%</p><h5 id="2-3-2-1-金属热电阻"><a href="#2-3-2-1-金属热电阻" class="headerlink" title="2.3.2.1 金属热电阻"></a>2.3.2.1 金属热电阻</h5><ul><li>电阻温度系数大，温度增加时，其电阻值有明显变化</li><li>物理和化学性能稳定，不易被介质腐蚀</li><li>较高的电阻率，以减小尺寸、减小热惯性</li><li>电阻随温度变化保持单值函数，最好是线性关系</li><li>易于得到高纯物质，复现性好，价格便宜。</li></ul><p>(1)铂电阻</p><ul><li>优点：物理化学性能非常稳定，耐氧化性，电阻率较高、复现性好、精度高;高精度温度测量;基准电阻和标准热电阻</li><li>不足：电阻温度系数较小，在还原性介质中工作易于变脆，贵金属，价格较高</li><li>范围：-200℃~850℃;在高温下，只适合在氧化气氛中使用，真空和还原气氛会导致电阻值与温度的关系改变。</li><li>纯度：标准器&gt;1.3925;工业1.3900~1.3920</li></ul><p>温度特性：非线性<br>$$<br>R_t&#x3D;R_0(1+At+Bt^2)\ \ \ \ \ \ \ (0&lt;t&lt;850°C)\<br>R_t&#x3D;R_0{1+At+Bt^2+C[t^3(t-100)]}\ \ \ \ \ \ \ (-200&lt;C&lt;0°C)<br>$$<br>电阻比$$W_{100}&#x3D;\frac{R_{100}}{R_{0}}，R_{100}是t&#x3D;100°C时电阻值,R_0同理$$</p><p>(2)铜电阻</p><ul><li>优点：电阻温度系数大，易加工和提纯，线性较好，价格便宜</li><li>不足：易被氧化(超过100℃)，电阻率小，体积大，热性大</li><li>范围：-50~150℃</li></ul><p>$$<br>R_t&#x3D;R_0(1+At+Bt^2+Ct^3)<br>$$</p><p><img src="/img/chuangan/ScreenShot_2025-11-04_130205_779.png"></p><p>热电阻优点：可远传信号灵敏度高、精度高稳定性强互换性、准确性好</p><p>热电阻缺点：需要电源激励、温度不能太高、不能瞬时测量温度变化</p><p><img src="/img/chuangan/ScreenShot_2025-11-04_130318_692.png"></p><p>测量误差：</p><ul><li>自热误差<ul><li>金属热电阻组成测量电路时，通电会发热引起电阻值变化</li><li>限制电流，规定其值应不超过6mA</li></ul></li><li>引线电阻引入的误差<ul><li>连接金属热电阻的导线有一定长度，金属热电阻自身的电阻值较小，所以引线的电阻值及其变化就不能忽略</li><li>采用三线制或四线制接法</li></ul></li></ul><h5 id="2-3-2-2-热敏电阻"><a href="#2-3-2-2-热敏电阻" class="headerlink" title="2.3.2.2 热敏电阻"></a>2.3.2.2 热敏电阻</h5><ul><li>原理：半导体材料的电阻率随温度显著变化</li><li>优点：灵敏度高(金属热电阻的十几倍)、阻值高(数千欧姆以上)、体积小、热惯性小、连接导线影响小;制作简单、价格低廉、使用方便、易于大批量生产</li><li>缺点：互换性差、热电特性为非线性</li><li>范围：-50~350℃℃，温度控制、精度要求不太高的温度测量</li></ul><p>负温度系数热敏电阻NTC，正温度系数热敏电阻PTC</p><p>NTC：$$R_T&#x3D;R_{T_0}exp[B(\frac{1}{T}-\frac{1}{T_0})]$$<img src="/img/chuangan/ScreenShot_2025-11-04_130912_627.png"></p><p>PTC：$$R_T&#x3D;R_{T_0}exp[B_p(T-T_0)]$$</p><p><img src="/img/chuangan/ScreenShot_2025-11-04_130945_421.png"></p><h4 id="2-3-3-湿敏电阻"><a href="#2-3-3-湿敏电阻" class="headerlink" title="2.3.3 湿敏电阻"></a>2.3.3 湿敏电阻</h4><ul><li>湿度：表示空气中水蒸气含量的物理量</li><li>绝对湿度：一定温度及压力条件下，每单位体积的混合气体中所含水蒸汽的质量(g&#x2F;m3)</li><li>相对湿度(RH)：指气体的绝对湿度与同一温度下达到饱和状态的绝对湿度的比值(%)</li></ul><p>应用最为广泛的湿度检测元件，原理简单、易于实现：感湿膜</p><p>感湿膜具有微型孔状结构，易吸收空气中的水分，引起其电阻率或电导率的变化，通过测量电阻或电导就可以达到<br>测量湿度的目的。</p><p><img src="/img/chuangan/ScreenShot_2025-11-04_131219_187.png"></p><h4 id="2-3-4-气敏电阻"><a href="#2-3-4-气敏电阻" class="headerlink" title="2.3.4 气敏电阻"></a>2.3.4 气敏电阻</h4><ul><li>原理：某些半导体与特定气体接触时，其电阻值发生变化，变化量与气体浓度有关。主要用于测量可燃性气体的浓度</li><li>特点：灵敏度高，响应快</li><li>材料：氧化锡(SnO2)、氧化锌(ZnO)、三氧化二铁(Fe2O3)和五氧化二钒(V2O5)等</li></ul><h5 id="2-3-4-1-氧化锡SnO2"><a href="#2-3-4-1-氧化锡SnO2" class="headerlink" title="2.3.4.1 氧化锡SnO2"></a>2.3.4.1 氧化锡SnO2</h5><p>N型半导体，构成形式包括:</p><ul><li>烧结体型：以多孔质陶瓷为基本材料、添加不同的物质烧结而成</li><li>薄膜型：采用淀积、溅射等工艺在绝缘衬底上涂一层半导体薄膜</li><li>厚膜型：一般是把氧化物材料粉末、添加剂、粘合剂以及载体配成浆料然后再将浆料印刷在基片上而成</li></ul><p><img src="/img/chuangan/ScreenShot_2025-11-04_131558_117.png"></p><h5 id="2-3-4-2-氧化锌ZnO"><a href="#2-3-4-2-氧化锌ZnO" class="headerlink" title="2.3.4.2 氧化锌ZnO"></a>2.3.4.2 氧化锌ZnO</h5><p><img src="/img/chuangan/ScreenShot_2025-11-04_131628_285.png"></p><p>应用：CO气体传感器，CH4气体传感器</p><h3 id="2-4-电容式检测元件"><a href="#2-4-电容式检测元件" class="headerlink" title="2.4 电容式检测元件"></a>2.4 电容式检测元件</h3><p>将待测物理量转变为电容量变化的一类传感器</p><ul><li>优点：结构简单、功耗低、动态特性好、非接触测量</li><li>缺点：初始电容、变化量小，受寄生电容及外界干扰影响</li></ul><h4 id="2-4-1-工作原理"><a href="#2-4-1-工作原理" class="headerlink" title="2.4.1 工作原理"></a>2.4.1 工作原理</h4><p><img src="/img/chuangan/ScreenShot_2025-11-04_131936_848.png"><br>$$<br>C&#x3D;\epsilon\frac{A}{d}&#x3D;\epsilon_0\epsilon_r\frac{A}{d}\ \ \ \ \ \ \ \ \ \ C&#x3D;\frac{2\pi\epsilon_0\epsilon_rl}{ln\frac{R}{r}}<br>$$</p><h5 id="2-4-1-1-变极距式d"><a href="#2-4-1-1-变极距式d" class="headerlink" title="2.4.1.1 变极距式d"></a>2.4.1.1 变极距式d</h5><p><img src="/img/chuangan/ScreenShot_2025-11-04_132440_536.png"><br>$$<br>C &#x3D; C_0 + \Delta C &#x3D; \varepsilon \frac{A}{d_0 - \Delta d} &#x3D; \varepsilon \frac{A}{d_0} \cdot \frac{1}{1 - \frac{\Delta d}{d_0}} &#x3D; C_0 \left[ \frac{1}{1 - \frac{\Delta d}{d_0}} \right]\\Delta C &#x3D; C - C_0 &#x3D; C_0 \left[ \frac{\frac{\Delta d}{d_0}}{1 - \frac{\Delta d}{d_0}} \right]<br>$$<br><img src="/img/chuangan/ScreenShot_2025-11-04_132504_054.png"></p><p>灵敏度：经幂级数展开有<br>$$<br>\frac{\Delta C}{C_0}&#x3D;\frac{\Delta d}{d_0}\K_C&#x3D;\frac{\Delta C}{\Delta d}&#x3D;\frac{C_0}{d_0}&#x3D;\frac{\epsilon A}{d^2}\<br>\delta &#x3D; \frac{\Delta C - \Delta C’}{\Delta C} &#x3D; -\left[ \frac{\Delta d}{d_0} + \left( \frac{\Delta d}{d_0} \right)^2 + \left( \frac{\Delta d}{d_0} \right)^3 + \cdots \right]<br>$$<br>但是这种计算方法的近似存在非线性误差，用差动式电容可以减小此误差</p><p><img src="/img/chuangan/ScreenShot_2025-11-04_133022_636.png"></p><p>▲C可由电容串联推理得到。<br>$$<br>\frac{\Delta C}{C_0}&#x3D;2\frac{\Delta d}{d_0}\<br>K_C&#x3D;\frac{\Delta C}{\Delta d}&#x3D;2\frac{C_0}{d_0}\<br>\delta &#x3D; \frac{\Delta C - \Delta C’}{\Delta C} &#x3D; -\left[ \left( \frac{\Delta d}{d_0} \right)^2 + \left( \frac{\Delta d}{d_0} \right)^4 + \left( \frac{\Delta d}{d_0} \right)^6 + \cdots \right]<br>$$<br>灵敏度上升，非线性误差和环境影响下降。</p><p><img src="/img/chuangan/ScreenShot_2025-11-04_134134_682.png"></p><p><img src="/img/chuangan/ScreenShot_2025-11-04_134151_102.png"></p><p>上面的是近似后的相对变化率，中间的是实际的相对变化率，δ是两者之间的非线性误差：上面×(1+δ)&#x3D;中间</p><p>记住变化后C公式，▲C公式以及近似的相对变化率。</p><h5 id="2-4-1-2-变面积式"><a href="#2-4-1-2-变面积式" class="headerlink" title="2.4.1.2 变面积式"></a>2.4.1.2 变面积式</h5><p><img src="/img/chuangan/ScreenShot_2025-11-04_135103_308.png"></p><p>线位移测量：</p><p><img src="/img/chuangan/ScreenShot_2025-11-04_135145_007.png"><br>$$<br>\Delta C&#x3D;C_0-C&#x3D;\frac{2\pi\epsilon_0}{ln\frac{R}{r}}\Delta l<br>$$<br>角位移测量：</p><p><img src="/img/chuangan/ScreenShot_2025-11-04_135309_493.png"><br>$$<br>A&#x3D;A_0-\theta r^2&#x2F;2\ \ \ \ \ \ \ \ \ \ A_0&#x3D;\pi r^2&#x2F;2\<br>A&#x3D;A_0(1-\frac{\theta}{\pi})\<br>\Delta A&#x3D;A_0\frac{\theta}{\pi}\<br>\Delta C&#x3D;\frac{\epsilon_0}{d}\Delta A&#x3D;\frac{\epsilon_0}{d}A_0\frac{\theta}{\pi}&#x3D;C_0\frac{\theta}{\pi}\<br>K_C&#x3D;\frac{\Delta C}{\theta}&#x3D;\frac{1}{\pi}C_0<br>$$</p><h5 id="2-4-1-3-变介电常数"><a href="#2-4-1-3-变介电常数" class="headerlink" title="2.4.1.3 变介电常数"></a>2.4.1.3 变介电常数</h5><p>$$\Delta C&#x3D;\frac{A}{d}\Delta \epsilon $$，直接测定：介电常数、厚度、位移；间接测定：温度、湿度</p><p><img src="/img/chuangan/ScreenShot_2025-11-04_180431_847.png"></p><p>(1)串联结构</p><p><img src="/img/chuangan/ScreenShot_2025-11-04_180520_547.png"><br>$$<br>C_0&#x3D;\epsilon_0\frac{A}{d_0}\<br>C&#x3D;\frac{C_1C_2}{C_1+C_2}&#x3D;\frac{\epsilon_{r1}\epsilon_0A}{d_1+\epsilon_{r1}(d_0-d_1)}\<br>\Delta C&#x3D;C_0\frac{\epsilon_{r1}-1}{1+\epsilon_{r1}\frac{d_0-d_1}{d_1}}<br>$$<br>(2)并联结构</p><p><img src="/img/chuangan/ScreenShot_2025-11-04_181033_140.png"><br>$$<br>C_0 &#x3D; \varepsilon_0 \frac{A_1 + A_2}{d_0}\</p><p>C &#x3D; C_1 + C_2 &#x3D; \frac{\varepsilon_{r1}\varepsilon_0 A_1}{d_0} + \frac{\varepsilon_0 A_2}{d_0}\</p><p>\Delta C &#x3D; C - C_0 &#x3D; C_0 \frac{\varepsilon_0 A_1 (\varepsilon_{r1} - 1)}{d_0}\</p><p>A_1 &#x3D; wl\<br>$$<br>(3)串并联结构</p><p><img src="/img/chuangan/ScreenShot_2025-11-04_181211_157.png"><br>$$<br>C &#x3D; \frac{C_1 C_2}{C_1 + C_2} + C_3 &#x3D; \frac{\varepsilon_{r1} \varepsilon_0 w l}{d_1 + \varepsilon_{r1}(d_0 - d_1)} + \frac{\varepsilon_0 w (L - l)}{d_0}<br>$$</p><h4 id="2-4-2-等效电路"><a href="#2-4-2-等效电路" class="headerlink" title="2.4.2 等效电路"></a>2.4.2 等效电路</h4><p><img src="/img/chuangan/ScreenShot_2025-11-04_181426_892.png"></p><ul><li>C为电容式传感器</li><li>Rp为并联损耗，包括极板间泄漏电阻和介质损耗等;</li><li>Rs为串联损耗，包括引线电阻、极板电阻和金属支架电阻</li><li>L由电容器自身电感和引线电感组成，与电容器的结构形式及引线长度有关;</li><li>Cp为寄生电容</li></ul><h5 id="2-4-2-1-有效电容"><a href="#2-4-2-1-有效电容" class="headerlink" title="2.4.2.1 有效电容"></a>2.4.2.1 有效电容</h5><p>对于任一谐振频率以下的频率，由于L的存在，检测元件的有效电容Ce在忽略Rp、Rs的影响时，可表示为<br>$$<br>C_e&#x3D;\frac{C}{1-\omega^2LC}\<br>\frac{\Delta C_e}{C_e}&#x3D;\frac{\Delta C}{C}[\frac{C}{1-\omega^2LC}]<br>$$<br>测量时必须与校准时处于相同条件；改变激励频率或者更换电缆时，都要重新进行标定</p><h4 id="2-4-3-温度与寄生电容影响"><a href="#2-4-3-温度与寄生电容影响" class="headerlink" title="2.4.3 温度与寄生电容影响"></a>2.4.3 温度与寄生电容影响</h4><p>消除温度对电容的影响：</p><p><img src="/img/chuangan/ScreenShot_2025-11-04_182224_208.png"></p><p>消除寄生电容的影响</p><p><img src="/img/chuangan/ScreenShot_2025-11-04_182228_866.png"></p><h4 id="2-4-4-应用"><a href="#2-4-4-应用" class="headerlink" title="2.4.4 应用"></a>2.4.4 应用</h4><p>位移传感器、压力传感器、重量传感器、主轴回转精度传感器、指纹传感器、电容式键盘、液位传感器、湿度传感器</p><p><img src="/img/chuangan/ScreenShot_2025-11-04_182622_925.png"><img src="/img/chuangan/ScreenShot_2025-11-04_182629_849.png"><img src="/img/chuangan/ScreenShot_2025-11-04_182636_087.png"><img src="/img/chuangan/ScreenShot_2025-11-04_182641_008.png"><img src="/img/chuangan/ScreenShot_2025-11-04_182646_137.png"><img src="/img/chuangan/ScreenShot_2025-11-04_182651_441.png"><img src="/img/chuangan/ScreenShot_2025-11-04_182655_634.png"></p><h3 id="2-5-热电式检测元件"><a href="#2-5-热电式检测元件" class="headerlink" title="2.5 热电式检测元件"></a>2.5 热电式检测元件</h3><p>利用敏感元件将温度变化转换为电量的变化，从而达到测量温度的目的</p><p>优点：结构简单、使用方便、测量准确度高、测量范围宽</p><h4 id="2-5-1-热电效应"><a href="#2-5-1-热电效应" class="headerlink" title="2.5.1 热电效应"></a>2.5.1 热电效应</h4><p>将热电极A、B的两个接点分别置于温度为T和T0(设T&gt;T0)的热源中，则在该回路内就会产生热电动势</p><p>温度高的接点称为热端（工作端、测量端）<br>温度低的接点称为冷端（自由端、参考端）</p><h5 id="2-5-1-1-接触电势"><a href="#2-5-1-1-接触电势" class="headerlink" title="2.5.1.1 接触电势"></a>2.5.1.1 接触电势</h5><p>两种导体同一种温度</p><p><img src="/img/chuangan/ScreenShot_2025-11-04_184328_995.png"><br>$$<br>e_{AB}(T)&#x3D;\frac{kT}{e}ln\frac{N_A}{N_B}<br>$$<br>电子数多的导体为正电势</p><h5 id="2-5-1-2-温差电势"><a href="#2-5-1-2-温差电势" class="headerlink" title="2.5.1.2 温差电势"></a>2.5.1.2 温差电势</h5><p>同一导体不同温度</p><p><img src="/img/chuangan/ScreenShot_2025-11-04_184509_083.png"><br>$$<br>e_A(T,T_0)&#x3D;\int^T_{T_0}\sigma_AdT<br>$$<br>温度高的部分为正电势</p><h5 id="2-5-1-3-回路热电势"><a href="#2-5-1-3-回路热电势" class="headerlink" title="2.5.1.3 回路热电势"></a>2.5.1.3 回路热电势</h5><p><img src="/img/chuangan/ScreenShot_2025-11-04_184909_576.png"><br>$$<br>E_{AB}(T,T_0)&#x3D;[e_{AB}(T)-e_{AB}(T_0)]+[-e_A(T,T_0)+e_B(T,T_0)]\<br>&#x3D;\frac{kT}{e}ln\frac{N_{AT}}{N_{BT}}-\frac{kT_0}{e}ln\frac{N_{AT_0}}{N_{BT_0}}+\int^T_{T_0}(\sigma_B-\sigma_A)dT<br>$$<br>当A&#x3D;B时$$E_{AB}(T,T_0)&#x3D;0$$，当A≠B且T&#x3D;T0时也为0</p><p>故热电偶工作的两个必要条件：<strong>两种导体，两个温度</strong></p><p>与材料的粗细、长度、分布无关</p><h5 id="2-5-1-4-测温原理"><a href="#2-5-1-4-测温原理" class="headerlink" title="2.5.1.4 测温原理"></a>2.5.1.4 测温原理</h5><p>热电极材料确定后，热电势的大小只与T、T0有关；若保持T0一致，则电偶回路总热电势就可看作是温度的单值函数</p><h4 id="2-5-3-热电偶的基本原理"><a href="#2-5-3-热电偶的基本原理" class="headerlink" title="2.5.3 热电偶的基本原理"></a>2.5.3 热电偶的基本原理</h4><h5 id="2-5-3-1-均值导体定律"><a href="#2-5-3-1-均值导体定律" class="headerlink" title="2.5.3.1 均值导体定律"></a>2.5.3.1 均值导体定律</h5><p>同种导体产生的回路不产生热电势</p><h5 id="2-5-3-2-中间导体定律"><a href="#2-5-3-2-中间导体定律" class="headerlink" title="2.5.3.2 中间导体定律"></a>2.5.3.2 中间导体定律</h5><p>回路中接入两端温度相同的第三种导体，不影响热电势的值。</p><p><img src="/img/chuangan/ScreenShot_2025-11-04_190628_180.png"><br>$$<br>E_{ABC}(T,T_0) &#x3D; e_{AB}(T) + e_{BC}(T_0) + e_{CA}(T_0) - \int_{T_0}^{T} \sigma_A dT + \int_{T_0}^{T} \sigma_B dT\<br>\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ &#x3D; \frac{kT}{e} \ln \frac{N_{AT}}{N_{BT}} + \frac{kT_0}{e} \ln \frac{N_{BT_0}}{N_{CT_0}} + \frac{kT_0}{e} \ln \frac{N_{CT_0}}{N_{AT_0}} + \int_{T_0}^{T} (\sigma_B - \sigma_A) dT\<br>\ \ \ \ \ \ \ \ \ \ &#x3D; \frac{kT}{e} \ln \frac{N_{AT}}{N_{BT}} - \frac{kT_0}{e} \ln \frac{N_{AT_0}}{N_{BT_0}} + \int_{T_0}^{T} (\sigma_B - \sigma_A) dT\<br>\ \ \ \ \ \ \ &#x3D; e_{AB}(T) - e_{AB}(T_0) + \int_{T_0}^{T} (\sigma_B - \sigma_A) dT &#x3D;E_{AB}<br>$$</p><h6 id="中间导体定律的应用"><a href="#中间导体定律的应用" class="headerlink" title="中间导体定律的应用"></a>中间导体定律的应用</h6><p>在热电偶回路中接入中间导体(第三导体)，只要中间导体两端温度相同，中间导体的引入对热电偶回路总电势没有影响</p><p><img src="/img/chuangan/ScreenShot_2025-11-04_191535_588.png"></p><p><img src="/img/chuangan/ScreenShot_2025-11-04_191623_306.png"></p><h5 id="2-5-3-3-中间温度定律"><a href="#2-5-3-3-中间温度定律" class="headerlink" title="2.5.3.3 中间温度定律"></a>2.5.3.3 中间温度定律</h5><p><strong>热电偶A、B在接点温度为T，T0时的热电势等于热电偶A、B在接点温度为T、Tc和Tc、T的热电势$$E_{AB}(T,T_C)$$和$$E_{AB}(T_C,T_0)$$的代数和</strong>，即:<br>$$<br>E_{AB}(T,T_0)&#x3D;E_{AB}(T,T_C)+E_{AB}(T_C,T_0)<br>$$<br><img src="/img/chuangan/ScreenShot_2025-11-04_191916_303.png"></p><p><strong>因此只要列出热电势在冷端温度为0°C的分度表，就可求出冷端在其他温度时的热电势值</strong>，如例题</p><p><img src="/img/chuangan/ScreenShot_2025-11-04_192648_390.png"></p><h5 id="2-5-3-4-标准电极定律"><a href="#2-5-3-4-标准电极定律" class="headerlink" title="2.5.3.4 标准电极定律"></a>2.5.3.4 标准电极定律</h5><p>**如果已知两种导体分别对第三种导体的热电势，则前两种导体之间的热电动势可求。**如例题<br>$$<br>E_{AB}(T,T_0)+E_{BC}(T,T_0)&#x3D;E_{AC}(T,T_0)<br>$$<br><img src="/img/chuangan/ScreenShot_2025-11-04_193409_708.png"></p><p><img src="/img/chuangan/ScreenShot_2025-11-04_193520_649.png"></p><p>纯金属的种类很多，而合金类型更多。因此，要得出这些金属之间组合而成的热电偶的电动势，其工作量是极大的</p><p>由于铂的物理、化学性质稳定，熔点高，易提纯，所以，我们通常选用<strong>高纯铂丝</strong>作为标准电极，只要测得各种金属与纯铂组成的热电偶的热电动势，则各种金属之间相互组合而成的热电偶的热电动势可根据该定律直接计算出来。</p><p>称为标准化热电偶。</p><h4 id="2-5-4-热电偶的材料"><a href="#2-5-4-热电偶的材料" class="headerlink" title="2.5.4 热电偶的材料"></a>2.5.4 热电偶的材料</h4><p>作为测温的热电偶需要满足：</p><ul><li>物理、化学性质稳定</li><li>电极的电阻小，电阻的温度系数小</li><li>热电动势值大，随温度单调上升，最好线性</li><li>材料易获得，复制性好，价格低</li></ul><p>共有8种材料作为标准化热电偶</p><p><img src="/img/chuangan/ScreenShot_2025-11-04_195724_909.png"></p><h4 id="2-5-5-分度表"><a href="#2-5-5-分度表" class="headerlink" title="2.5.5 分度表"></a>2.5.5 分度表</h4><p>不同金属组成的热电偶，温度与热电动势之间有不同的函数关系，一般通过实验的方法来确定，并将不同温度下测得的结果列成表格，编制出热电势与温度的对照表，即分度表。</p><p>供查阅使用，每10℃分档。中间值按内插法计算。<br>$$<br>t_M&#x3D;t_L+\frac{E_M-E_L}{E_H-E_L}(t_H-t_L)<br>$$<br>利用中间温度定律测温：</p><p>以冷端为0°C，建立热端温度与热电动势之间的关系表E(t，0)</p><ol><li>测量工作时的热电动势值E(t，t1)</li><li>根据已知t1，查表得到E(t1，0)</li><li>利用中间温度定律计算$$E(t,0)&#x3D;E(t,t_1)+E(t_1,0)$$</li><li>查表得到被测温度t</li></ol><p><img src="/img/chuangan/ScreenShot_2025-11-04_195135_071.png"></p><h4 id="2-5-6-冷端温度补偿"><a href="#2-5-6-冷端温度补偿" class="headerlink" title="2.5.6 冷端温度补偿"></a>2.5.6 冷端温度补偿</h4><ul><li>根据热电偶测温原理，只有当热电偶的冷端的温度保持不变时，热电动势才是被测温度的单值函数。</li><li>经常使用的分度表及显示仪表，都是以热电偶冷端的温度为0℃为先决条件的。</li><li>实际使用中，因热电偶长度受到一定限制，冷端温度直接受到被测介质与环境温度的影响，不仅难于保持0而且往往是波动的。</li><li>因此，要对热电偶冷端进行温度补偿。</li></ul><h4 id="2-5-7-热电偶的误差"><a href="#2-5-7-热电偶的误差" class="headerlink" title="2.5.7 热电偶的误差"></a>2.5.7 热电偶的误差</h4><ol><li>分度引起的误差：工业上常用的热电偶分度都用标准分度表进行</li><li>冷端温度引起的误差：冷端温度通常不为零，从而会引入误差，温度补偿措施</li><li>测量线路及仪表误差：与热电偶配套的测量电路和仪表，合适的仪表量程</li><li>干扰和漏电引起的误差：周围电磁场的影响可能会使得热电偶回路产生附加电势；绝缘不好造成热电势分流，或把被测对象电源泄漏到热电偶中</li></ol><h4 id="2-5-8-晶体管温度检测元件"><a href="#2-5-8-晶体管温度检测元件" class="headerlink" title="2.5.8 晶体管温度检测元件"></a>2.5.8 晶体管温度检测元件</h4><p>根据半导体原理，晶体管的PN结的伏安特性与温度有关，利用这一特性可构成温度检测元件：有二极管温度检测元件、三极管温度检测元件、集成式温度检测元件</p><h5 id="2-5-8-1-二极管温度检测元件"><a href="#2-5-8-1-二极管温度检测元件" class="headerlink" title="2.5.8.1 二极管温度检测元件"></a>2.5.8.1 二极管温度检测元件</h5><p>$$<br>V_D&#x3D;V_{g0}-\frac{KV}{q}(ln\frac{B}{I_d}+lnT^{\eta})<br>$$</p><p><img src="/img/chuangan/ScreenShot_2025-11-06_100919_684.png"></p><p>如Id为常数，即流过PN结的电则正向偏压仅随温度变化,对于通常的硅PN结材料来说，在-50~150℃的温度区间内，其非线性项很小，可以忽略</p><p>在-40~100℃的温度范围内，其PN结电压与温度具有较好的线性关系。与热电偶相比具有较高的灵敏度。</p><h5 id="2-5-8-2-三极管温度检测元件"><a href="#2-5-8-2-三极管温度检测元件" class="headerlink" title="2.5.8.2 三极管温度检测元件"></a>2.5.8.2 三极管温度检测元件</h5><p>$$<br>V_{be}&#x3D;\frac{KT}{q}ln\frac{I_e}{I_{se}}<br>$$</p><p><img src="/img/chuangan/ScreenShot_2025-11-06_101127_982.png"></p><p>热电偶：结构简单、使用方便；准确度高；测温范围宽；需要考虑冷端补偿；输出信号小</p><p>晶体管：测温灵敏度高；具有良好的线性；时间常数小；功耗低；抗干扰能力强；便于集成</p><h3 id="2-6-压电式检测元件"><a href="#2-6-压电式检测元件" class="headerlink" title="2.6 压电式检测元件"></a>2.6 压电式检测元件</h3><p>压电式敏感元件是利用压电材料的压电效应工作的。当其受到外力作用时，压电材料的表面将产生电荷，因而是一种典型的有源器件</p><h4 id="2-6-1-压电效应"><a href="#2-6-1-压电效应" class="headerlink" title="2.6.1 压电效应"></a>2.6.1 压电效应</h4><p>正压电效应：某些电介质在沿一定方向受外力(压力或拉力)时，其内部正负电荷中心会发生相对位移产生极化现象，从而在它的两个相对的表面上集聚正负相反的电荷</p><ul><li>作用力越大，则机械变形越大，所产生的电荷量越多</li><li>作用力去掉后，恢复到不带电的状态;动态力变为静态力时，电荷将由于表面漏电而很快泄漏、消失</li><li>作用力的方向改变时，电荷的极性也随之改变;输出电压的频率与动态力的频率相同</li></ul><p>逆压电效应：当在电介质的极化方向上施加电场，这些电介质也会发生变形，电场去掉后，电介质的变形随之消失，这种现象称为逆压电效应，或称为电致伸缩现象。</p><p>压电效应是可逆的。</p><p><img src="/img/chuangan/ScreenShot_2025-11-06_102234_271.png"></p><h4 id="2-6-2-压电材料"><a href="#2-6-2-压电材料" class="headerlink" title="2.6.2 压电材料"></a>2.6.2 压电材料</h4><h5 id="2-6-2-1-石英晶体SiO2"><a href="#2-6-2-1-石英晶体SiO2" class="headerlink" title="2.6.2.1 石英晶体SiO2"></a>2.6.2.1 石英晶体SiO2</h5><p>目前传感器中使用的均是以居里点为573℃，晶体的结构为六角晶系的α-石英，呈六角棱柱体。</p><p><img src="/img/chuangan/ScreenShot_2025-11-06_102557_643.png"></p><p><img src="/img/chuangan/ScreenShot_2025-11-06_102645_775.png"></p><p><img src="/img/chuangan/ScreenShot_2025-11-06_103132_238.png"></p><p>压电效应机理：当石英晶体未受外力作用时，正、负离子正好分布在正六边形的顶角上，每两个相对顶点上的电荷形成一个电偶极矩P1、P2、P3，夹角为120°，它们的矢量和为零。</p><p><img src="/img/chuangan/ScreenShot_2025-11-06_103431_413.png"></p><p><img src="/img/chuangan/ScreenShot_2025-11-06_103436_295.png"></p><ul><li>压电常数小，但时间和温度稳定性极好，常温下几乎不变，在20~200℃范围内其温度变化率仅为-0.016%&#x2F;℃</li><li>机械强度和品质因素高。许用应力高达(6.8~9.8)x10^7Pa，且刚度大，固有频率高，动态特性好;</li><li>居里点573℃，无热释电性，且绝缘性、重复性均好</li></ul><p>常用于精度和稳定性要求高的场合和制作标准传感器</p><h5 id="2-6-2-2-压电陶瓷"><a href="#2-6-2-2-压电陶瓷" class="headerlink" title="2.6.2.2 压电陶瓷"></a>2.6.2.2 压电陶瓷</h5><p>具有与磁畴材料磁畴结构类似的电畴结构</p><p><img src="/img/chuangan/ScreenShot_2025-11-06_110450_354.png"></p><p><img src="/img/chuangan/ScreenShot_2025-11-06_110531_884.png"></p><p><img src="/img/chuangan/ScreenShot_2025-11-06_110616_745.png"></p><p><img src="/img/chuangan/ScreenShot_2025-11-06_111114_180.png"></p><h5 id="2-6-2-3-其他压电材料"><a href="#2-6-2-3-其他压电材料" class="headerlink" title="2.6.2.3 其他压电材料"></a>2.6.2.3 其他压电材料</h5><p>压电高分子材料、压电半导体、复合压电材料、压电涂层</p><h4 id="2-6-3-等效电路"><a href="#2-6-3-等效电路" class="headerlink" title="2.6.3 等效电路"></a>2.6.3 等效电路</h4><p>当压电元件受外力作用时，会在一个极板上聚集正电荷，另一个极板上聚集等量的负电荷，因此它相当于一个电荷源(静电发生器)</p><p>当压电元件电极表面聚集电荷时，它又相当于一个以压电材料为电介质的电容器。</p><p><img src="/img/chuangan/ScreenShot_2025-11-06_111732_427.png"></p><p>压电传感器不适合静态测量。</p><p>压电器件是一个有源电容器，存在与电容传感器相同的应用弱点-高内阻、小功率问题，必须进行前置放大，前置阻抗变换。压电传感器的测量电路有两种形式：电压放大器和电荷放大器。</p><p><img src="/img/chuangan/ScreenShot_2025-11-06_112345_701.png"></p><ul><li>从作用力看，元件是串接的，因而每片受到的作用力相同，产生的变形和电荷数量大小都与单片时相同。</li><li>并联接法类似两个电容的并联，外力作用下正负电极上的电荷量增加了1倍，电容量也增加了1倍，输出电压与单片时相同。</li><li>串联接法两压电片中间粘接处正负电荷中和，上、下极板的电荷量与单片时相同，总电容量为单片的一半，输出电压增大了1倍。</li></ul><p><img src="/img/chuangan/ScreenShot_2025-11-06_112416_168.png"></p><p><img src="/img/chuangan/ScreenShot_2025-11-06_112423_640.png"></p><h4 id="2-6-4-压电检测元件的误差"><a href="#2-6-4-压电检测元件的误差" class="headerlink" title="2.6.4 压电检测元件的误差"></a>2.6.4 压电检测元件的误差</h4><h5 id="2-6-4-1-温度引起误差"><a href="#2-6-4-1-温度引起误差" class="headerlink" title="2.6.4.1 温度引起误差"></a>2.6.4.1 温度引起误差</h5><p>压电系数、介电常数、体电阻和弹性模量等参数发生变化</p><p>瞬态环境温度变化对检测元件也会产生较大影响：</p><ul><li>选用灵敏度随温度变化较小的检测元件。</li><li>受瞬变温度影响较小的检测元件</li><li>采用隔热片，以减少温度的影响;</li><li>采用温度补偿片，通过它的的热膨胀变形来起抵消壳体等部件变形的作用</li><li>压电材料的温度上限为1&#x2F;2居里温度。超过有效温度会引起较大测量误差。</li></ul><h5 id="2-6-4-2-噪声变化"><a href="#2-6-4-2-噪声变化" class="headerlink" title="2.6.4.2 噪声变化"></a>2.6.4.2 噪声变化</h5><p>元件受振动引起的噪声</p><p>电缆受到振动和弯曲会由于摩擦引入感应电荷：</p><ul><li>隔离基座，独立外壳</li><li>低噪声电缆、紧固电缆</li><li>阻抗变换器</li></ul><h5 id="2-6-4-3-灵敏度变化"><a href="#2-6-4-3-灵敏度变化" class="headerlink" title="2.6.4.3 灵敏度变化"></a>2.6.4.3 灵敏度变化</h5><p>随时间延续而变化<br>每半年进行一次校正(石英晶体稳定性好)</p><h5 id="2-6-4-4-安装差异"><a href="#2-6-4-4-安装差异" class="headerlink" title="2.6.4.4 安装差异"></a>2.6.4.4 安装差异</h5><p>安装面具有较高的平行度、平直度和较低的粗糙度<br>事先给压电片有一定的预应力</p><h4 id="2-6-5-应用"><a href="#2-6-5-应用" class="headerlink" title="2.6.5 应用"></a>2.6.5 应用</h4><p>加速度传感器（安全气囊）、力和压力传感器（血压传感器、压电式纵跳训练装置、水深测量、刀具切削力传感器）、振动传感器（地震、玻璃打碎预警）、点火器、超声波产生与接收。</p><h3 id="2-7-光电式传感元件"><a href="#2-7-光电式传感元件" class="headerlink" title="2.7 光电式传感元件"></a>2.7 光电式传感元件</h3><p>光电式检测元件是将光信号转换为电信号的元件，物理基础是光电效应</p><h4 id="2-7-1-光源"><a href="#2-7-1-光源" class="headerlink" title="2.7.1 光源"></a>2.7.1 光源</h4><ul><li>照度要求：足够亮度、光通量，保证信噪比和灵敏度</li><li>均匀要求：视场亮度均匀、无阴影，避免测量误差</li><li>投影要求：控制光的方向、透射、反射、散射</li><li>发热要求：热光源、冷光源，减小发热对测量结果的影响</li><li>光谱要求：光波频率、波长:紫外→可见光→红外</li></ul><p><img src="/img/chuangan/ScreenShot_2025-11-06_135028_332.png"></p><h5 id="2-7-1-1-热辐射光源"><a href="#2-7-1-1-热辐射光源" class="headerlink" title="2.7.1.1 热辐射光源"></a>2.7.1.1 热辐射光源</h5><p>白炽灯：钨丝卤钨灯：钨丝+卤素(碘)<br>特点：谱线丰富，可见光+红外光，峰值在近红外区；发光效率低，15%在可见光；发热大，&gt;80%能量转化为热能；寿命短(1000小时)，易碎，电压高，有危险。<br>应用：可见光源–宽光谱(滤色片→窄带光谱)、近红外光源 -红外检测</p><h5 id="2-7-1-2-气体放电光源"><a href="#2-7-1-2-气体放电光源" class="headerlink" title="2.7.1.2 气体放电光源"></a>2.7.1.2 气体放电光源</h5><p>气体分子激发→放电→发光<br>弧光灯：碳弧灯；钠弧灯；氙弧灯；水银弧灯(汞灯)；金卤灯<br>荧光灯：气体放电+荧光粉，波长更长<br>日光灯：光谱接近日光<br>节能灯：压缩荧光灯<br>特点：效率高，省电;功率大，光色接近日光;紫外线丰富，有辐射;废弃物有汞污染、易碎，对人眼有损害<br>应用：强光、色温要求接近日光</p><h5 id="2-7-1-3-发光二极管"><a href="#2-7-1-3-发光二极管" class="headerlink" title="2.7.1.3 发光二极管"></a>2.7.1.3 发光二极管</h5><p>半导体，电致发光<br>单色LED：红色、绿色、黄色、橙色、蓝色<br>白色LED：光谱丰富—(蓝+黄)&#x2F;(蓝+绿+红)；亮度高—荧光灯5倍，白炽灯的25倍<br>特点：体积小，可平面封装，固体光源，无辐射，绿色光源;功耗低(白炽灯1&#x2F;8，荧光灯1&#x2F;2)发热少寿命长(10万小时，是荧光灯的10倍)、耐振动、响应快(毫秒级)、供电电压低、易于数字控制;价格较白炽灯贵，功率低<br>应用:指示灯、背光源；仪器光源、室内照明</p><h5 id="2-7-1-4-激光光源"><a href="#2-7-1-4-激光光源" class="headerlink" title="2.7.1.4 激光光源"></a>2.7.1.4 激光光源</h5><p>主要特点：</p><ul><li>方向性好：发散角很小(约0.18°)，比普通光小2~3数量；</li><li>亮度高：能量高度集中，比普通光高几百万倍</li><li>单色性好：光谱范围极小，He-Ne激光：λ&#x3D;632.8nm、$$\Delta \lambda&#x3D;10^{-6}nm$$</li><li>相干性好：受激辐射，传播方向&#x2F;振动方向&#x2F;频率&#x2F;相位一致，时间相干性、空间相干性均好</li></ul><p>固体激光器：体积小，坚固，功率高</p><p>气体激光器：小巧、单色性好、能连续工作、功率小;高光束质量、高稳定性、长寿命、低噪音、经济</p><p>半导体激光器：效率高、体积小、重量轻、结构简单、功率高、非线性</p><h5 id="2-7-1-5-基本概念"><a href="#2-7-1-5-基本概念" class="headerlink" title="2.7.1.5 基本概念"></a>2.7.1.5 基本概念</h5><ul><li>辐射能(焦耳)：光源所发出的能量;</li><li>辐射通量(瓦)：每秒所发出的辐射能;</li><li>光通量(流明)：辐射通量x发光效率，影响人眼视觉明暗;</li><li>照度(Ix)：单位面积上的光通量</li></ul><p><img src="/img/chuangan/ScreenShot_2025-11-06_142050_320.png"></p><h4 id="2-7-2-光电效应"><a href="#2-7-2-光电效应" class="headerlink" title="2.7.2 光电效应"></a>2.7.2 光电效应</h4><p>电子发射、电位、电导率、电流</p><h5 id="2-7-2-1-外光电效应"><a href="#2-7-2-1-外光电效应" class="headerlink" title="2.7.2.1 外光电效应"></a>2.7.2.1 外光电效应</h5><p>物质受到光照后，内部电子逸出物体表面的现象，也称为光电发射效应，多发生于金属和金属氧化物：光电管、光电倍增管</p><p>外光电效应的规律：</p><ul><li>光谱成分不变时，光电流的大小与入射光的强度成正比</li><li>入射光子的能量E大于该物质的表面逸出功A0</li></ul><p>$$<br>E&#x3D;hv&#x3D;\frac{1}{2}mv_0^2+A_0(光电子最大动能)\<br>\lambda_0&#x3D;\frac{hc}{A_0}(红限波长)<br>$$</p><h5 id="2-7-2-2-内光电效应"><a href="#2-7-2-2-内光电效应" class="headerlink" title="2.7.2.2 内光电效应"></a>2.7.2.2 内光电效应</h5><p>物质受到光照后所产生的光电子只在物质内部运动，而不会逸出物质外部的现象。多发生于半导体内</p><p>光电导效应：某些物体受到光照时，其内部原子释放的电子留在物体内部而使得物体的导电性增加，电阻值下降（光敏电阻）</p><p>光生伏特效应：某些物体受到光照时，会产生一定方向的电动势（光电池、光敏二极管、光敏三极管）</p><h4 id="2-7-3-光电器件的基本特性"><a href="#2-7-3-光电器件的基本特性" class="headerlink" title="2.7.3 光电器件的基本特性"></a>2.7.3 光电器件的基本特性</h4><p><img src="/img/chuangan/ScreenShot_2025-11-06_143352_553.png"></p><h4 id="2-7-4-光敏元件"><a href="#2-7-4-光敏元件" class="headerlink" title="2.7.4 光敏元件"></a>2.7.4 光敏元件</h4><h5 id="2-7-4-1-外光电效应——真空光电管"><a href="#2-7-4-1-外光电效应——真空光电管" class="headerlink" title="2.7.4.1 外光电效应——真空光电管"></a>2.7.4.1 外光电效应——真空光电管</h5><p>光电管由一个阴极和一个阳极构成，密封在一只真空玻璃管内。阴极装在玻璃管内壁上，其上涂有光电发射材料。阳极通常用金属丝弯曲成矩形或圆形，置于玻璃管的中央。</p><p><img src="/img/chuangan/ScreenShot_2025-11-06_144047_871.png"><img src="/img/chuangan/ScreenShot_2025-11-06_144126_963.png"></p><p>伏安特性：在一定的光照射下，才对光电器件的阴极所加电压与阳极所产生的电流之间的关系称为光电管的伏安特性。它是应用光电传感器参数的主要依据</p><p><img src="/img/chuangan/ScreenShot_2025-11-06_144255_260.png"></p><p>光照特性：当外加电压一定时，光电流与光通量之间的关系，称为光电管的光照特性。<br>光照特性曲线的斜率称为光电管的灵敏度</p><p><img src="/img/chuangan/ScreenShot_2025-11-06_144501_994.png"></p><p>光谱特性：光电阴极材料对不同波长的光具有不同的灵敏度，这就是光电管的光谱特性。银氧铯阴极和锑铯阴极的响应范围分别在近红外和可见光区域</p><p><img src="/img/chuangan/ScreenShot_2025-11-06_144708_002.png"></p><h5 id="2-7-4-2-外光电效应——光电倍增管"><a href="#2-7-4-2-外光电效应——光电倍增管" class="headerlink" title="2.7.4.2 外光电效应——光电倍增管"></a>2.7.4.2 外光电效应——光电倍增管</h5><p>当入射光很弱时，光电管产生的光电流很弱(零点几μA)，不易检测，误差也大。</p><p><img src="/img/chuangan/ScreenShot_2025-11-06_144342_661.png"></p><p><img src="/img/chuangan/ScreenShot_2025-11-06_144349_682.png"></p><h5 id="2-7-4-3-内光电效应——光敏电阻"><a href="#2-7-4-3-内光电效应——光敏电阻" class="headerlink" title="2.7.4.3 内光电效应——光敏电阻"></a>2.7.4.3 内光电效应——光敏电阻</h5><p>光敏电阻是利用光电导效应原理工作的</p><ul><li>在无光照时，光敏电阻呈高阻态(MΩ级)，回路中仅有微弱的电流。</li><li>在有光照时，内部电子从价带越过禁带跃迁到导带，并在价带留下空穴，从而使得载流子(电子-空穴对)浓度增加，导电性能增强，电阻值下降(kΩ级)。</li><li>利用检流计可以检测到电流随光照强度的变化(或者测量负载电阻的压降)，即，光照越强，光敏电阻的阻值越小，回路中的电流越大。</li></ul><p><img src="/img/chuangan/ScreenShot_2025-11-06_145321_402.png"></p><p>种类很多：如硫化镉、硫化铅、硫化铊、硒化镉、硒化铅等。由于材料、工艺不同，其光电性能也相差很大</p><p>(1)暗电阻、暗电流：光敏电阻在无光照时所测得的电阻值称为暗电阻，此时在给定工作电压下流过的电流称为暗电流。<br>(2)亮电阻、亮电流：光敏电阻在有光照时的电阻值称为亮电阻，此时在给定工作电压下流过的电流称为亮电流。<br>(3)光电流：亮电流与暗电流之差称为光电流。</p><ul><li>光敏电阻的暗电阻越大，亮电阻越小，即暗电流小而亮电流大，因而其灵敏度越高。</li><li>实际用的光敏电阻，其暗电阻一般为1~100MQ，而亮电阻则在几千欧以下，可见光敏电阻的灵敏度是相当高的。</li></ul><p><strong>伏安特性</strong>：</p><ul><li>在一定光照下，光敏电阻的光电流与两端所加电压的关系</li><li>光电流随外加电压线性增加，且没有饱和现象，但实际上电压不可能无限增大，一般不允许超过额定功耗线。</li></ul><p><img src="/img/chuangan/ScreenShot_2025-11-06_145854_692.png"></p><p><strong>光照特性</strong>：</p><ul><li>在一定电压下，光敏电阻的光电流与光照强度的关系</li><li>不同光敏电阻的光照特性不同，且大多数情况是非线性的，一般用于控制系统的开关信号，不宜作为线性测量元件。</li></ul><p><img src="/img/chuangan/ScreenShot_2025-11-06_150255_560.png"></p><p><strong>光谱特性</strong>：</p><ul><li>光敏电阻对不同波长的光具有不同的灵敏度</li><li>不同材料的光敏电阻，其光谱响应范围是不同的，这也决定了它们的使用范围不一样</li></ul><p><img src="/img/chuangan/ScreenShot_2025-11-06_150518_289.png"></p><p><strong>频率特性</strong>：</p><ul><li>光敏电阻的光电流不能随着光照强度改变而立即变化，这是此类器件的缺点之一</li><li>硫化铅的频率响应范围最宽，而其他光敏电阻的响应范围则都比较窄</li></ul><p><img src="/img/chuangan/ScreenShot_2025-11-06_150713_211.png"></p><p><strong>温度特性</strong>：</p><ul><li>光敏电阻受温度影响很大。随着温度升高，光敏电阻的暗电流增加，灵敏度降低，因此这类元件宜用于低温环境。</li><li>硫化铅光敏电阻的峰值波长会随着温度升高而蓝移</li></ul><p><img src="/img/chuangan/ScreenShot_2025-11-06_150818_608.png"></p><h5 id="2-7-4-4-内光电效应——光电池"><a href="#2-7-4-4-内光电效应——光电池" class="headerlink" title="2.7.4.4 内光电效应——光电池"></a>2.7.4.4 内光电效应——光电池</h5><ul><li>利用光生伏特效应直接将光能转换为电能</li><li>硅光电池、硒光电池、锗光电池、砷化镓光电池、氧化亚铜光电池</li><li>短路电流、负载电压、开路电压</li></ul><p><img src="/img/chuangan/ScreenShot_2025-11-06_151225_127.png"></p><p><strong>光电池基本特性</strong>：</p><p><img src="/img/chuangan/ScreenShot_2025-11-06_151310_331.png"></p><p><img src="/img/chuangan/ScreenShot_2025-11-06_151322_897.png"></p><p>应用:宇航飞行仪器，仪表电源，便携仪表(计算器)开关测量(开路电压输出)，线性检测(短路电流输出)</p><h5 id="2-7-4-5-光敏晶体管"><a href="#2-7-4-5-光敏晶体管" class="headerlink" title="2.7.4.5 光敏晶体管"></a>2.7.4.5 光敏晶体管</h5><h6 id="2-7-4-5-1-光敏二极管"><a href="#2-7-4-5-1-光敏二极管" class="headerlink" title="2.7.4.5.1 光敏二极管"></a>2.7.4.5.1 光敏二极管</h6><ul><li>在无光照时，处于截止状态，反向饱和电流极小;</li><li>当受到光照时，产生光生载流子，反向饱和电流增加约1000倍;</li><li>极好的线性，更好的频率特性</li></ul><p><img src="/img/chuangan/ScreenShot_2025-11-06_151640_372.png"></p><h6 id="2-7-4-5-2-光敏三极管"><a href="#2-7-4-5-2-光敏三极管" class="headerlink" title="2.7.4.5.2 光敏三极管"></a>2.7.4.5.2 光敏三极管</h6><p>当光照射到集电极(c)和基极(b)的PN结时，产生的光电子在反向偏压下流向集电极，空穴流向基极，形成由集电极到发射极的电流(相当于普通三极管的基极电流Ib)，同时使发射极和基极之间的正向偏压升高，于是便有大量电子经基极流向集电极，形成集电极电流Ic。结果表现为，基极电流被放大了，因而光敏三极管比光敏二极管具有更高的灵敏度。</p><p><img src="/img/chuangan/ScreenShot_2025-11-06_151937_592.png"></p><p><strong>光敏晶体管基本特性</strong>：</p><p><img src="/img/chuangan/ScreenShot_2025-11-06_152129_729.png"></p><p><img src="/img/chuangan/ScreenShot_2025-11-06_152208_551.png"></p><h6 id="2-7-4-5-3-其他类型光敏元件"><a href="#2-7-4-5-3-其他类型光敏元件" class="headerlink" title="2.7.4.5.3 其他类型光敏元件"></a>2.7.4.5.3 其他类型光敏元件</h6><p><strong>(1)PIN结光电二极管（PIN-PD）</strong></p><p><strong>结构</strong>：PN + I</p><ul><li>I-高电阻率的本征半导体(厚)</li><li>PN结双电层的间距加宽，结电容变小</li></ul><p><strong>特点</strong>：频带宽，可达10GHz，响应速度快；灵敏度高；线性输出范围宽，线性好；输出电流小(数微安)，电阻很大</p><p><strong>应用</strong>：用于光通讯，光测量</p><p><img src="/img/chuangan/ScreenShot_2025-11-06_153312_938.png"></p><p><strong>(2)雪崩光电二极管</strong></p><p><strong>雪崩效应</strong>：工作电压很高(100~200V)，接近于反向击穿电压。结区内电场极强，光生电子得到极大加速，同时与晶格碰撞，从而产生电离雪崩反应。</p><p><strong>特点</strong>：有很高的内增益，可达到几百，灵敏度高响应速度特别快，带宽可达100GHz，是目前最快的一种光电二极管噪声大(随机)，线性差</p><p><strong>应用</strong>：用于光通讯、光编码</p><p><strong>(3)阵列式结型光电器件</strong></p><p><strong>构成</strong>：利用集成电路技术，使几百个光电二极管或光电池排成一行，集成在一块集成电路片子上，即成为阵列式的一维光电器件衬底是共用的，而各光敏元都是独立的，分别有各自的前极引出线</p><p><strong>特点</strong>:光敏元密集度大，总尺寸小，容易作到各单元多数一致，便于信号处理</p><p><strong>应用</strong>:可用来辨别光点移动的方向</p><p><strong>(4)位置敏感器件</strong></p><p><img src="/img/chuangan/ScreenShot_2025-11-06_155730_421.png"></p><p><strong>(5)四象限光电池</strong></p><p><img src="/img/chuangan/ScreenShot_2025-11-06_155755_540.png"></p><p><strong>(6)固态摄像器件(CCD、CMOS)</strong></p><h3 id="2-8-磁电式检测元件"><a href="#2-8-磁电式检测元件" class="headerlink" title="2.8 磁电式检测元件"></a>2.8 磁电式检测元件</h3><p>利用电磁感应原理，将运动速度转速等物理量变换成感应电势</p><h4 id="2-8-1-磁电感应式敏感元件"><a href="#2-8-1-磁电感应式敏感元件" class="headerlink" title="2.8.1 磁电感应式敏感元件"></a>2.8.1 磁电感应式敏感元件</h4><ul><li>磁电感应式敏感元件是利用导体和磁场发生相对运动而在导体两端输出感应电动势进行工作的，因此也被称为感应式或者电动式敏感元件</li><li>它不需要辅助电源，就能把被测对象的机械能转换成易于测量的电信号，是一种典型的有源器件，有时也称作电动式或感应式传感器。</li><li>电路简单、输出功率大、性能稳定、适用于运动测量</li><li>常用于振动、转速、扭矩等参数的测量</li></ul><h5 id="2-8-1-1-楞次定律"><a href="#2-8-1-1-楞次定律" class="headerlink" title="2.8.1.1 楞次定律"></a>2.8.1.1 楞次定律</h5><p>闭合的导线回路中所出现的感应电流，其感应电流的方向总是试图减小磁通的变化量(右手定则)</p><p><img src="/img/chuangan/ScreenShot_2025-11-25_103024_201.png"></p><p><img src="/img/chuangan/ScreenShot_2025-11-25_103348_874.png"></p><h5 id="2-8-1-2-工作原理"><a href="#2-8-1-2-工作原理" class="headerlink" title="2.8.1.2 工作原理"></a>2.8.1.2 工作原理</h5><p>磁通变化率:由磁场强度、磁路电阻、线圈运动速度决定</p><p>磁通量 Φ的变化实现办法:</p><ul><li>磁场强度变化</li><li>磁路中磁阻的变化恒磁通(磁阻)式</li><li>磁铁与线圈之间做相对运动                                         变磁通(磁阻)式</li><li>恒定磁场中线圈面积的变化</li></ul><p>直接应用:测定速度<br>在信号调节电路中接积分电路，或微分电路，磁电式传感器就可以用来测量位移或加速度。</p><h6 id="2-8-1-2-1-恒磁阻式检测元件"><a href="#2-8-1-2-1-恒磁阻式检测元件" class="headerlink" title="2.8.1.2.1 恒磁阻式检测元件"></a>2.8.1.2.1 恒磁阻式检测元件</h6><p>磁路系统产生恒定的直流磁场，磁路中的工作气隙固定不变，因而磁路中的磁阻也是恒定不变的，测量线圈中产生感应电动势是由于<strong>线圈与永久磁铁间的相对运动切割磁力线</strong>导致磁通量发生变化。</p><p><img src="/img/chuangan/ScreenShot_2025-11-25_104008_643.png"></p><h6 id="2-8-1-2-2-变磁阻式检测元件"><a href="#2-8-1-2-2-变磁阻式检测元件" class="headerlink" title="2.8.1.2.2 变磁阻式检测元件"></a>2.8.1.2.2 变磁阻式检测元件</h6><p>线圈和磁铁部分都是静止的，线圈中的感应电动势是通过改变磁路中的气隙大小来改变磁路的磁阻，从而导致磁通发生变化，在线圈中产生感应电动势。<br>用来测量转速，线圈中产生感应电动势的频率作为输出，而感应电动势的频率取决于磁通变化的频率。</p><p>结构:开磁路、闭磁路</p><p>闭磁路式：</p><p><img src="/img/chuangan/ScreenShot_2025-11-25_104341_996.png"></p><h5 id="2-8-1-3-等效电路"><a href="#2-8-1-3-等效电路" class="headerlink" title="2.8.1.3 等效电路"></a>2.8.1.3 等效电路</h5><p>磁电感应式检测元件相当于一个电源</p><p><img src="/img/chuangan/ScreenShot_2025-11-25_104525_466.png"></p><h5 id="2-8-1-4-灵敏度"><a href="#2-8-1-4-灵敏度" class="headerlink" title="2.8.1.4 灵敏度"></a>2.8.1.4 灵敏度</h5><p>以线速度型恒磁阻式检测元件为例</p><p><img src="/img/chuangan/ScreenShot_2025-11-25_104625_104.png"></p><h5 id="2-8-1-5-误差以及补偿"><a href="#2-8-1-5-误差以及补偿" class="headerlink" title="2.8.1.5 误差以及补偿"></a>2.8.1.5 误差以及补偿</h5><p><img src="/img/chuangan/ScreenShot_2025-11-25_104658_247.png"></p><p>工作温度发生变化<br>受到外磁场干扰             →             灵敏度都将发生变化而产生测量误差<br>受到机械振动或冲击</p><h6 id="2-8-1-5-1-温度误差"><a href="#2-8-1-5-1-温度误差" class="headerlink" title="2.8.1.5.1 温度误差"></a>2.8.1.5.1 温度误差</h6><p>最主要的影响因素</p><ul><li>磁感应强度的温度系数为负;</li><li>线圈长度的温度系数是正;</li><li>负载电阻的温度系数为正</li></ul><p>对于铜线，温度每变化1℃</p><p>dl&#x2F;l&#x3D;0.167x10-4;<br>dR&#x2F;R&#x3D;0.43 x10-2;<br>dB&#x2F;B&#x3D;-0.02x10-2(取决于材料性质)。</p><p>补偿方法–热磁分流器</p><ul><li>具有负温度系数的热磁合金材料加在磁路系统的两个极靴上;</li><li>在正常温度下，热磁分流器将空气隙磁通分流一部分</li><li>当温度升高时，热磁分流器的磁导率显著下降，经它分流掉的磁通占总磁通的比例较正常温度下显著降低，从而保持空气隙中的工作磁通不随温度变化。</li></ul><h6 id="2-8-1-5-2-永磁铁不稳定误差"><a href="#2-8-1-5-2-永磁铁不稳定误差" class="headerlink" title="2.8.1.5.2 永磁铁不稳定误差"></a>2.8.1.5.2 永磁铁不稳定误差</h6><p><img src="/img/chuangan/ScreenShot_2025-11-25_110941_997.png"></p><ul><li>一般线圈长度具有较好的时间稳定性，而经磁化的永久磁铁的磁性一般会随时间而发生变化</li><li>解决办法:永磁材料在充磁前先进行退火处理，以消除内应力。充磁后再进行老化处理。</li></ul><h6 id="2-8-1-5-3-非线性误差"><a href="#2-8-1-5-3-非线性误差" class="headerlink" title="2.8.1.5.3 非线性误差"></a>2.8.1.5.3 非线性误差</h6><ul><li>感应电流会产生磁场，该磁场会削弱&#x2F;增强永久磁铁所产生的磁场，从而使磁电式检测元件的实际磁通量变化引起严重的非线性;</li><li>解决办法:补偿线圈，补偿线圈的反馈电流为$$i_k&#x3D;Ai$$</li></ul><p><img src="/img/chuangan/ScreenShot_2025-11-25_111112_463.png"></p><h5 id="2-8-1-6-应用"><a href="#2-8-1-6-应用" class="headerlink" title="2.8.1.6 应用"></a>2.8.1.6 应用</h5><p><img src="/img/chuangan/ScreenShot_2025-11-25_111634_367.png"></p><h4 id="2-8-2-霍尔传感器"><a href="#2-8-2-霍尔传感器" class="headerlink" title="2.8.2 霍尔传感器"></a>2.8.2 霍尔传感器</h4><h5 id="2-8-2-1-基本原理"><a href="#2-8-2-1-基本原理" class="headerlink" title="2.8.2.1 基本原理"></a>2.8.2.1 基本原理</h5><p><img src="/img/chuangan/ScreenShot_2025-11-25_111901_873.png"></p><h5 id="2-8-2-2-霍尔元件"><a href="#2-8-2-2-霍尔元件" class="headerlink" title="2.8.2.2 霍尔元件"></a>2.8.2.2 霍尔元件</h5><p><img src="/img/chuangan/ScreenShot_2025-11-25_111949_830.png"></p><h5 id="2-8-2-3-霍尔元件性质"><a href="#2-8-2-3-霍尔元件性质" class="headerlink" title="2.8.2.3 霍尔元件性质"></a>2.8.2.3 霍尔元件性质</h5><p><img src="/img/chuangan/ScreenShot_2025-11-25_112159_904.png"></p><h5 id="2-8-2-4-霍尔元件误差补偿"><a href="#2-8-2-4-霍尔元件误差补偿" class="headerlink" title="2.8.2.4 霍尔元件误差补偿"></a>2.8.2.4 霍尔元件误差补偿</h5><h6 id="2-8-2-4-1-温度误差"><a href="#2-8-2-4-1-温度误差" class="headerlink" title="2.8.2.4.1 温度误差"></a>2.8.2.4.1 温度误差</h6><p>半导体材料的载流子浓度、迁移率和电阻率都会发生变化，从而造成霍尔元件的霍尔系数、灵敏度、输入电阻及输出电阻变化</p><p>补偿措施：</p><ul><li>温度系数小的半导体材料</li><li>采用恒流源供电使$$U_H$$保持稳定</li><li>输入回路中并联一个电阻Rp，起到分流的作用，使$$K_HI$$保持恒定</li></ul><p><img src="/img/chuangan/ScreenShot_2025-11-25_112402_349.png"></p><h6 id="2-8-2-4-2-不等位电势"><a href="#2-8-2-4-2-不等位电势" class="headerlink" title="2.8.2.4.2 不等位电势"></a>2.8.2.4.2 不等位电势</h6><ul><li>霍尔电极安装不对称</li><li>半导体材料不均匀造成电阻率不均匀</li><li>元件几何尺寸不对称</li><li>激励电极接触不良导致电流不均匀</li></ul><p>激励电流I流经不等位电阻r所产生的电压U0</p><p><img src="/img/chuangan/ScreenShot_2025-11-25_112541_964.png"></p><p><img src="/img/chuangan/ScreenShot_2025-11-25_112546_963.png"></p><h5 id="2-8-2-5-霍尔集成器件"><a href="#2-8-2-5-霍尔集成器件" class="headerlink" title="2.8.2.5 霍尔集成器件"></a>2.8.2.5 霍尔集成器件</h5><p>将霍尔元件、放大器、施密特触发器及输出电路通过集成化制作工艺构成独立元件</p><p><img src="/img/chuangan/ScreenShot_2025-11-25_113240_681.png"></p><h5 id="2-8-2-6-应用"><a href="#2-8-2-6-应用" class="headerlink" title="2.8.2.6 应用"></a>2.8.2.6 应用</h5><ul><li>当激励电流一定时，霍尔电势与磁感应强度成正比。<ul><li>霍尔式罗盘(或称磁力计)来测量磁场的大小。</li><li>非均匀磁场中，霍尔电势的大小还可以反映出位置、角度等变化量，间接地实现位移、角度、转速、压力等物理量的测量。</li><li>开关特性，转速测量、磁电编码器、无触点开关、导磁产品计数等应用。霍尔键盘也是基于这一特性工作的。</li></ul></li><li>当磁场强度一定时，霍尔电势与激励电流成正比。<ul><li>利用这一特性，可以直接测量电流的大小以及与电流有关的物理量。</li></ul></li><li>当磁感应强度与激励电流都为变量时，霍尔电势与两者的乘积成正比。<ul><li>利用这一特性，可以测量具有乘法运算关系的物理量，典型的应用包括乘法器、功率计等。</li></ul></li></ul><p>①测量磁场大小和方向</p><p><img src="/img/chuangan/ScreenShot_2025-11-25_114302_772.png"></p><p>②研究磁性材料③位移传感器：灵敏度高，但是位移量小，适合微位移量以及振动测量④角位移测量</p><p>⑤压力传感器(微压力传感器)</p><p><img src="/img/chuangan/ScreenShot_2025-11-25_114423_877.png"></p><p>⑥加速度传感器</p><p><img src="/img/chuangan/ScreenShot_2025-11-25_114500_692.png"></p><p>⑦霍尔开关⑧霍尔式接近开关⑨霍尔点火器⑩霍尔式无触电电子点火装置</p><p>转速传感器</p><p><img src="/img/chuangan/ScreenShot_2025-11-25_114654_835.png"></p><p>钢球计数器，电流传感器</p><h3 id="2-9-磁弹性式检测元件"><a href="#2-9-磁弹性式检测元件" class="headerlink" title="2.9 磁弹性式检测元件"></a>2.9 磁弹性式检测元件</h3><p>基于铁磁材料的磁弹性效应：受外力作用产生内应力σ，引起磁阻或磁导率的变化</p><p>磁弹性式检测元件：压磁式检测元件、压磁元件</p><p><strong>优点</strong>:输出功率大、线性好、抗干扰能力及过载能力强、便于制造、经济实用、恶劣的条件下长期使用</p><p><strong>缺点</strong>:测量精度不高(误差约为1%)，反应速度较慢</p><p>测力、称重、温度、应力</p><ul><li>磁畴：铁磁材料内部存在强大的“分子场”，即使无外磁场，内部也有自发磁化的小区域；磁性取向随机，材料整体并不体现出磁性</li><li>磁化:外加磁场会使本来随机排列的磁畴发生转向</li><li>剩磁:当外加磁场去除后，材料仍会剩余一些磁场</li><li>居里温度:当温度很高时，由于无规则热运动的增强，磁性会消失，这个临界温度叫居里温度。</li></ul><h4 id="2-9-1-磁弹性效应"><a href="#2-9-1-磁弹性效应" class="headerlink" title="2.9.1 磁弹性效应"></a>2.9.1 磁弹性效应</h4><p>铁磁材料：</p><p><strong>磁致伸缩效应</strong>：l 变 V不变，磁致伸缩系数$$\lambda&#x3D;\frac{\Delta l}{l}$$</p><p>正磁致伸缩：有磁场变长； 负磁致伸缩：有磁场变短</p><p><strong>压磁效应</strong>：产生σ、μ改变，相对磁导率变化$$\frac{\Delta\mu}{\mu}&#x3D;\frac{2\lambda}{B^2}\sigma\mu$$</p><p>正压磁效应：拉长时磁畴构成磁场；负压磁效应：压缩时磁畴构成磁场</p><h4 id="2-9-2-结构与工作原理"><a href="#2-9-2-结构与工作原理" class="headerlink" title="2.9.2 结构与工作原理"></a>2.9.2 结构与工作原理</h4><p><img src="/img/chuangan/ScreenShot_2025-11-27_103636_075.png"></p><p><img src="/img/chuangan/ScreenShot_2025-11-27_104119_640.png"></p><p>承受压力较大、磁导率高、剩磁小、稳定性好；目前常用的材料为硅钢片</p><p>压磁元件工作原理：由具有正磁致伸缩效应的硅钢片粘叠而成</p><p><img src="/img/chuangan/ScreenShot_2025-11-27_104541_937.png"></p><h4 id="2-9-3-误差分析"><a href="#2-9-3-误差分析" class="headerlink" title="2.9.3 误差分析"></a>2.9.3 误差分析</h4><p>磁弹性式检测元件具有输出功率大、线性好、寿命长、适应恶劣环境等优点，但由于铁磁材料特性受许多因素影响使测量结果出现误差。降低这些因素的影响，是提高磁弹性式检测元件准确度的有效措施。</p><h5 id="2-9-3-1-磁场强度影响"><a href="#2-9-3-1-磁场强度影响" class="headerlink" title="2.9.3.1 磁场强度影响"></a>2.9.3.1 磁场强度影响</h5><p><img src="/img/chuangan/ScreenShot_2025-11-27_105708_780.png"></p><h5 id="2-9-3-2-激励频率影响"><a href="#2-9-3-2-激励频率影响" class="headerlink" title="2.9.3.2 激励频率影响"></a>2.9.3.2 激励频率影响</h5><p><img src="/img/chuangan/ScreenShot_2025-11-27_105738_539.png"></p><h5 id="2-9-3-3-激励电流影响"><a href="#2-9-3-3-激励电流影响" class="headerlink" title="2.9.3.3 激励电流影响"></a>2.9.3.3 激励电流影响</h5><p><img src="/img/chuangan/ScreenShot_2025-11-27_105852_610.png"></p><h5 id="2-9-3-4-预加载荷影响"><a href="#2-9-3-4-预加载荷影响" class="headerlink" title="2.9.3.4 预加载荷影响"></a>2.9.3.4 预加载荷影响</h5><p><img src="/img/chuangan/ScreenShot_2025-11-27_105958_244.png"></p><h5 id="2-9-3-5-温度影响"><a href="#2-9-3-5-温度影响" class="headerlink" title="2.9.3.5 温度影响"></a>2.9.3.5 温度影响</h5><p><img src="/img/chuangan/ScreenShot_2025-11-27_110227_639.png"></p><h5 id="2-9-3-6-其他因素"><a href="#2-9-3-6-其他因素" class="headerlink" title="2.9.3.6 其他因素"></a>2.9.3.6 其他因素</h5><p><img src="/img/chuangan/ScreenShot_2025-11-27_110248_294.png"></p><h3 id="2-10-核辐射式检测元件"><a href="#2-10-核辐射式检测元件" class="headerlink" title="2.10 核辐射式检测元件"></a>2.10 核辐射式检测元件</h3><p>利用被测物质对射线的<strong>吸收、散射、反射</strong>或射线对被测物质的<strong>电离作用</strong></p><p>厚度、物位、密度、成分、金属探伤</p><p><strong>优点</strong>:非接触式测量，适合于腐蚀、高温、剧毒、爆炸性等恶劣环境</p><p>核辐射式检测元件的<strong>组成</strong>:放射源、探测器、转换电路</p><h4 id="2-10-1-放射源"><a href="#2-10-1-放射源" class="headerlink" title="2.10.1 放射源"></a>2.10.1 放射源</h4><h5 id="2-10-1-1-放射性同位素"><a href="#2-10-1-1-放射性同位素" class="headerlink" title="2.10.1.1 放射性同位素"></a>2.10.1.1 放射性同位素</h5><p>放射性同位素：质子数量相同、中子数量不同</p><p><img src="/img/chuangan/ScreenShot_2025-11-27_111113_251.png"></p><h5 id="2-10-1-2-核衰变和核辐射"><a href="#2-10-1-2-核衰变和核辐射" class="headerlink" title="2.10.1.2 核衰变和核辐射"></a>2.10.1.2 核衰变和核辐射</h5><p><strong>核衰变</strong>:放射性同位素的原子核是不稳定的原子核，在无任何外因作用下，会自动衰变，放出粒子或射线，变为另外的同位素。</p><p><strong>核辐射</strong>:核衰变中放出不同的带有一定能量的粒子或射线的放射性现象。</p><p>核辐射种类：α粒子，β粒子，X射线，γ射线，中子辐射</p><p><img src="/img/chuangan/ScreenShot_2025-11-27_112129_883.png"></p><p><strong>按辐射本质分类</strong>：</p><ul><li><strong>粒子辐射</strong>：组成物质的基本粒子，或由这些粒子组成的原子核。<strong>既有能量又有静止质量</strong>。粒子辐射是一些高速运动的粒子，消耗自己的动能把能量传给被穿透的物质。粒子辐射包括电子、质子、中子、α粒子、β粒子和带电重离子等。</li><li><strong>电磁辐射</strong>：实质是电磁波，<strong>仅有能量，没有静止质量</strong>。包括无线电波、微波、可见光、紫外线、X射线和y 射线等。</li></ul><p><strong>按与物质的作用能力分类</strong>：</p><ul><li><strong>电离辐射</strong>：通过初级和次级过程引起物质电离，如α粒子、β粒子、质子、中子、X射线和γ 射线等，对于X、γ射线，一般当E&gt;10ev时可以引起电离辐射，或当波长λ&lt;100nm时可以引起电离辐射。</li><li><strong>非电离辐射</strong>：与物质作用不产生电离的辐射，如微波、无线电波、红外线等，但现在也不能忽视对人体的长期危害作用。</li></ul><p><img src="/img/chuangan/ScreenShot_2025-11-27_112717_028.png"></p><h5 id="2-10-1-3-不同电离辐射性质"><a href="#2-10-1-3-不同电离辐射性质" class="headerlink" title="2.10.1.3 不同电离辐射性质"></a>2.10.1.3 不同电离辐射性质</h5><p>α粒子:两个中子和两个质子，能量4-9MeV，电离作用最强，主要用于气体成分分析，气体压力及流量测量</p><p>β粒子:中子转变为质子过程释放的高速运动电子，能量一般小于2MeV</p><p>γ射线:核跃迁或粒子湮灭过程发射的电磁辐射，能量几十 keV到几MeV</p><p><img src="/img/chuangan/ScreenShot_2025-11-27_113136_543.png"></p><p><img src="/img/chuangan/ScreenShot_2025-11-27_114627_165.png"></p><h5 id="2-10-1-4-强度衰减特性"><a href="#2-10-1-4-强度衰减特性" class="headerlink" title="2.10.1.4 强度衰减特性"></a>2.10.1.4 强度衰减特性</h5><p>对某一个原子核来说，在何时衰变，完全是偶然的。但是就大量这种原子核作为整体来说，在到 t 到 t+dt 时间内衰变的原子核数 dN 应当和时间间隔 dt 及 t 时刻的放射性原子核数N成正比</p><p>$$-\frac{dN}{N}&#x3D;\lambda dt$$    其中λ是衰变常数</p><p>放射性原子核数目$$N&#x3D;N_0e^{-\lambda t}$$</p><p>放射性核的数目随时间按指数规律减少(核衰变)</p><p>组成核辐射检测器时，某个时刻放射源中还存在多少个放射性原子核没有衰变并不重要，重要的是单位时间内有多少个核发生衰变。</p><p>在给定时刻，单位时间内的核衰变数称为放射性活度   $$A&#x3D;-\frac{dN}{dt}&#x3D;\lambda N_0e^{-\lambda t}&#x3D;A_0e^{-\lambda t}$$<br>$$<br>I&#x3D;I_0e^{-\lambda t}<br>$$<br>$$I_0$$:开始时的放射源强度:</p><p>$$I$$:经过时间 t 后放射源强度;</p><p>$$\lambda$$:为放射性衰变常数，与外界条件无关;</p><p>放射源的辐射强度随时间按指数定律而衰减——校准</p><p>半衰期：放射性同位素的原子核数衰减到一半所用的时间<br>$$<br>T_{1&#x2F;2}&#x3D;\frac{ln2}{\lambda}&#x3D;\frac{0.693}{\lambda}<br>$$<br>平均寿命:在某特定状态下放射性核数减少到原来的1&#x2F;e的平均时间，符号?</p><h5 id="2-10-1-5-核辐射与物质的作用"><a href="#2-10-1-5-核辐射与物质的作用" class="headerlink" title="2.10.1.5 核辐射与物质的作用"></a>2.10.1.5 核辐射与物质的作用</h5><h6 id="2-10-1-5-1-带电粒子与物质的作用"><a href="#2-10-1-5-1-带电粒子与物质的作用" class="headerlink" title="2.10.1.5.1 带电粒子与物质的作用"></a>2.10.1.5.1 带电粒子与物质的作用</h6><p>电离：当入射粒子靠近原子时和物质中的原子发生静电作用，使原子中的束缚电子产生加速运动而变为自由电子<br>激发：若入射粒子距原子远，束缚电子所获得的能量还不够使它逃逸出来时，则原子核由低能级跃迁到高能级而处于激发状态。<br>散射：带电粒子穿过物质因受原子核的电场作用而改变运动方向称为散射。</p><p>当粒子穿过物质时，会发生电离、激发和散射等现象，其结果就表现为对射线的吸收。</p><p>当一平行射线穿过物质层时，其强度衰减规律可表示为：$$I&#x3D;I_0e^{-\mu_m\rho x}$$</p><ul><li>$$I$$:穿过物质后的辐射强度;</li><li>$$I_0$$:射入物质前的辐射强度;</li><li>$$\mu_m$$:为物质的吸收系数;</li><li>$$\rho$$:物质的密度。</li><li>$$x$$:厚度</li></ul><p><img src="/img/chuangan/ScreenShot_2025-11-29_120655_559.png"></p><h6 id="2-10-1-5-2-γ射线和物质的作用"><a href="#2-10-1-5-2-γ射线和物质的作用" class="headerlink" title="2.10.1.5.2 γ射线和物质的作用"></a>2.10.1.5.2 γ射线和物质的作用</h6><p><strong>光电效应</strong>：γ光子穿过物质时和物质中的原子发生碰撞，把自己的能量交给原子核外的一个电子使其成为自由电子(光电子)，而丫光子本身被吸收。<br>$$<br>E&#x3D;\frac{1}{2}mv^2&#x3D;h\gamma-A<br>$$<br><strong>康普顿效应</strong>：随着入射γ光子能量的增加，入射γ光子和物质中的电子发生碰撞，偏离它原来的运动方向，失去一部分能量，然后将能量转移给了电子，使电子(康普顿电子)从原子内部冲出来</p><p><strong>电子对效应</strong>：当入射y光子能量足够高，从原子核旁经过时，在核库仑场的作用下，转化为一个正电子和一个负电子，而丫光子则消失<br>$$<br>hv&#x3D;E_{e+}+E_{e-}+2m_0c^2<br>$$<br>γ射线通过物质时强度衰减<br>$$<br>I&#x3D;I_0e^{-\mu x}<br>$$</p><ul><li>μ：物质对射线的吸收系数</li><li>x：材料厚度</li></ul><p>吸收系数与材料和γ射线的能量有关，是三种效应的叠加<br>$$<br>\mu&#x3D;\tau+\sigma+\kappa<br>$$</p><ul><li>$\tau$:光电吸收系数</li><li>$\sigma$:康普顿吸收系数</li><li>$\kappa$:电子对生成吸收系数</li></ul><h4 id="2-10-2-核辐射探测器"><a href="#2-10-2-核辐射探测器" class="headerlink" title="2.10.2 核辐射探测器"></a>2.10.2 核辐射探测器</h4><p>核辐射检测器又称核辐射接收器，是以射线和物质的相互作用为基础设计的</p><p>将核辐射信号转换成电信号，以检测射线强度的变化，进而实现被测参数的检测</p><p><strong>气体探测器、闪烁探测器、半导体探测器</strong>：电流电离室、盖革计数器(G-M计数器)、正比室</p><h5 id="2-10-2-1-气体探测器"><a href="#2-10-2-1-气体探测器" class="headerlink" title="2.10.2.1 气体探测器"></a>2.10.2.1 气体探测器</h5><p>Ⅰ段是<strong>复合区</strong>，电流与电压成正比;<br>Ⅱ段是<strong>电流饱和区</strong>，离子对完全收集，与射线的强度有关(<strong>电离室</strong>);<br>Ⅲ段是<strong>正比区</strong>，电子能量很大使气体产生次级电离N&#x3D;M<em>N0，M随电压增大(<strong>正比室</strong>)<br>IV段是*<em>雪崩区</em></em>(<strong>盖革计数器</strong>)<br>V段是<strong>放电区</strong>一气体击穿</p><p><img src="/img/chuangan/ScreenShot_2025-11-29_122353_570.png"></p><p>α粒子电离室：</p><p><img src="/img/chuangan/ScreenShot_2025-11-29_122428_239.png"></p><p>β射线的多电极电离室：</p><p><img src="/img/chuangan/ScreenShot_2025-11-29_122510_326.png"></p><p>盖革计数器：</p><p><img src="/img/chuangan/ScreenShot_2025-11-29_122548_516.png"></p><p><img src="/img/chuangan/ScreenShot_2025-11-29_122612_176.png"></p><h5 id="2-10-2-2-闪烁探测器"><a href="#2-10-2-2-闪烁探测器" class="headerlink" title="2.10.2.2 闪烁探测器"></a>2.10.2.2 闪烁探测器</h5><p>闪烁计数器，先将辐射能转变为光能，再对光信号进行测量<br>闪烁体、光电倍增管和输出电路</p><p><img src="/img/chuangan/ScreenShot_2025-11-29_122715_426.png"></p><p><strong>闪烁体</strong>：受激发光物质，射线照射到闪烁体时，闪烁体的原子被电离和激发，受激原子退激时会发光。能在大约一微秒或更短的时间内把所吸收的一部分能量以光的形式再发射出来</p><p><strong>主要类型</strong>：无机闪烁体、有机闪烁体</p><p><strong>无机晶体</strong>：主要是含杂质或不含杂质的<strong>碱金属碘化物</strong>；对入射粒子的阻止本领大、发光效率高、有很高的探测效率</p><p><strong>有机晶体</strong>：都是未取代的或取代的<strong>芳香碳氢化合物</strong>；发光时间短，必须与分辨性能较高的光电倍增管配合使用</p><p><strong>液体闪烁体</strong>：液态的有机溶液</p><ul><li>α粒子：无机闪烁晶体，硫化锌</li><li>γ射线：无机闪烁晶体，碘化钠</li><li>β射线：有机闪烁体</li></ul><p>闪烁探测器<strong>特点</strong>：效率高、分辨时间短；不仅能探测γ射线，而且能探测各种带电和不带电的粒子，在核辐射检测中有着广泛的应用。</p><h5 id="2-10-2-3-半导体探测器"><a href="#2-10-2-3-半导体探测器" class="headerlink" title="2.10.2.3 半导体探测器"></a>2.10.2.3 半导体探测器</h5><ul><li>以半导体材料为探测介质:锗、硅</li><li>辐射与半导体晶体相互作用时产生电子-空穴对，电子-空穴对在外电场的作用下漂移而输出信号</li><li><strong>能量分辨率高；体积小、重量轻、结构简单、使用方便</strong></li><li>探测器不能做大做厚，难以测量高能辐射，输出信号小，电子线路复杂</li></ul><p><img src="/img/chuangan/ScreenShot_2025-11-29_123301_988.png"></p><h4 id="2-10-3-核辐射式检测元件的误差"><a href="#2-10-3-核辐射式检测元件的误差" class="headerlink" title="2.10.3 核辐射式检测元件的误差"></a>2.10.3 核辐射式检测元件的误差</h4><p><strong>1、辐射源强度误差</strong></p><p>在时间 t 上，强度衰减为$$\Delta I&#x3D;I_0-I$$，所以由辐射源本身核衰变引起的相对误差为<br>$$<br>r&#x3D;\frac{\Delta I}{I}&#x3D;1-e^{-\lambda t}<br>$$<br>放射源半衰期长，射线要达到一定强度</p><p><strong>2、核衰变的统计特性引起的误差</strong></p><p>由于核衰变产生的粒子数是随机的，它服从于统计规律，检测器测量到的粒子数的相对误差可按下式计算<br>$$<br>\delta_r&#x3D;\sqrt{\frac{1}{t_mf_n\eta}}<br>$$</p><ul><li>$t_m$:测量时间</li><li>$f_n$:为射入检测元件的粒子的平均频率</li><li>$\eta$:检测元件的效率</li></ul><h4 id="2-10-4-辐射式检测元件的应用"><a href="#2-10-4-辐射式检测元件的应用" class="headerlink" title="2.10.4 辐射式检测元件的应用"></a>2.10.4 辐射式检测元件的应用</h4><p>核物理、原子分子物理、固体物理、材料化学、化学、生物学、地质、考古、天体物理<br>成分分析、辐射探伤、测厚、流量、医学诊断</p><h5 id="2-10-4-1-核辐射式流量计"><a href="#2-10-4-1-核辐射式流量计" class="headerlink" title="2.10.4.1 核辐射式流量计"></a>2.10.4.1 核辐射式流量计</h5><p>核辐射流量计可以检测气体和液体在管道中的流量。在气流管壁上装两个活动电极，其一的内侧面涂覆有放射性物质构成的电离室。</p><p><img src="/img/chuangan/ScreenShot_2025-11-29_124822_539.png"></p><h5 id="2-10-4-2-射线式测厚仪"><a href="#2-10-4-2-射线式测厚仪" class="headerlink" title="2.10.4.2 射线式测厚仪"></a>2.10.4.2 射线式测厚仪</h5><p><img src="/img/chuangan/ScreenShot_2025-11-29_124859_784.png"></p><h5 id="2-10-4-3-核辐射式液位仪"><a href="#2-10-4-3-核辐射式液位仪" class="headerlink" title="2.10.4.3 核辐射式液位仪"></a>2.10.4.3 核辐射式液位仪</h5><p><img src="/img/chuangan/ScreenShot_2025-11-29_124955_136.png"></p><ul><li>辐射式液位计既可进行连续测量，也可进行定点发送信号和进行控制;</li><li>射线不受温度、压力、湿度、电磁场的影响，而且可以穿透各种介质，包括固体，因此能实现完全非接触测量</li><li>辐射式液位计适合于特殊场合或恶劣环境下不常有人之处的液位测量，如高温、高压、强腐蚀、剧毒、有爆炸性、易结晶、沸腾状态介质、高温熔融体等的液位测量。</li><li>使用时仍要注意控制剂量，作好防护，以防射线泄漏对人体造成伤害。</li></ul><h3 id="2-11-红外传感器"><a href="#2-11-红外传感器" class="headerlink" title="2.11 红外传感器"></a>2.11 红外传感器</h3><p>利用红外线的物理性质进行参数检测的传感器</p><h4 id="2-11-1-红外辐射"><a href="#2-11-1-红外辐射" class="headerlink" title="2.11.1 红外辐射"></a>2.11.1 红外辐射</h4><p><img src="/img/chuangan/ScreenShot_2025-12-05_102026_167.png"></p><ul><li>红外辐射的物理本质是热辐射</li><li>任何物体，只要其温度高于绝对零度，就会向周围空间辐射红外线物体的温度越高，辐射出的红外线越多，红外辐射的能量就越强</li><li>太阳光谱中各种单色光的热效应从紫色到红色是逐渐增强的，最强热效应出现在红外频率范围</li><li>红外辐射被物体吸收后可以转化为热能，引起物体温度的升高。</li><li>红外辐射作为电磁波的一种形式可以以波的形式在空间直线传播具有电磁波的一般特性，如反射、折射、散射、干涉和吸收等</li></ul><p><img src="/img/chuangan/ScreenShot_2025-12-05_102753_345.png"></p><h4 id="2-11-2-红外传感器"><a href="#2-11-2-红外传感器" class="headerlink" title="2.11.2 红外传感器"></a>2.11.2 红外传感器</h4><p>一种能将红外辐射能转换成电能的器件<br>一般由光学系统、探测器和信号调理电路等部分组成。<br>按工作原理的不同，可分为：热电红外传感器、光电红外传感器</p><h5 id="2-11-2-1-热电红外传感器"><a href="#2-11-2-1-热电红外传感器" class="headerlink" title="2.11.2.1 热电红外传感器"></a>2.11.2.1 热电红外传感器</h5><p>利用红外辐射的“热电效应原理”工作</p><ul><li>探测元件吸收红外辐射 → 自身温度升高 → 有关物理参数（如阻值）变化</li><li>通过测量该物理参数的变化来确定探测器所吸收的红外辐射</li></ul><p>常用的热电探测器有：热敏电阻型、热电偶型、高莱气动型及热释电型</p><p><img src="/img/chuangan/ScreenShot_2025-12-05_112244_038.png"></p><p>优点：响应波段宽，响应范围可扩展到整个红外区域可在常温下工作，使用方便，应用相当广泛</p><p>缺点：热敏材料的热效应需要一定的平衡时间，因此，热敏电阻型、热电偶型和高莱气动型热电探测器的响应速度慢，响应时间较长</p><p><strong>热释电红外传感器</strong></p><p>热释电材料（PZT，铌酸锂、钛酸钡等）自发极化，当光照引起材料温度升高（如红外光）时，由于温度升高而引起极化变弱，束缚电荷减少从而使电极的感生自由电荷减少—电荷释放，产生电流。</p><ul><li>由于热释电信号正比于器件温升的时间变化率，无热平衡过程，响应速度快，探测率高，而且频率响应范围宽</li><li>不适合测量恒定的红外辐射信号。</li><li>探测元件前面加机械式的周期遮光装置</li><li>硫酸三甘肽系列水溶性晶体</li></ul><h5 id="2-11-2-2-光电红外传感器"><a href="#2-11-2-2-光电红外传感器" class="headerlink" title="2.11.2.2 光电红外传感器"></a>2.11.2.2 光电红外传感器</h5><p>利用红外辐射的光电效应原理</p><p>优点：灵敏度高，响应速度快，具有较宽的响应频率</p><p>缺点：探测波段较窄，一般需在低温下工作，光电红外传感器的灵敏度是依赖于传感器自身的温度。要得到较高的灵敏度，就必须将光电红外传感器冷却至较低的温度。通常采<br>用的冷却剂为液氮</p><p>热电红外传感器通常灵敏度比光电红外传感器低，但在室温下也能较好地工作，同时响应频段较宽，响应范围能扩展到整个红外区域。</p><p><img src="/img/chuangan/ScreenShot_2025-12-05_112437_889.png"></p><h4 id="2-11-3-红外传感器基本特性"><a href="#2-11-3-红外传感器基本特性" class="headerlink" title="2.11.3 红外传感器基本特性"></a>2.11.3 红外传感器基本特性</h4><ul><li><p>灵敏度：</p><p>传感器的输出电压与输入红外辐射功率之比（电压响应率）</p><p><img src="/img/chuangan/ScreenShot_2025-12-05_112649_886.png"></p></li><li><p>响应波长范围&#x2F;光谱响应：</p><p>传感器的电压响应与入射红外辐射波长之间的关系</p><ul><li>热电传感器的电压响应率与波长无关</li><li>光电型传感器的电压响应率曲线是一条随波长变化的曲线</li></ul><p>一般将响应率最大值所对应的波长称为峰值波长<br>峰值波长两边，响应率下降到最大值的一半所对应的波长称为截止波长<br>由两个截止波长所围成的光谱区域表示红外传感器使用的波长范围</p></li><li><p>噪声等效功率：</p><p>信噪比为1时的入射红外辐射功率，也是红外器件探测到的最小辐射功率</p><p><img src="/img/chuangan/ScreenShot_2025-12-05_112826_475.png"></p></li></ul><p>探测率：</p><p>噪声等效功率的倒数</p><p><img src="/img/chuangan/ScreenShot_2025-12-05_112859_815.png"></p><p>比探测率：</p><p>归一化探测率，或者叫探测灵敏度。传感器的敏感元件面积为单位面积，放大器的带宽为1Hz，单位辐射功率所产生的信号电压与噪声电压之比</p><p><img src="/img/chuangan/ScreenShot_2025-12-05_112958_561.png"></p><p>时间常数&#x2F;滞后时间：</p><p>衡量红外传感器的输出信号响应快慢</p><p><img src="/img/chuangan/ScreenShot_2025-12-05_113024_449.png"></p><h4 id="2-11-4-基本定律"><a href="#2-11-4-基本定律" class="headerlink" title="2.11.4 基本定律"></a>2.11.4 基本定律</h4><p>基尔霍夫定律</p><p><img src="/img/chuangan/ScreenShot_2025-12-05_113054_872.png"></p><p>斯蒂芬-玻尔兹曼定律</p><p><img src="/img/chuangan/ScreenShot_2025-12-05_113118_535.png"></p><p>维恩位移定律</p><p><img src="/img/chuangan/ScreenShot_2025-12-05_113136_793.png"></p><h4 id="2-11-5-红外传感器的结构"><a href="#2-11-5-红外传感器的结构" class="headerlink" title="2.11.5 红外传感器的结构"></a>2.11.5 红外传感器的结构</h4><p>红外传感器一般由光学系统、敏感元件、前置放大器和信号调制器组成</p><p>根据测量方式可以分为：</p><p>• 被动式红外传感器<br>• 主动式红外传感器<br>• 根据传感器中光学系统的结构不同可分为<br>• 透射式红外传感器<br>• 反射式红外传感器</p><h4 id="2-11-6-红外传感器分类"><a href="#2-11-6-红外传感器分类" class="headerlink" title="2.11.6 红外传感器分类"></a>2.11.6 红外传感器分类</h4><p>被动式：被测物体本身就是红外辐射源，利用红外敏感元件测量物体的辐射强度&#x2F;温度，或者进行热成像。<br>主动式：利用红外辐射源对物体进行照射，使红外辐射被吸收、反射或者透射，从而导致物体自身或者红外光性质发生变化，再利用外敏感元件进行检测。</p><p><img src="/img/chuangan/ScreenShot_2025-12-05_113420_709.png"></p><h4 id="2-11-7-应用"><a href="#2-11-7-应用" class="headerlink" title="2.11.7 应用"></a>2.11.7 应用</h4><ul><li><p>红外测温、红外成像、红外遥感、红外测距、气体检测</p><p>• 辐射计，用于辐射和光谱测量；<br>• 搜索和跟踪系统，用于搜索和跟踪红外目标，确定其空间位置并对它的运动进行跟踪；<br>• 热成像系统，可产生整个目标红外辐射的分布图像；<br>• 红外测距和通信系统；<br>• 混合系统，是指以上各类系统中的两个或者多个的组合</p></li><li><p>具有以下特点：</p><p>• 测量过程中不影响被测目标的温度分布，可用于对远距离、带电，以及其他不能直接接触的物体进行温度测量；<br>• 响应速度快，可应用于对高速运动物体进行测量；<br>• 灵敏度高，能分辨微小的温度变化；<br>• 测温范围宽，能测量-10~1300℃之间的温度</p></li></ul><h3 id="2-12-超声波传感器"><a href="#2-12-超声波传感器" class="headerlink" title="2.12 超声波传感器"></a>2.12 超声波传感器</h3><p>通过超声波信号的变化来实现物理量测量的传感器</p><h4 id="2-12-1-声波的产生与分类"><a href="#2-12-1-声波的产生与分类" class="headerlink" title="2.12.1 声波的产生与分类"></a>2.12.1 声波的产生与分类</h4><p>声波的产生就是源于物体的振动，而声波的传播则是介质中质点的振动传递过程。<br>声波必须通过中间介质（固体、液体和气体）才能传播，</p><h5 id="2-12-1-1-频率分类"><a href="#2-12-1-1-频率分类" class="headerlink" title="2.12.1.1 频率分类"></a>2.12.1.1 频率分类</h5><p><img src="/img/chuangan/ScreenShot_2025-12-09_103019_876.png"></p><h5 id="2-12-1-2-波阵面形状"><a href="#2-12-1-2-波阵面形状" class="headerlink" title="2.12.1.2 波阵面形状"></a>2.12.1.2 波阵面形状</h5><p>平面波：波阵面与传播方向垂直且为互相平行的平面声波<br>球面波：波阵面为同心球面的声波<br>柱面波：波阵面为同轴圆柱面的声波</p><p><img src="/img/chuangan/ScreenShot_2025-12-09_103251_271.png"></p><h5 id="2-12-1-3-质点振动方向与波传播方向的关系"><a href="#2-12-1-3-质点振动方向与波传播方向的关系" class="headerlink" title="2.12.1.3 质点振动方向与波传播方向的关系"></a>2.12.1.3 质点振动方向与波传播方向的关系</h5><p><strong>纵波，L波</strong>：</p><p>Ø 质点振动方向与波传播方向一致或平行<br>Ø 其传播是由于介质中各体元发生压缩和拉伸的变形，并产生使体元回复原状的纵向弹性力而实现的<br>Ø 在介质中传播时会产生质点稠密和稀疏部分，也称为疏密波<br>Ø 可在固体、液体和气体中传播<br>Ø 容易激发和接收，在参数检测中有广泛的应用</p><p><strong>横波，S波：</strong></p><p>Ø 质点的振动方向与波的传播方向是垂直的<br>Ø 质点上下振动是可以产生横波，称为垂直偏振横波（SV波）<br>Ø 水平振动时同样可以产生横波，称为水平偏振横波（SH波）<br>Ø 横波不能在液体或气体介质中传播。</p><p><strong>表面波，瑞利波（Rayleigh波)</strong>：</p><p>Ø 在半无限大固体介质与气体介质的交界面产生的波<br>Ø 运动轨迹为椭圆形，可视为纵波和横波的合成<br>Ø 表面波不能在液体或者气体介质中传播<br>Ø 表面波常用于材料表面缺陷的检测</p><p><strong>板波，兰姆波（Lamb波)</strong>：</p><p>Ø 在板厚与波长相当的薄板中传播的波<br>Ø 兰姆波是板波中最重要的一种波<br>Ø 可看成是两个Rayleigh波在板的上下表面上相互作用的结果<br>Ø 可用于检测板厚、分层和裂纹等缺陷</p><h4 id="2-12-2-声波的传播特性"><a href="#2-12-2-声波的传播特性" class="headerlink" title="2.12.2 声波的传播特性"></a>2.12.2 声波的传播特性</h4><h5 id="2-12-2-1-波长频率和声速"><a href="#2-12-2-1-波长频率和声速" class="headerlink" title="2.12.2.1 波长频率和声速"></a>2.12.2.1 波长频率和声速</h5><p>波长：在声波的传播方向上，相邻两个振动相位相同的点之间的距离称为波长</p><p><img src="/img/chuangan/ScreenShot_2025-12-09_105223_629.png"></p><p><img src="/img/chuangan/ScreenShot_2025-12-09_105300_721.png"></p><h5 id="2-12-2-2-声场参量"><a href="#2-12-2-2-声场参量" class="headerlink" title="2.12.2.2 声场参量"></a>2.12.2.2 声场参量</h5><p>声波在介质中传播就会引起内部压强的变化，形成声场</p><p><strong>声压</strong>：</p><p>Ø 某一点的瞬时压强与没有声波时该点的静压强之差<br>$p&#x3D;\rho c v$，ρ是介质密度，c是介质中声速，v是质点振动速度<br>Ø 声压是个交变量，即同一时刻不同体积单元、以及同一体积单元不同时刻的声压是不同的<br>Ø 对于简谐声波，设声压的振幅 pa，则有效声压为$p_e&#x3D;\frac{p_a}{\sqrt{2}}$<br>Ø 声压的大小反应了声音的强弱<br>l 人耳对于1 kHz声音的可听阈约为2×10^-5 Pa，<br>l 微风吹动树叶的声音约为2×10^-4 Pa<br>l 在房间内高声谈话的声音（相距1 m处）为0.05-0.1 Pa<br>l 飞机发动机发出的声音（相距5 m处）约200 Pa。</p><p><strong>声阻抗：</strong></p><p>声阻抗Za是指在波阵面的一定面积上，声压与通过该面积的体积速度的比值$Z_a&#x3D;\frac{p}{U}$<br>由于体积速度U的含义是不明确的，因此通常使用质点振动速度v来代替，得到声阻抗率Zs，即介质中某一点的声压与该点的质点振动速度的比值。$Z_s&#x3D;\frac{p}{v}&#x3D;\rho c$</p><p><strong>声强：</strong></p><p>声强是单位时间内通过垂直于声波传播方向的单位面积的声能量。<br>$I&#x3D;\overline\varepsilon c&#x3D;\frac{p_e^2}{\rho c}&#x3D;\frac{p_a^2}{2\rho c}$</p><p><strong>声场参量的级与分贝:</strong></p><p>① 声振动的能量范围非常宽，例如，人讲话的声功率只有约10-5 W，而火箭发射的噪声功率却可以高达109 W，两者相差十几个数量级。<br>②从声音接收的角度，人耳感受到的“响度感觉”并不正比于声音强度的绝对值，而是更接近于与强度的对数成正比。<br>③在声学以及电子、通讯等领域，人们更感兴趣的是信号的相对比值，而非其绝对值。<br>基于以上这些原因，在声学领域普遍使用对数标度来表示这些声场参量，并称之为“级”，如声压级、声强级等，单位为分贝（dB）。</p><p><strong>声压级与声强级</strong></p><p><img src="/img/chuangan/ScreenShot_2025-12-09_110141_132.png"></p><h5 id="2-12-2-3-声波的反射、折射与透射"><a href="#2-12-2-3-声波的反射、折射与透射" class="headerlink" title="2.12.2.3 声波的反射、折射与透射"></a>2.12.2.3 声波的反射、折射与透射</h5><p><img src="/img/chuangan/ScreenShot_2025-12-09_110221_530.png"></p><p><img src="/img/chuangan/ScreenShot_2025-12-09_110243_622.png"></p><h4 id="2-12-3-超声波的激发与接收"><a href="#2-12-3-超声波的激发与接收" class="headerlink" title="2.12.3 超声波的激发与接收"></a>2.12.3 超声波的激发与接收</h4><p>激发形式：</p><p><img src="/img/chuangan/ScreenShot_2025-12-09_110846_372.png"></p><p>接收：</p><p><img src="/img/chuangan/ScreenShot_2025-12-09_110919_289.png"></p><p><img src="/img/chuangan/ScreenShot_2025-12-09_110933_560.png"></p><h4 id="2-12-4-探头类型"><a href="#2-12-4-探头类型" class="headerlink" title="2.12.4 探头类型"></a>2.12.4 探头类型</h4><p><img src="/img/chuangan/ScreenShot_2025-12-09_111048_185.png"></p><p>Ø 直探头（纵波）<br>Ø 斜探头（横波）<br>Ø 表面波探头（表面波）<br>Ø 兰姆波探头（兰姆波）<br>Ø 可变角探头（纵波、横波、表面波、兰姆波）<br>Ø 双晶探头（一个探头内含两个晶片，一个用于发射，另一个用于接收）<br>Ø 聚焦探头（将声波聚集为一细束）</p><h4 id="2-12-5-等效电路"><a href="#2-12-5-等效电路" class="headerlink" title="2.12.5 等效电路"></a>2.12.5 等效电路</h4><p><img src="/img/chuangan/ScreenShot_2025-12-09_111305_190.png"></p><p>频率特性，方向性</p><p><img src="/img/chuangan/ScreenShot_2025-12-09_111324_449.png"></p><h4 id="2-12-6-超声波传感器工作原理"><a href="#2-12-6-超声波传感器工作原理" class="headerlink" title="2.12.6 超声波传感器工作原理"></a>2.12.6 超声波传感器工作原理</h4><p>Ø 在确定的介质中，其传播速度是确定的<br>• 空 气：344 m&#x2F;s<br>• 自来水：1430 m&#x2F;s<br>• 海 水：1500 m&#x2F;s<br>• 钢 铁：5800 m&#x2F;s<br>Ø 超声波纵波在气体中的传播速度最低，液体次之，固体最高<br>Ø 在固体中，横波声速为纵波的一半，表面波声速为横波声速的90%</p><p><strong>探头布置方式</strong></p><p><img src="/img/chuangan/ScreenShot_2025-12-09_111724_434.png"></p><p><strong>误差影响因素</strong></p><p><img src="/img/chuangan/ScreenShot_2025-12-09_112045_204.png"></p><h4 id="2-12-7-应用"><a href="#2-12-7-应用" class="headerlink" title="2.12.7 应用"></a>2.12.7 应用</h4><p>移动机器人测距和避障；汽车雷达；防盗报警；材料厚度、密度、液位；物位传感器；流速、流量；零件内部缺陷</p>]]></content>
    
    
    <categories>
      
      <category>检测技术</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>轨迹识别与分类控制小车——“魔杖”</title>
    <link href="/2025/12/02/%E8%BD%A8%E8%BF%B9%E8%AF%86%E5%88%AB%E4%B8%8E%E5%88%86%E7%B1%BB%E6%8E%A7%E5%88%B6%E5%B0%8F%E8%BD%A6%E2%80%94%E2%80%94%E2%80%9C%E9%AD%94%E6%9D%96%E2%80%9D/"/>
    <url>/2025/12/02/%E8%BD%A8%E8%BF%B9%E8%AF%86%E5%88%AB%E4%B8%8E%E5%88%86%E7%B1%BB%E6%8E%A7%E5%88%B6%E5%B0%8F%E8%BD%A6%E2%80%94%E2%80%94%E2%80%9C%E9%AD%94%E6%9D%96%E2%80%9D/</url>
    
    <content type="html"><![CDATA[<p>​用esp32和MPU6050，再加上一些轨迹分类算法、蓝牙传输，就实现了一个简单的”魔杖”效果。</p><span id="more"></span><h1 id="一、思路"><a href="#一、思路" class="headerlink" title="一、思路"></a>一、思路</h1><p>​开发板均选择<strong>esp32 devkit v1</strong>，传感器选择<strong>MPU6050</strong>，小车驱动选择<strong>TB6612</strong></p><p>​魔杖部分：利用MPU6050可以监测加速度和角速度的功能，获得世界坐标系下的去除重力加速度分量后的三轴加速度，要求得到的结果准确、低噪、响应速度快，然后将加速度二次积分得到三轴位移，便可以表示出世界坐标系下的三轴轨迹，再对这些轨迹按照机器学习的方法进行训练，获得能够分类轨迹的模型，再把模型部署到开发板上去，这样便能够实现对分类结果的实时运算，再将这个结果通过蓝牙传输给小车端的板子，对其控制。</p><p>​小车部分：用TB6612写出基本的控制运动的代码，接收从魔杖端发送过来的指令并对其做出响应。</p><p>​预计实现四种轨迹（上下左右）的控制指令</p><h1 id="二、-魔杖part"><a href="#二、-魔杖part" class="headerlink" title="二、 魔杖part"></a>二、 魔杖part</h1><h2 id="2-1-硬件连接"><a href="#2-1-硬件连接" class="headerlink" title="2.1 硬件连接"></a>2.1 硬件连接</h2><p>​魔杖部分共用到的硬件有：esp32 devkit v1开发板，MPU6050传感器，按钮，5V锂电池，microusb公对母带开关导线，若干杜邦线。</p><p>​其中MPU6050为I2C通信，有串行数据线SDA，串行时钟线SCL，均为开漏输出(OD)，而esp32仅有两个管脚支持I2C通信，依次为   D21——SDA、D22——SCL，剩下两个端口分别接3.3V和GND，来给传感器供电。</p><p>​双端按钮默认常断，一端接地，一端接D13，因为D13有内置上拉电阻，否则平时浮空输入时改管脚电平不定。而电池通过microusb公对母导线与esp32连接来给开发板供电，这条导线上的按钮即为整个魔杖的上电开关。</p><p><img src="/img/mozhang_img/ScreenShot_2025-12-02_101641_001.png"></p><h2 id="2-2-三轴加速度的获取"><a href="#2-2-三轴加速度的获取" class="headerlink" title="2.2 三轴加速度的获取"></a>2.2 三轴加速度的获取</h2><p>​我们想要把传感器的运动轨迹解算出来，即将传感器的运动轨迹用位移的数组表示出了，首先要从加速度的获取入手，获得世界坐标系下的三轴加速度再经过两次积分后便可以得到位移数组。</p><h3 id="2-2-1-DMP库直接获取"><a href="#2-2-1-DMP库直接获取" class="headerlink" title="2.2.1 DMP库直接获取"></a>2.2.1 DMP库直接获取</h3><p>​因为我们所用的是MPU6050传感器，因此我们自然会想到用其自带的DMP姿态解算库，其内置的若干函数可以直接计算出世界坐标系下去除重力分量的三轴加速度。</p><p>​核心代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;I2Cdev.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;MPU6050_6Axis_MotionApps20.h&quot;</span></span><br>MPU6050 mpu;<br><span class="hljs-type">uint8_t</span> fifoBuffer[<span class="hljs-number">64</span>];<span class="hljs-comment">//内部缓存</span><br>Quaternion q;<span class="hljs-comment">//四元数</span><br>VectorFloat gravity;<span class="hljs-comment">//重力分量</span><br>VectorInt16 acc_raw;<span class="hljs-comment">//三轴原始加速度</span><br>VectorInt16 lineacc;<span class="hljs-comment">//去除重力的线性加速度</span><br>VectorInt16 worldacc;<span class="hljs-comment">//世界坐标系下的</span><br><span class="hljs-type">float</span> ypr[<span class="hljs-number">3</span>];<span class="hljs-comment">//三轴角</span><br><span class="hljs-type">float</span> acc[<span class="hljs-number">3</span>];<span class="hljs-comment">//最终加速度</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">setup</span><span class="hljs-params">()</span><br>&#123;<br>  Wire.begin();<br>  Wire.setClock(<span class="hljs-number">400000</span>);<span class="hljs-comment">//I2C通信速率</span><br>  Serial.begin(<span class="hljs-number">115200</span>);<span class="hljs-comment">//波特率</span><br>  mpu.initialize();<br>  mpu.dmpInitialize();<br>  mpu.CalibrateAccel(<span class="hljs-number">6</span>);<br>  mpu.CalibrateGyro(<span class="hljs-number">6</span>);<br>  mpu.PrintActiveOffsets();<br>  mpu.setDMPEnabled(<span class="hljs-literal">true</span>);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (mpu.dmpGetCurrentFIFOPacket(fifoBuffer))<span class="hljs-comment">//读缓存</span><br>  &#123;<br>    mpu.dmpGetQuaternion(&amp;q,fifoBuffer);<span class="hljs-comment">//读四元数</span><br>    mpu.dmpGetGravity(&amp;gravity,&amp;q);<span class="hljs-comment">//读重力分量</span><br>    mpu.dmpGetAccel(&amp;acc_raw,fifoBuffer);<span class="hljs-comment">//读原始加速度</span><br>    acc_raw.x=acc_raw.x/<span class="hljs-number">2</span>;<br>    acc_raw.y=acc_raw.y/<span class="hljs-number">2</span>;<br>    acc_raw.z=acc_raw.z/<span class="hljs-number">2</span>;<br>    mpu.dmpGetLinearAccel(&amp;lineacc,&amp;acc_raw,&amp;gravity);<span class="hljs-comment">//去除重力</span><br>    mpu.dmpGetYawPitchRoll(ypr,&amp;q,&amp;gravity);<br>    mpu.dmpConvertToWorldFrame(&amp;worldacc,&amp;lineacc,&amp;q);<span class="hljs-comment">//转世界坐标系</span><br>    acc[<span class="hljs-number">0</span>]=worldacc.x/<span class="hljs-number">8192.0f</span>;<span class="hljs-comment">//归一化</span><br>    acc[<span class="hljs-number">1</span>]=worldacc.y/<span class="hljs-number">8192.0f</span>;<br>    acc[<span class="hljs-number">2</span>]=worldacc.z/<span class="hljs-number">8192.0f</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​中间有一段是将原始加速度除以二，是因为在其原始函数中，去除重力分量的定义是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">MPU6050_6Axis_MotionApps20::dmpGetLinearAccel</span><span class="hljs-params">(VectorInt16 *v, VectorInt16 *vRaw, VectorFloat *gravity)</span> &#123;<br>    <span class="hljs-comment">// get rid of the gravity component (+1g = +8192 in standard DMP FIFO packet, sensitivity is 2g)</span><br>    v -&gt; x = vRaw -&gt; x - gravity -&gt; x*<span class="hljs-number">8192</span>;<br>    v -&gt; y = vRaw -&gt; y - gravity -&gt; y*<span class="hljs-number">8192</span>;<br>    v -&gt; z = vRaw -&gt; z - gravity -&gt; z*<span class="hljs-number">8192</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​所有加速度得到的初始值单位是LSB，也就是数模转换的灵敏度，这个取决于量程范围：对±2g，灵敏度为16384 LSB&#x2F;g；对±4g，灵敏度为8192 LSB&#x2F;g。但是上述函数的原理，是将重力分量乘8192再减的，但是默认量程为2g，这就导致了灵敏度换算出现差异，于是原始灵敏度要先除以二再进行运算。</p><p>​但是我们最终得到的数据存在相当大的问题：z轴有非常严重的零点漂移，而且随着传感器姿态不同，漂移量也随之变化，最大可达0.3g，这就导致了我们不能仅用添加一个偏置项的方法来消除零漂。而z轴又是非常重要的，关系到上下轨迹的判断，假如静止时偏移量为向上的0.3g，而实际运动的加速度向下且小于0.3g，此时记录下来的加速度变化数据方向全部向上，会将原本向下的轨迹误判为向上。</p><p>​简单判断原因可能与其内部运算逻辑有关系，重力分量是四元数运算得到的，三轴加速度是从缓存中读出来的，这差异可能就导致了结果有出入。因为DMP库是内部封装的，所以我们只能换其他算法。</p><p><img src="/img/mozhang_img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250901110900_29.png"></p><center>零点漂移量较小时的三轴加速度</center><h3 id="2-2-2-加速度角速度-欧拉角-旋转矩阵算法"><a href="#2-2-2-加速度角速度-欧拉角-旋转矩阵算法" class="headerlink" title="2.2.2 加速度角速度-欧拉角-旋转矩阵算法"></a>2.2.2 加速度角速度-欧拉角-旋转矩阵算法</h3><p>​于是我们脱离DMP库，按照一定的顺序逐步计算出来世界坐标系下的三轴加速度。</p><h4 id="2-2-2-1-Adafruit库"><a href="#2-2-2-1-Adafruit库" class="headerlink" title="2.2.2.1 Adafruit库"></a>2.2.2.1 Adafruit库</h4><p>​Adafruit库可以直接从传感器中读出三轴加速度和三轴角速度数据，而且值准确、低噪、响应快。为方便我们定义了一个头文件。</p><p>mpu6050.h </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Adafruit_MPU6050.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Adafruit_Sensor.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Wire.h&gt;</span></span><br>Adafruit_MPU6050 mpu;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MPU6050_DATA</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">float</span> Acc_X = <span class="hljs-number">0.0</span>;<span class="hljs-comment">//三轴加速度m/s^2</span><br>  <span class="hljs-type">float</span> Acc_Y = <span class="hljs-number">0.0</span>;<br>  <span class="hljs-type">float</span> Acc_Z = <span class="hljs-number">0.0</span>;<br>  <span class="hljs-type">float</span> Angle_Velocity_R = <span class="hljs-number">0.0</span>; <span class="hljs-comment">//三轴角速度rad/s</span><br>  <span class="hljs-type">float</span> Angle_Velocity_P = <span class="hljs-number">0.0</span>;<br>  <span class="hljs-type">float</span> Angle_Velocity_Y = <span class="hljs-number">0.0</span>;<br>&#125;mpu6050_data;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Init_mpu6050</span><span class="hljs-params">()</span>&#123;<br>    ...<span class="hljs-comment">//主要包含一些量程等初始量设置</span><br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">ReadMPU6050</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">sensors_event_t</span> a, g, temp;<br>  mpu.getEvent(&amp;a, &amp;g, &amp;temp);<br>  mpu6050_data.Acc_X = a.acceleration.x;<br>  mpu6050_data.Acc_Y = a.acceleration.y;<br>  mpu6050_data.Acc_Z = a.acceleration.z;<br>  mpu6050_data.Angle_Velocity_R = g.gyro.x; <br>  mpu6050_data.Angle_Velocity_P = g.gyro.y; <br>  mpu6050_data.Angle_Velocity_Y = g.gyro.z; <br>&#125;<br></code></pre></td></tr></table></figure><p>mozhang.ino（其中mpu6050_data是全局变量）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mpu6050.h&quot;</span></span><br>...<br><span class="hljs-type">void</span> <span class="hljs-title function_">setup</span><span class="hljs-params">()</span> &#123;<br> Init_mpu6050();<br> ...<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span> &#123;<br>ReadMPU6050()；<br>...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-2-2-Madgwick算法"><a href="#2-2-2-2-Madgwick算法" class="headerlink" title="2.2.2.2 Madgwick算法"></a>2.2.2.2 Madgwick算法</h4><p>​通过Adafruit库我们获得了传感器坐标系下的三轴加速度和角速度，为转到世界坐标系我们需要由欧拉角得到的旋转矩阵，于是问题就变成了如何用获得的这六个值来解出来三个欧拉角。我们采用Madgwick算法。</p><p>​Madgwick算法是一种基于四元数的六轴融合的姿态滤波算法，大致原理如下图：</p><p><img src="/img/mozhang_img/ScreenShot_2025-12-02_101356_007.png"></p><p>​但是这个算法太难了，设计的变量于公式推导都比较多，因此我们直接搬运了<a href="https://github.com/kriswiner/MPU6050">https://github.com/kriswiner/MPU6050</a><br>这个项目的算法函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MadgwickQuaternionUpdate</span><span class="hljs-params">(<span class="hljs-type">float</span> ax, <span class="hljs-type">float</span> ay, <span class="hljs-type">float</span> az, <span class="hljs-type">float</span> gyrox, <span class="hljs-type">float</span> gyroy, <span class="hljs-type">float</span> gyroz)</span><br>&#123;<br>    <span class="hljs-type">float</span> q1 = q[<span class="hljs-number">0</span>], q2 = q[<span class="hljs-number">1</span>], q3 = q[<span class="hljs-number">2</span>], q4 = q[<span class="hljs-number">3</span>];         <span class="hljs-comment">// short name local variable for readability</span><br>    <span class="hljs-type">float</span> norm;                                               <span class="hljs-comment">// vector norm</span><br>    <span class="hljs-type">float</span> f1, f2, f3;                                         <span class="hljs-comment">// objetive funcyion elements</span><br>    <span class="hljs-type">float</span> J_11or24, J_12or23, J_13or22, J_14or21, J_32, J_33; <span class="hljs-comment">// objective function Jacobian elements</span><br>    <span class="hljs-type">float</span> qDot1, qDot2, qDot3, qDot4;<br>    <span class="hljs-type">float</span> hatDot1, hatDot2, hatDot3, hatDot4;<br>    <span class="hljs-type">float</span> gerrx, gerry, gerrz, gbiasx, gbiasy, gbiasz;        <span class="hljs-comment">// gyro bias error</span><br><br>    <span class="hljs-comment">// Auxiliary variables to avoid repeated arithmetic</span><br>    <span class="hljs-type">float</span> _halfq1 = <span class="hljs-number">0.5f</span> * q1;<br>    <span class="hljs-type">float</span> _halfq2 = <span class="hljs-number">0.5f</span> * q2;<br>    <span class="hljs-type">float</span> _halfq3 = <span class="hljs-number">0.5f</span> * q3;<br>    <span class="hljs-type">float</span> _halfq4 = <span class="hljs-number">0.5f</span> * q4;<br>    <span class="hljs-type">float</span> _2q1 = <span class="hljs-number">2.0f</span> * q1;<br>    <span class="hljs-type">float</span> _2q2 = <span class="hljs-number">2.0f</span> * q2;<br>    <span class="hljs-type">float</span> _2q3 = <span class="hljs-number">2.0f</span> * q3;<br>    <span class="hljs-type">float</span> _2q4 = <span class="hljs-number">2.0f</span> * q4;<br>    <span class="hljs-type">float</span> _2q1q3 = <span class="hljs-number">2.0f</span> * q1 * q3;<br>    <span class="hljs-type">float</span> _2q3q4 = <span class="hljs-number">2.0f</span> * q3 * q4;<br><br>    <span class="hljs-comment">// Normalise accelerometer measurement</span><br>    norm = <span class="hljs-built_in">sqrt</span>(ax * ax + ay * ay + az * az);<br>    <span class="hljs-keyword">if</span> (norm == <span class="hljs-number">0.0f</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// handle NaN</span><br>    norm = <span class="hljs-number">1.0f</span>/norm;<br>    ax *= norm;<br>    ay *= norm;<br>    az *= norm;<br>...    <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">yaw=<span class="hljs-built_in">atan2</span>(<span class="hljs-number">2.0f</span> * (q[<span class="hljs-number">1</span>] * q[<span class="hljs-number">2</span>] + q[<span class="hljs-number">0</span>] * q[<span class="hljs-number">3</span>]), q[<span class="hljs-number">0</span>] * q[<span class="hljs-number">0</span>] + q[<span class="hljs-number">1</span>] * q[<span class="hljs-number">1</span>] - q[<span class="hljs-number">2</span>] * q[<span class="hljs-number">2</span>] - q[<span class="hljs-number">3</span>] * q[<span class="hljs-number">3</span>]);   <br>pitch=-<span class="hljs-built_in">asin</span>(<span class="hljs-number">2.0f</span> * (q[<span class="hljs-number">1</span>] * q[<span class="hljs-number">3</span>] - q[<span class="hljs-number">0</span>] * q[<span class="hljs-number">2</span>]));<br>roll=<span class="hljs-built_in">atan2</span>(<span class="hljs-number">2.0f</span> * (q[<span class="hljs-number">0</span>] * q[<span class="hljs-number">1</span>] + q[<span class="hljs-number">2</span>] * q[<span class="hljs-number">3</span>]), q[<span class="hljs-number">0</span>] * q[<span class="hljs-number">0</span>] - q[<span class="hljs-number">1</span>] * q[<span class="hljs-number">1</span>] - q[<span class="hljs-number">2</span>] * q[<span class="hljs-number">2</span>] + q[<span class="hljs-number">3</span>] * q[<span class="hljs-number">3</span>]);<br></code></pre></td></tr></table></figure><p>​最终通过这个算法我们得到准确且响应快的欧拉角，但是仍然存在yaw角随时间慢慢偏移的现象，这个是不可避免的，这个需要加装磁力计来校正，而MPU6050没有磁力计。</p><h4 id="2-2-2-3-旋转矩阵"><a href="#2-2-2-3-旋转矩阵" class="headerlink" title="2.2.2.3 旋转矩阵"></a>2.2.2.3 旋转矩阵</h4><p>​用获得的欧拉角求出旋转矩阵，便可以从传感器坐标系转为世界坐标系，再减去重力分量便可以得到我们需要的世界坐标系下去除重力分量的三轴加速度。</p><p>  $$ WorldAcc_{(3×1)}&#x3D;R · Acc_{(3×1)}$$</p><p>旋转矩阵定义为：</p><p>​                                                               <img src="/img/mozhang_img/stitching-collage-1764643307827.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span> R[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>];<br>R[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-built_in">cos</span>(pitch)*<span class="hljs-built_in">cos</span>(yaw);<br>R[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-built_in">cos</span>(yaw)*<span class="hljs-built_in">sin</span>(roll)*<span class="hljs-built_in">sin</span>(pitch)-<span class="hljs-built_in">cos</span>(roll)*<span class="hljs-built_in">sin</span>(yaw);<br>R[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]=<span class="hljs-built_in">sin</span>(roll)*<span class="hljs-built_in">sin</span>(yaw)+<span class="hljs-built_in">cos</span>(roll)*<span class="hljs-built_in">cos</span>(yaw)*<span class="hljs-built_in">sin</span>(pitch);<br><br>R[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-built_in">cos</span>(pitch)*<span class="hljs-built_in">sin</span>(yaw);<br>R[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-built_in">cos</span>(roll)*<span class="hljs-built_in">cos</span>(yaw)+<span class="hljs-built_in">sin</span>(roll)*<span class="hljs-built_in">sin</span>(pitch)*<span class="hljs-built_in">sin</span>(yaw);<br>R[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]=<span class="hljs-built_in">cos</span>(roll)*<span class="hljs-built_in">sin</span>(pitch)*<span class="hljs-built_in">sin</span>(yaw)-<span class="hljs-built_in">cos</span>(yaw)*<span class="hljs-built_in">sin</span>(roll);<br><br>R[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]=-<span class="hljs-built_in">sin</span>(pitch);<br>R[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]=<span class="hljs-built_in">cos</span>(pitch)*<span class="hljs-built_in">sin</span>(roll);<br>R[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]=<span class="hljs-built_in">cos</span>(roll)*<span class="hljs-built_in">cos</span>(pitch);<br><br>worldAccX=R[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]*mpu6050_data.Acc_X+R[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]*mpu6050_data.Acc_Y+R[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]*mpu6050_data.Acc_Z;<br>worldAccY=R[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]*mpu6050_data.Acc_X+R[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]*mpu6050_data.Acc_Y+R[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]*mpu6050_data.Acc_Z;<br>worldAccZ=R[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]*mpu6050_data.Acc_X+R[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]*mpu6050_data.Acc_Y+R[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]*mpu6050_data.Acc_Z;<br>worldAccZ-=<span class="hljs-number">9.8065</span>;<br></code></pre></td></tr></table></figure><p>以下为部分动作时的加速度响应情况：</p><p><img src="/img/mozhang_img/stitching-collage-1764643543204.jpg" alt="上、下、左、右"></p><h2 id="2-3-世界坐标系的定义"><a href="#2-3-世界坐标系的定义" class="headerlink" title="2.3 世界坐标系的定义"></a>2.3 世界坐标系的定义</h2><p>​前面的一切工作都是为了获得世界坐标系下的加速度，但是世界坐标系到底是怎么定义的，直接关系到了我们对姿态的解算。</p><p>​传感器坐标系的定义与传感器姿态有关，xy轴是相对于传感器确定的，z轴也因此确定下来。而定义的世界坐标系与上电时刻的传感器坐标系有关但是并不完全重合。这在之前可以看出：去除重力加速度分量时仅仅在z轴减去g便可以得到非常稳定的结果，这给我们启发，定义的<strong>世界坐标系的z轴是始终与重力方向相反竖直向上的</strong>，z轴便确定了，而其<strong>xy轴则是上电时刻传感器坐标系的xy轴在垂直于z轴的水平面上的投影</strong>。</p><p>​这样不同的上电姿态只会影响xy轴的方向，但是这也是亟待解决的，因为关系到左右轨迹的确定，如果xy轴不确定，那么左右移动时其在xy轴上的分量也是不确定的。</p><p>​再者，我们所需要的轨迹，本质上都是二维轨迹，换句话说就是我们只需要用到三维轨迹在某个固定的二维平面上的投影即可。于是我们想到可以<strong>令传感器的y轴与魔杖共线，这样xOz平面始终垂直于魔杖</strong>，这样就实现了正常手持魔杖时无论传感器以什么姿态上电，其左右运动对应的都是x的变化。而我们用来分类的轨迹用xOz平面上的投影即可，因为xz轴都是相对于魔杖固定的。</p><p>​只要挥舞时人的朝向与上电时保存一致，后续训练的模型就是可用的。</p><p><img src="/img/mozhang_img/ScreenShot_2025-12-02_105353_677.png" alt="传感器坐标系"></p><p><img src="/img/mozhang_img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250901111919_86.png" alt="传感器安装方法"></p><p>​按照这种方式安装传感器最终得到的效果如下：</p><p><img src="/img/mozhang_img/stitching-collage-1764643940118.jpg" alt="左、右、上、下"></p><h2 id="2-4-数据采集逻辑以及积分环节"><a href="#2-4-数据采集逻辑以及积分环节" class="headerlink" title="2.4 数据采集逻辑以及积分环节"></a>2.4 数据采集逻辑以及积分环节</h2><p>​现在我们可以获得效果非常好的数据，但是我们不能一直获取数据并运算，于是需要做一个“防误触”机制，即设置数据采集和运算的开始标志，最容易想到的便是按钮，按下开始采集，松开停止采集并且将采集到的数据进行运算。此外也可以设置一个阈值，当加速度到达某个阈值时才开始采集，但是后者不太稳定，而且阈值也不好设置，遂采用前者。</p><h3 id="2-4-1-按键触发数据采集"><a href="#2-4-1-按键触发数据采集" class="headerlink" title="2.4.1 按键触发数据采集"></a>2.4.1 按键触发数据采集</h3><p>​直观点要实现按下按钮开始收集数据，松开按钮或者按下时间达到2s后停止记录数据，并且执行数据的一系列计算，然后再按下开启新的一段采集流程。</p><p>基本逻辑为：</p><ol><li>定义三个数组为三轴，按下按钮开始记录，每次循环中将本次数据记录到数组中；在首次按下按钮时初始化一系列变量：包括下标，时间，flag2(开始计时标志)，偏置项</li><li>松开按钮或者时间计时为2s后停止记录并进行积分运算得到轨迹。同时更新flag1，flag2关闭记录通道和积分运算通道。</li></ol><p>​其中为了解决当计时2s已到但是按钮未松开导致一直在记录使数组溢出，定义flag1作为进入记录的标志；其中当按钮为松开状态时flag1为0，即只有按钮松开后才能够再次按下开始记录</p><p>​为了避免平时即使没有记录也进入到积分环节，定义flag2，开始计时时才开始，积分结束后再关闭。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">int</span> buttonPin=<span class="hljs-number">13</span>;<span class="hljs-comment">//按钮GPIO13</span><br><span class="hljs-type">int</span> buttonstate=<span class="hljs-number">0</span>;<span class="hljs-comment">//按钮状态</span><br><span class="hljs-type">int</span> lastbuttonstate=<span class="hljs-number">0</span>;<span class="hljs-comment">//上一次按钮状态</span><br><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<span class="hljs-comment">//下标</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> starttime=<span class="hljs-number">0</span>;<span class="hljs-comment">//开始时间</span><br><span class="hljs-type">int</span> flag1=<span class="hljs-number">0</span>;<span class="hljs-comment">//为了标志2s已到但是按钮未松开的情况的flag</span><br><span class="hljs-type">int</span> flag2=<span class="hljs-number">1</span>;<span class="hljs-comment">//为了标志开始计时的flag</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">if</span>(buttonstate==LOW&amp;&amp;flag1==<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//如果按下按钮</span><br>   <span class="hljs-keyword">if</span>(lastbuttonstate==HIGH)&#123;<span class="hljs-comment">//首次按下按钮</span><br>      i=<span class="hljs-number">0</span>;<span class="hljs-comment">//下标更新</span><br>      starttime=millis();<span class="hljs-comment">//起始时间更新</span><br>      flag2=<span class="hljs-number">0</span>;<span class="hljs-comment">//开始计时标志</span><br>      <span class="hljs-built_in">memset</span>(x_x,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(x_x));<br>      <span class="hljs-built_in">memset</span>(y_x,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(y_x));<br>      <span class="hljs-built_in">memset</span>(z_x,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(z_x));<br>      Serial.println(<span class="hljs-string">&quot;首次按下&quot;</span>);<br>    &#125; <br>    x_acc[i]=worldAccX;<span class="hljs-comment">//更新加速度</span><br>    y_acc[i]=worldAccY;<br>    z_acc[i]=worldAccZ;<br>    i++;<br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span>((millis()-starttime&gt;=<span class="hljs-number">2000</span>||(lastbuttonstate==LOW&amp;&amp;buttonstate==HIGH))&amp;&amp;flag2==<span class="hljs-number">0</span>)&#123;<br>    flag1=<span class="hljs-number">1</span>;<span class="hljs-comment">//关闭记录通道</span><br>    flag2=<span class="hljs-number">1</span>;<span class="hljs-comment">//关闭积分运算通道</span><br>    ...<span class="hljs-comment">//积分运算和模型预测</span><br>    ...<span class="hljs-comment">//串口输出和蓝牙发送等等</span><br>  &#125;<br>  <span class="hljs-keyword">if</span>(buttonstate==HIGH)&#123;flag1=<span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//如果按钮是松开的允许再按记录，如果是按到时间到了结束，不触发flag1变化，不进记录</span><br>  lastbuttonstate=buttonstate;<span class="hljs-comment">//记录上一次按钮状态</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/mozhang_img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250901111002_32.png"></p><p><img src="/img/mozhang_img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250901111006_33.png"></p><p>可以实现两种结束记录的方式。</p><p>​其中是每隔50ms记录一次数据，理论上最多40个数据，但是为了避免溢出定义数组长度为50。至于每隔50ms没有在上述代码中体现出来，因为madgwick算法中的参数delta与时间有关，于是另外做了一个计时的变量count顺便计时50ms运行一次，就没有使用delay(50)的方法。</p><h3 id="2-4-2-积分环节"><a href="#2-4-2-积分环节" class="headerlink" title="2.4.2 积分环节"></a>2.4.2 积分环节</h3><p>​对于获得的三个加速度数组，要对其进行两次积分，这时可以将这几个加速度数组看作分段函数，每一段的时间长度都是50ms，对其积分便是求图象上若干个长方形的面积累加，于是积分问题就转变为了对数组求累加和的问题。同时令两次积分的初始值都为0，就得到了坐标系下的相对运动轨迹。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span> <span class="hljs-title function_">sumwhat</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">float</span> tool[<span class="hljs-number">50</span>])</span>&#123;<span class="hljs-comment">//辅助函数求tool数组的前i项和，再乘上时间间隔0.05s</span><br>  <span class="hljs-type">int</span> j;<br>  <span class="hljs-type">float</span> sum=<span class="hljs-number">0.0</span>;<br>  <span class="hljs-keyword">for</span> (j=<span class="hljs-number">0</span>;j&lt;=i;j++)&#123;<br>    sum+=tool[j]*<span class="hljs-number">0.05</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> sum;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span>&#123;<br>    ...<br>    <span class="hljs-comment">//积分环节</span><br>    Serial.println(<span class="hljs-string">&quot;进入积分&quot;</span>);<br>    <span class="hljs-keyword">for</span> (k=<span class="hljs-number">0</span>;k&lt;i;k++)&#123;<br>      x_v[k]=sumwhat(k,x_acc);<br>      y_v[k]=sumwhat(k,y_acc);<br>      z_v[k]=sumwhat(k,z_acc);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (k=<span class="hljs-number">0</span>;k&lt;i;k++)&#123;<br>      x_x[k]=sumwhat(k,x_v);<br>      y_x[k]=sumwhat(k,y_v);<br>      z_x[k]=sumwhat(k,z_v);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>结果较为准确：</p><p><img src="/img/mozhang_img/stitching-collage-1764644244461.jpg" alt="上、下">           </p><h2 id="2-5-模型训练与部署"><a href="#2-5-模型训练与部署" class="headerlink" title="2.5 模型训练与部署"></a>2.5 模型训练与部署</h2><p>​到目前为止我们成功将运动轨迹解算成对应的相对位移数组，接下来要对上下左右四种轨迹的分类模型进行训练。</p><h3 id="2-5-1-数据集收集"><a href="#2-5-1-数据集收集" class="headerlink" title="2.5.1 数据集收集"></a>2.5.1 数据集收集</h3><p>​为了模拟真实魔杖挥舞场景，将传感器绑在筷子顶端，按照之前确定的方式固定，挥舞魔杖来采集数据。采集过程中也发现，按照人类的使用习惯，传感器安装在魔杖顶端，手握住末端，人手挥动时基本上只动手腕，因此不会出现纯上下左右平移的情况，而是会在Y轴上自然做出一些移动的，比如向上，人习惯向上移动时向内(-Y方向)挥动；向左，人也习惯向左时向内移动一些，这也证明了我们<strong>忽略Y轴位移只看XOZ平面投影的处理和我们安装传感器的方法是正确的</strong>。</p><p>​每次挥舞完成松开按钮后，将计算出来的三轴位移数据串口打印出来，再通过python的pySerial库读取串口数据并且保存在txt文档中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">...<span class="hljs-comment">//在串口打印时要同时输出开始和结束标志，以方便python脚本判断应该保存的部分</span><br>Serial.println(<span class="hljs-string">&quot;===START===&quot;</span>);   <span class="hljs-comment">// 一次动作开始</span><br>    <span class="hljs-keyword">for</span> (k=<span class="hljs-number">0</span>;k&lt;i;k++)&#123;<br>      Serial.print(<span class="hljs-string">&quot;x:&quot;</span>);<br>      Serial.print(x_x[k]);<br>      Serial.print(<span class="hljs-string">&quot;,y:&quot;</span>);<br>      Serial.print(y_x[k]);<br>      Serial.print(<span class="hljs-string">&quot;,z:&quot;</span>);<br>      Serial.println(z_x[k]);<br>      &#125;<br>    Serial.println(<span class="hljs-string">&quot;===END===&quot;</span>);     <span class="hljs-comment">// 一次动作结束</span><br>...<br></code></pre></td></tr></table></figure><p>mozhang.ipynb （数据收集脚本）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> serial<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> os<br><br>SERIAL_PORT = <span class="hljs-string">&quot;COM7&quot;</span><br>BAUD_RATE = <span class="hljs-number">115200</span><br>SAVE_DIR = <span class="hljs-string">r&quot;D:\新建文件夹 (5)\data\RIGHT&quot;</span><span class="hljs-comment">#保存路径</span><br>os.makedirs(SAVE_DIR, exist_ok=<span class="hljs-literal">True</span>)<br><br>ser = serial.Serial(SERIAL_PORT, BAUD_RATE, timeout=<span class="hljs-number">1</span>)<br>time.sleep(<span class="hljs-number">2</span>)<br><br>sample_idx=<span class="hljs-number">1</span><br>recording=<span class="hljs-literal">False</span><br>buffer=[]<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    line = ser.readline().decode(<span class="hljs-string">&quot;utf-8&quot;</span>, errors=<span class="hljs-string">&quot;ignore&quot;</span>).strip()<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> line:<br>        <span class="hljs-keyword">continue</span><br>    <span class="hljs-keyword">if</span> line==<span class="hljs-string">&quot;===START===&quot;</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;开始采集样本 <span class="hljs-subst">&#123;sample_idx&#125;</span>&quot;</span>)<br>        buffer = []<br>        recording = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">continue</span><br>    <span class="hljs-keyword">if</span> line==<span class="hljs-string">&quot;===END===&quot;</span>:<br>        <span class="hljs-keyword">if</span> recording:<br>            filename = os.path.join(SAVE_DIR, <span class="hljs-string">f&quot;sample_<span class="hljs-subst">&#123;sample_idx:03d&#125;</span>.txt&quot;</span>)<br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> f:<br>                f.write(<span class="hljs-string">&quot;\n&quot;</span>.join(buffer))<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;样本 <span class="hljs-subst">&#123;sample_idx&#125;</span> 保存到 <span class="hljs-subst">&#123;filename&#125;</span>&quot;</span>)<br>            sample_idx+=<span class="hljs-number">1</span><br>            recording=<span class="hljs-literal">False</span><br>        <span class="hljs-keyword">continue</span><br>    <span class="hljs-keyword">if</span> recording:<br>        buffer.append(line)<br>        <br> ser.close()<br></code></pre></td></tr></table></figure><p>​最终四个方向各收集到100组数据，依次打包为文件夹。具体样例如下图所示。</p><p><img src="/img/mozhang_img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250901112242_92.png"></p><p><img src="/img/mozhang_img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250901112244_93.png"></p><h3 id="2-5-2-数据预处理"><a href="#2-5-2-数据预处理" class="headerlink" title="2.5.2 数据预处理"></a>2.5.2 数据预处理</h3><p>​将得到了这些txt文档，用python脚本每个逐行遍历，并用正则表达式取出需要的xz轴的数据，再将其打包为一个2×50的矩阵，每个方向的数据整合成一个100×2×50的大矩阵，获得的四个大矩阵先整合起来再将每个小矩阵展平，最终得到一个400×100的矩阵。然后再定义标签向量，依次为100个1、2、3、4。</p><p>mozhang_train.ipynb</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">process_txt</span>(<span class="hljs-params">file_path, max_len=<span class="hljs-number">50</span></span>):<br>    <span class="hljs-comment">#处理单个txt文件，返回一个2x50的矩阵</span><br>    x_vals, z_vals=[],[]<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:<br>            <span class="hljs-keyword">match</span>=re.findall(<span class="hljs-string">r&quot;x:([-+]?\d*\.?\d+),y:([-+]?\d*\.?\d+),z:([-+]?\d*\.?\d+)&quot;</span>, line)<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">match</span>:<br>                x, _, z=<span class="hljs-keyword">match</span>[<span class="hljs-number">0</span>]<br>                x_vals.append(<span class="hljs-built_in">float</span>(x))<br>                z_vals.append(<span class="hljs-built_in">float</span>(z))   <br>    <span class="hljs-comment">#不够的补0</span><br>    x_vals=(x_vals+[<span class="hljs-number">0.0</span>]*max_len)[:max_len]<br>    z_vals=(z_vals+[<span class="hljs-number">0.0</span>]*max_len)[:max_len]<br>    <br>    <span class="hljs-keyword">return</span> np.array([x_vals, z_vals])<br><span class="hljs-comment"># 批量读取文件</span><br>files_1=glob.glob(<span class="hljs-string">r&quot;D:\新建文件夹 (5)\data\1_UP\*.txt&quot;</span>)<br>files_2=glob.glob(<span class="hljs-string">r&quot;D:\新建文件夹 (5)\data\2_DOWN\*.txt&quot;</span>)<br>files_3=glob.glob(<span class="hljs-string">r&quot;D:\新建文件夹 (5)\data\3_LEFT\*.txt&quot;</span>)<br>files_4=glob.glob(<span class="hljs-string">r&quot;D:\新建文件夹 (5)\data\4_RIGHT\*.txt&quot;</span>)<br><br>matrices_1=[process_txt(f) <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> files_1]<br>matrices_2=[process_txt(f) <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> files_2]<br>matrices_3=[process_txt(f) <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> files_3]<br>matrices_4=[process_txt(f) <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> files_4]<br><span class="hljs-comment">#堆叠成三维数组 100×2×50</span><br>data_1=np.stack(matrices_1)<br>data_2=np.stack(matrices_2)<br>data_3=np.stack(matrices_3)<br>data_4=np.stack(matrices_4)<br><span class="hljs-comment">#整合</span><br>X=np.concatenate([data_1,data_2,data_3,data_4],axis=<span class="hljs-number">0</span>)<br>y=np.array([<span class="hljs-number">1</span>]*<span class="hljs-number">100</span>+[<span class="hljs-number">2</span>]*<span class="hljs-number">100</span>+[<span class="hljs-number">3</span>]*<span class="hljs-number">100</span>+[<span class="hljs-number">4</span>]*<span class="hljs-number">100</span>)<br><span class="hljs-comment">#展平</span><br>X=X.reshape(X.shape[<span class="hljs-number">0</span>],-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p><img src="/img/mozhang_img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250901112340_95.png"></p><h3 id="2-5-3-模型训练"><a href="#2-5-3-模型训练" class="headerlink" title="2.5.3 模型训练"></a>2.5.3 模型训练</h3><p>​接下来我们将数据集按照7：3比例分为训练集和验证集，用支持向量机SVM训练模型，得到了准确率为0.942的模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><span class="hljs-keyword">from</span> sklearn.svm <span class="hljs-keyword">import</span> SVC<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> classification_report, accuracy_score<br><span class="hljs-comment">#划分训练集和测试集</span><br>X_train, X_test, y_train, y_test = train_test_split(<br>    X, y, test_size=<span class="hljs-number">0.3</span>, random_state=<span class="hljs-number">41</span>, stratify=y<br>)<br><span class="hljs-comment">#用SVM训练</span><br>clf = SVC(kernel=<span class="hljs-string">&#x27;rbf&#x27;</span>, C=<span class="hljs-number">1</span>, gamma=<span class="hljs-number">1.0</span>)<span class="hljs-comment">#此处gamma参数决定rgb核的宽度，经尝试1.0时效果最好，转c语言的时候gamma需要为定值</span><br>clf.fit(X_train, y_train)<br><span class="hljs-comment">#预测</span><br>y_pred = clf.predict(X_test)<br><span class="hljs-comment">#评估</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;准确率:&quot;</span>, accuracy_score(y_test, y_pred))<br><span class="hljs-built_in">print</span>(classification_report(y_test, y_pred))<br></code></pre></td></tr></table></figure><p><img src="/img/mozhang_img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250901112401_96.png"></p><p>以下为将所有数据经模型运行一遍后得到的预测结果，几乎是能够完全分类正确的。</p><p><img src="/img/mozhang_img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250901112404_97.png"></p><h3 id="2-5-4-模型部署"><a href="#2-5-4-模型部署" class="headerlink" title="2.5.4 模型部署"></a>2.5.4 模型部署</h3><p>​目前只在python中训练出了模型，我们需要将其部署到esp32上，使其不依赖于电脑便可以运行模型实现轨迹分类。</p><p>​需要用到上位机吗？并不需要，因为：</p><p>​1.上下左右轨迹特征度高</p><p>​2.数据量下，仅400个</p><p>​3.用的是机器学习的SVM算法，比较简单</p><p>​因此说明我们得到的模型相对简单，可能esp32自带的算力便可以支持。</p><p>​一个模型本身可以看作是一个包含矩阵运算的复杂数学函数，只要我们能够将模型的数学形式表示出来，便可以用c语言的形式写出来，但是这种模型的参数一般都非常多而且复杂，于是我们选择使用micromlgen库，其支持将简单的python模型导出为c语言形式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> micromlgen <span class="hljs-keyword">import</span> port<br>c_code=port(clf)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">r&quot;D:\新建文件夹 (5)\data\classifier.h&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(c_code)<br></code></pre></td></tr></table></figure><p>用micromlgen库成功导出模型的c语言版本后，得到的结果为：（仅为部分代码，原函数见 mozhang\classifier.h）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdarg&gt;</span></span><br>namespace Eloquent &#123;<br>    namespace ML &#123;<br>        namespace Port &#123;<br>            <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SVM</span> &#123;</span><br>                public:<br>                    <span class="hljs-comment">/**</span><br><span class="hljs-comment">                    * Predict class for features vector</span><br><span class="hljs-comment">                    */</span><br>                    <span class="hljs-type">int</span> <span class="hljs-title function_">predict</span><span class="hljs-params">(<span class="hljs-type">float</span> *x)</span> &#123;<br>                        <span class="hljs-type">float</span> kernels[<span class="hljs-number">131</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>                        <span class="hljs-type">float</span> decisions[<span class="hljs-number">6</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>                        <span class="hljs-type">int</span> votes[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>                        kernels[<span class="hljs-number">0</span>] = compute_kernel(x,   <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">-0.0</span>  , <span class="hljs-number">-0.0</span>  , <span class="hljs-number">0.1</span>  , <span class="hljs-number">0.18</span>  , <span class="hljs-number">0.19</span>  , <span class="hljs-number">0.19</span>  , <span class="hljs-number">0.19</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">-0.0</span>  , <span class="hljs-number">-0.0</span>  , <span class="hljs-number">0.03</span>  , <span class="hljs-number">0.14</span>  , <span class="hljs-number">0.27</span>  , <span class="hljs-number">0.31</span>  , <span class="hljs-number">0.33</span>  , <span class="hljs-number">0.33</span>  , <span class="hljs-number">0.34</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span>  , <span class="hljs-number">0.0</span> );<br>                        ...<br>                        decisions[<span class="hljs-number">0</span>] = <span class="hljs-number">-0.206241160743</span><br>                        + kernels[<span class="hljs-number">0</span>] * <span class="hljs-number">0.06523232929</span><br>                        + kernels[<span class="hljs-number">6</span>] * <span class="hljs-number">0.60241767888</span><br>                        + kernels[<span class="hljs-number">7</span>] * <span class="hljs-number">0.239027242719</span><br>                        + kernels[<span class="hljs-number">8</span>] * <span class="hljs-number">0.452574668479</span><br>                        + kernels[<span class="hljs-number">9</span>] * <span class="hljs-number">0.31387810585</span><br>                        + kernels[<span class="hljs-number">11</span>]<br>                        + kernels[<span class="hljs-number">15</span>] * <span class="hljs-number">0.786632371654</span><br>                        + kernels[<span class="hljs-number">17</span>] * <span class="hljs-number">0.353397278291</span><br>                        + kernels[<span class="hljs-number">18</span>]<br>                        + kernels[<span class="hljs-number">19</span>] * <span class="hljs-number">0.162507380842</span><br>                        + kernels[<span class="hljs-number">20</span>] * <span class="hljs-number">0.252686093615</span><br>                        ...<br>                    &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>而mozhang.ino的改动如下：导入了clf模型，添加了存放输入输出的变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;classifier.h&quot;</span></span><br>Eloquent::ML::Port::SVM clf;<span class="hljs-comment">//实例化模型</span><br>...<br><span class="hljs-type">float</span> input[<span class="hljs-number">100</span>]=&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//用于跑模型的变量</span><br><span class="hljs-type">int</span> pred;<span class="hljs-comment">//预测结果</span><br>...<br><span class="hljs-type">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span>&#123;<br>    ...<br>    <span class="hljs-keyword">for</span> (k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">50</span>;k++)&#123;<br>          input[k]=x_x[k];<br>          input[k+<span class="hljs-number">50</span>]=z_x[k];<br>        &#125;<br>    ...<br>    pred=clf.predict(input);<br>    Serial.println(pred);<br>&#125;<br></code></pre></td></tr></table></figure><p>​经上电测试，发现上下左右的标签对应变成了0、1、2、3，但是仍然实现了轨迹分类，并且模型运行速度非常快，松开按钮后零延迟输出预测结果，说明esp32的算力是充足的。</p><p><img src="/img/mozhang_img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250901112453_102.png"></p><p>​这同时也定义了一个工作流，如果要添加新的轨迹的话，只需要按照数据收集、模型训练、模型部署的顺序更新一遍即可。</p><h2 id="2-6-蓝牙传输"><a href="#2-6-蓝牙传输" class="headerlink" title="2.6 蓝牙传输"></a>2.6 蓝牙传输</h2><p>​esp32自带蓝牙模块，可以直接用库函数调用。</p><p>​其中魔杖的开发板作为主机，小车的开发板作为从机。依次定义名称为”ESP32_BT”和”vehicle”，但是并不能用名称连接，而是要用从机的mac地址连接，连接再用SerialBT.print()便可实现蓝牙通信。同时为了直观观察蓝牙是否连接成功，定义了一个LED灯来指示，成功连接就闪烁三下，失败就一直亮。</p><p>主机mozhang.ino</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;BluetoothSerial.h&quot;</span></span><br>...<br>BluetoothSerial SerialBT;<span class="hljs-comment">//定义</span><br>...<br><span class="hljs-type">void</span> <span class="hljs-title function_">setup</span><span class="hljs-params">()</span>&#123;<br>  ...<br>  SerialBT.begin(<span class="hljs-string">&quot;ESP32_BT&quot;</span>,<span class="hljs-literal">true</span>);<br>  <span class="hljs-type">uint8_t</span> macAddr[<span class="hljs-number">6</span>]=&#123;<span class="hljs-number">0x84</span>, <span class="hljs-number">0x1F</span>, <span class="hljs-number">0xE8</span>, <span class="hljs-number">0x15</span>, <span class="hljs-number">0xBE</span>, <span class="hljs-number">0x4E</span>&#125;;<br><br>  <span class="hljs-keyword">if</span> (SerialBT.connect(macAddr)) &#123;<br>    Serial.println(<span class="hljs-string">&quot;Connected to Slave!&quot;</span>);<br>    <span class="hljs-keyword">for</span> (k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">3</span>;k++) &#123;<span class="hljs-comment">//蓝牙连接成功提升:灯闪三下</span><br>      digitalWrite(LED_PIN, HIGH);<br>      delay(<span class="hljs-number">300</span>);<br>      digitalWrite(LED_PIN, LOW);<br>      delay(<span class="hljs-number">300</span>);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    Serial.println(<span class="hljs-string">&quot;Failed to connect to Slave.&quot;</span>);<br>    digitalWrite(LED_PIN, HIGH);<span class="hljs-comment">//蓝牙连接失败提示:灯一直亮</span><br>  &#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span>&#123;<br>    ...<br>SerialBT.println(pred);<span class="hljs-comment">//发送</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从机vehicle.ino</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;BluetoothSerial.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;esp_bt_device.h&quot;</span></span><br><br>BluetoothSerial SerialBT;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">setup</span><span class="hljs-params">()</span> &#123;<br>  Serial.begin(<span class="hljs-number">115200</span>);<br>  SerialBT.begin(<span class="hljs-string">&quot;vehicle&quot;</span>);  <span class="hljs-comment">//从机名称</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span>* mac = esp_bt_dev_get_address();<br>  Serial.<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ESP32 Bluetooth MAC address: %02X:%02X:%02X:%02X:%02X:%02X\n&quot;</span>,<br>                mac[<span class="hljs-number">0</span>], mac[<span class="hljs-number">1</span>], mac[<span class="hljs-number">2</span>], mac[<span class="hljs-number">3</span>], mac[<span class="hljs-number">4</span>], mac[<span class="hljs-number">5</span>]);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (SerialBT.available()) &#123;<br>      <span class="hljs-type">char</span> msg = SerialBT.read();<br>      <span class="hljs-comment">//用msg控制小车</span><br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p><img src="/img/mozhang_img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250901112650_111.png"></p><h1 id="三、小车part"><a href="#三、小车part" class="headerlink" title="三、小车part"></a>三、小车part</h1><h2 id="3-1-硬件"><a href="#3-1-硬件" class="headerlink" title="3.1 硬件"></a>3.1 硬件</h2><p>​小车所用的硬件有TB6612稳压板和带光电编码器的直流电机，以及控制他们的esp32开发板。</p><p>​在TB6612稳压板上，其对电机的控制通过七个管脚：STBY、PWMA&#x2F;PWMB、AIN1&#x2F;AIN2、BIN1&#x2F;BIN2。其中PWM控制速度，IN1&#x2F;IN2控制方向，只有STBY高电平时才会激活控制。</p><p>​编码器的相关管脚为E1A&#x2F;E1B，E2A&#x2F;E2B，依次表示左右轮的A相和B相，A相用来判断速度，用固定时间内的脉冲数来换算；B相用来判断方向，通过B相相对于A相是超前还是落后来判断。本来用的是双轮平衡小车，想要通过调节PID来使其直立平衡和运动平衡，但是控制需要得到双轮转速来进行反馈调节，每转脉冲数600，轮径4.5cm，轮距10cm都已经测出。但是右轮电机的光电编码器是坏的，不能准确测出脉冲数，因此不能测出速度，不能实现双轮平衡。</p><p>​于是我们采取添加拓展版加牛眼轮的方法使小车能够平衡。</p><p>​管脚连接为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PWMA 12  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AIN1 14</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AIN2 27</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PWMB 13  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BIN1 33</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BIN2 32</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STBY 26  </span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENCODER_L   19   <span class="hljs-comment">//左轮A相</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DIRECTION_L 22   <span class="hljs-comment">//左轮B相</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENCODER_R   18   <span class="hljs-comment">//右轮A相</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DIRECTION_R 23   <span class="hljs-comment">//右轮B相</span></span><br></code></pre></td></tr></table></figure><p><img src="/img/mozhang_img/stitching-collage-1764644572720.jpg"></p><h2 id="3-2-控制逻辑"><a href="#3-2-控制逻辑" class="headerlink" title="3.2 控制逻辑"></a>3.2 控制逻辑</h2><p>​因为测速有问题，并不能实现过于精确的逻辑控制，于是仅仅做了简单的控制逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span> <br>&#123;<br>  <br>  <span class="hljs-keyword">if</span> (SerialBT.available()) &#123;<br>    msg = SerialBT.read();<br>    Serial.println(msg);<br>    <span class="hljs-keyword">if</span>(msg==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<span class="hljs-comment">//前进</span><br>      SetPWM(<span class="hljs-number">1</span>, <span class="hljs-number">70</span>);<br>      SetPWM(<span class="hljs-number">2</span>, <span class="hljs-number">70</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(msg==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;<span class="hljs-comment">//停止</span><br>        SetPWM(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        SetPWM(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(msg==<span class="hljs-string">&#x27;2&#x27;</span>)&#123;<span class="hljs-comment">//左转</span><br>      SetPWM(<span class="hljs-number">1</span>,<span class="hljs-number">40</span>);<br>      SetPWM(<span class="hljs-number">2</span>,<span class="hljs-number">70</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(msg==<span class="hljs-string">&#x27;3&#x27;</span>)&#123;<span class="hljs-comment">//右转</span><br>      SetPWM(<span class="hljs-number">1</span>,<span class="hljs-number">70</span>);<br>      SetPWM(<span class="hljs-number">2</span>,<span class="hljs-number">40</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​如果测速功能正常，可以按照当前状态是否静止，或者当前是前进还是后退，用if-else和switch-case语句来实现更多样的控制。</p><p><img src="/img/mozhang_img/ScreenShot_2025-12-02_110409_690.png"></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>本篇写于2025.12.2，嵌高已经出分一个半月了，但是我的五百块钱报销还没下来，不愧是控院。回顾这个项目，虽然是小组作业，但是还是全程全部是我C完的😒(虽然也没花多少时间，8.23开始，9.3结束)。第一次从0开始搭建一个项目，虽然逻辑很简单，但是最后跑起来的适合还是很高兴，这个项目最难的还是驯服那个三轴加速度，我中期答辩就卡在那里了，那时候还天天科二练车，这边还死活做不出来，我严重怀疑商家给我的传感器是残次品。第二个就是搞懂坐标系的定义，真忘不了那个下午，拿着根筷子在书桌前挥舞，最后用一堆实验数据归纳出了结论，然后碰巧又是正确的，神了。从那个时候茅塞顿开，后面训练部署什么的都一口气完成。</p><p>所有代码均已经上传github</p><p><a href="https://github.com/DKESTXD/qiangao-mozhang">https://github.com/DKESTXD/qiangao-mozhang</a></p><p>里面有演示视频和制作日志，挺好玩的还</p><h3 id="可改进之处"><a href="#可改进之处" class="headerlink" title="可改进之处"></a>可改进之处</h3><ul><li>世界坐标系定义问题。前文中说到世界坐标系在上电瞬间就确定下来了，因此在使用魔杖时只能始终面朝上电方向，或者说这时左右变成了一个绝对的定义而不是相对人身体的定义，比如如果上电后转身180°再使用的话，左右轨迹的判断就反过来了</li><li>小车的平衡问题。因为右轮电机的编码器问题，没能实现优雅的双轮平衡小车，而是加了辅助轮。</li><li>模型还可以再改，可以将y轴考虑进去，用3D轨迹，用更大更复杂的模型训练，使得轨迹判断更精确，甚至能够解决世界坐标系定义导致的使用魔杖时转身导致不准的问题。</li></ul>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于azumanga中最喜欢的角色排名</title>
    <link href="/2025/06/27/%E5%85%B3%E4%BA%8Eazumanga%E4%B8%AD%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E8%A7%92%E8%89%B2%E6%8E%92%E5%90%8D/"/>
    <url>/2025/06/27/%E5%85%B3%E4%BA%8Eazumanga%E4%B8%AD%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E8%A7%92%E8%89%B2%E6%8E%92%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<p>TOP 1  osaka (忽略图片里面的黑边，b站全集就是这样的)</p><span id="more"></span><h3 id="TOP1：osaka"><a href="#TOP1：osaka" class="headerlink" title="TOP1：osaka"></a>TOP1：osaka</h3><p>大阪osaka，春日步。天然呆鼻祖，眼睛高光在下面的含金量，adhd重度患者，单线程处理，名场面的神，思维跳跃的冷笑话谐音梗大王。作为最出圈最热门的角色，这也是我追这部番最开始的入坑理由。因为大阪真的太有意思了，以及声优的慵懒温柔的声线，和尾音的aya，浑然天成，我已经五分钟没有复习wuhahah了，omg！</p><p><img src="/img/aziman/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20251210225758_609_49.jpg"></p><h3 id="TOP2：榊"><a href="#TOP2：榊" class="headerlink" title="TOP2：榊"></a>TOP2：榊</h3><p>毫无疑问的榊，如果说我开始看这部番是为了osaka，那么榊一定是我挖掘出来的第一个宝藏角色。黑长直高大帅气高冷外貌和喜欢毛茸茸可爱动物的反差，以及天生克猫的debuff，以及温柔呆呆的性格，非常有人格魅力，最后也是终于找到了梦中情猫maya，有一个非常棒的结局。永远的榊！</p><p><img src="/img/aziman/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20251210223957_592_49.jpg"></p><h3 id="TOP3：阿历"><a href="#TOP3：阿历" class="headerlink" title="TOP3：阿历"></a>TOP3：阿历</h3><p>我只看到了一个努力学习却险些落榜，想要减肥，每天应付阿智的绝望女高中生(bushi)。相较于其他神人来说，阿智是正常的，正常意味着普通，但是普通也是它的人格魅力所在，尤其是魔法乐园那一集，阿历少见作为主角，这一集的强烈反差使得更喜欢阿历了。</p><p><img src="/img/aziman/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20251210230543_612_49.jpg"></p><h3 id="TOP4：阿乐"><a href="#TOP4：阿乐" class="headerlink" title="TOP4：阿乐"></a>TOP4：阿乐</h3><p>作为被油咖喱半路拐来的黑皮体育生，在前期对她的印象其实一般，只感觉是另一个版本的阿智，尤其在笨蛋三人组那一集。但是就在神回第19回之后，她作为一个体育生是最早意识到为毕业后做准备的，从此她的形象立体起来，她的超雄相较于阿智的更像是一种竞争心的体现，因为好胜心强，所以才会怕失败，才会更早的准备，最贴近现实的一个人物。她就像是一把钥匙，打开了主角团其他人心中关于未来去向的一扇门，从剧情展开，她是必要的角色，由她来担任这个最先意识到压力的角色是相当合理的。</p><p><img src="/img/aziman/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20251210230545_614_49.jpg"></p><h3 id="TOP5：千代"><a href="#TOP5：千代" class="headerlink" title="TOP5：千代"></a>TOP5：千代</h3><p>汽油酱，对千代的印象很奇特，本身是天才少女跳级生加富姐，智力像高中生，但是只有智力像高中生。他是整个主角团的灵魂人物（因为暑假篇都是在她家的别墅里过的(bushi)）。爱千tv，千代怪叫，磁吸麻花辫，千代生气下楼走正步都是名场面，但是却又不像osaka那样深入人心，明明非常特殊，却因为特殊之处太多了导致印象不深，就像到了后期几乎都忘记了她是个小学跳级生了。</p><p><img src="/img/aziman/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20251210225757_608_49.jpg"></p><h3 id="TOP5：香香"><a href="#TOP5：香香" class="headerlink" title="TOP5：香香"></a>TOP5：香香</h3><p>香香的设定很简单，榊的绝对梦女，但是经常被变态山村缠上。一直很倒霉，偶尔很幸福，很正常很单纯的角色。</p><p><img src="/img/aziman/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20251210230814_617_49.jpg"></p><h3 id="TOP6：喵喵"><a href="#TOP6：喵喵" class="headerlink" title="TOP6：喵喵"></a>TOP6：喵喵</h3><p>黑泽老师，处在一个小孩子与成熟的成年人的中间态，既没有油咖喱那样的没心没肺，也不像一个真正的成年人那样成熟，尤其是在第十九回展示了她的内心想法。喵喵戏份虽然不多，但是塑造的真的很棒，尤其是酒后说胡话那一段。</p><p><img src="/img/aziman/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20251210230322_611_49.jpg"></p><h3 id="TOP7：油咖喱"><a href="#TOP7：油咖喱" class="headerlink" title="TOP7：油咖喱"></a>TOP7：油咖喱</h3><p>知名出生油咖喱，看似是老师，实际上比小孩还要小孩，这种反差感非常的有意思，偶尔还穿插了一些作为大人的人性，还像个人。油咖喱也贡献了非常多的名场面，如逆天车技，osaka单杀油咖喱。总之油咖喱的存在是非常缺一不可的，作为这个神人班级的班主任，只有油咖喱能驾驭。</p><p><img src="/img/aziman/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20251210230320_610_49.jpg"></p><h3 id="TOP8：阿智"><a href="#TOP8：阿智" class="headerlink" title="TOP8：阿智"></a>TOP8：阿智</h3><p>我知道这是像塑造一个大大咧咧，亢奋精力充沛的活宝形象，但是有些时候太过了，以至于超越了原本的塑造，直接塑造成出生了，比如把别墅钥匙丢进树林、在食堂追杀阿历，这些剧情甚至有些匪夷所思了。这就导致阿智一直喜欢不起来。但是客观的讲，阿智的塑造也是成功的，主角团需要这样一个没心没肺的人物来创造危险与冲突。</p><p><img src="/img/aziman/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20251210225312_597_49.jpg"></p><h3 id="TOP9：山村"><a href="#TOP9：山村" class="headerlink" title="TOP9：山村"></a>TOP9：山村</h3><p>作为主角团唯一一个男角色，简直不是人，僵尸说是。说实话设计这个角色纯属恶趣味了，一开始泳池篇看他的时候还抱有一丝侥幸，后来发现这哥们纯变态啊。虽然剧中有很多细节告诉我们山村其实也是个善良的人，但是这和他是个变态并不冲突。但是他的太太却非常漂亮，而且也属于那种走路撞栏杆的笨蛋形象，这对吗。</p><p><img src="/img/aziman/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20251210225316_600_49.jpg"></p><p>总之这部2001年的番对于后续日常番的降维打击，一方面在于其剧情的完整，一方面在于其笑点的实现。其并没有像日常番那种时间冻结一般的展开，而是从高中开学第一天开始，到高中毕业结束，每一回都是一个时间段，在这其中不仅逐步丰满人物形象，而且人物也在慢慢成长，日常番的精髓在于没有明确的主线，但是也不能脱离宏观上时间的主线。另外它的叙事风格是极其舒缓平静的，它的笑点的丢出不是靠人物的夸张动作或者大声吐槽，而是用冷笑话式的沉默画面、魔性而幽默的循环以及经典的慢慢转头等小动作实现的，总能让人会心一笑。<br>总之好看就对了，omg！</p><p>meme持续更新中…</p><p><video src="/img/aziman/3b4d90fa99f1c8a1abaa6306c4b96307.mp4" position="absolute" width="100%" height="100%" controls="controls"></video></p><p><img src="/img/aziman/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20251210225754_605_49.jpg"></p><p><img src="/img/aziman/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20251210225756_607_49.jpg"></p><p><img src="/img/aziman/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20251210230544_613_49.jpg"></p><p><img src="/img/aziman/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20251210230547_615_49.jpg"></p><p><img src="/img/aziman/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20251210230549_616_49.jpg"></p><p><img src="/img/aziman/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20251210230814_617_49.jpg"></p><p><img src="/img/aziman/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20251210230817_618_49.jpg"></p><p><img src="/img/aziman/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20251210223958_593_49.jpg"></p><p><img src="/img/aziman/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20251210223959_594_49.jpg"></p><p><img src="/img/aziman/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20251210224119_596_49.jpg"></p><p><img src="/img/aziman/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20251210225313_598_49.jpg"></p><p><img src="/img/aziman/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20251210225315_599_49.jpg"></p><p><img src="/img/aziman/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20251210225317_601_49.jpg"></p><p><img src="/img/aziman/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20251210225318_602_49.jpg"></p><p><img src="/img/aziman/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20251210225319_603_49.jpg"></p><p><img src="/img/aziman/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20251210225753_604_49.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>enjoy yourself</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>用排队论模拟分析食堂排队问题以及仿真</title>
    <link href="/2025/05/25/%E7%94%A8%E6%8E%92%E9%98%9F%E8%AE%BA%E6%A8%A1%E6%8B%9F%E5%88%86%E6%9E%90%E9%A3%9F%E5%A0%82%E6%8E%92%E9%98%9F%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9F/"/>
    <url>/2025/05/25/%E7%94%A8%E6%8E%92%E9%98%9F%E8%AE%BA%E6%A8%A1%E6%8B%9F%E5%88%86%E6%9E%90%E9%A3%9F%E5%A0%82%E6%8E%92%E9%98%9F%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9F/</url>
    
    <content type="html"><![CDATA[<p>虽然本题假设的食堂排队情况比较理想，但是也算是合理的模型了，仿真起来也是非常方便的(理论求解是另一个哥们做的，仿真的part是我做的，在ai横行的时代，老艺术家还是会选择手搓)。</p><span id="more"></span><h2 id="1-排队论"><a href="#1-排队论" class="headerlink" title="1 排队论"></a>1 排队论</h2><p>排队论（Queueing Theory）是数学和运筹学的一个分支，研究系统在资源有限且需求随机的情况下，如何形成排队现象以及如何优化服务效率。其核心目标是分析等待时间、队列长度、服务效率等指标，为系统设计提供理论支持。</p><p>任何一个排队问题的基本排队过程都可以用下图表示。从图可知,每个顾客由顾客源按一定方式到达服务系统,首先加入队列排队等待接受服务,然后服务台按一定规则从队列中选择顾客进行服务,获得服务的顾客立即离开。通常,排队系统都有输入过程、服务台、服务时间、服务规则等4个组成部分。</p><p><img src="data:image/png;base64,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UmWT35ulbHeMu0zr2iaCZ3PXbZ74rYatT4FlxH1nrXPW5xdB9brN3dH+IsawE+rIvs7Pf/7z3Xe+851deQpNfi9v9ieC5/KabjWvMwVyV18d89wJC5EQorl/85vfLHcTutz3vOc9b3eiE52oTNcf//jH7rvf/W65/Lcu0fB/+tOfdr/97W+7M53pTOXrIZrVd6T++te/7r72ta91P/vZz7o99tijXAJ8kpOcpPvKV77S/eY3vyl1nPjEJ+7OcY5zlEuI69jW7373u+773/9+uTZuVKkvNNeOvsdKMSYuPncupl71nOIUp+jOfe5zl3Y9a0w//vGPy5j10Wdf//rXu9Oe9rTdXnvtVeiUcbZtErtnVedg9hOe8ISdn1aWT4EGnsun8ZZsgRAkKHO33igg2JKDG9NpMaO73vWunSvZTnnKU3b+v/e9793d61736j73uc91r3/967v3vOc93V3ucpfu5Cc/eQHT05/+9N3FLnaxcgnwC17wggIsL37xi0srX/jCFzrWwB/+8IcCSpe61KXK7yR3vPWtb+3udre7dXvuuWcHDC9ykYt05zznOctVcIBb+clPftI99KEP7e5///uX+QBWlBqf3/SmN+1ucIMbdPvuu28Bwez3Uz/ABfxi19p/7nOf2732ta8toEjAfvvb3y6/9cd7wBSYe8+zwBJoPvjBDy6A/vSnP30X5V75yld2v/rVr7pHP/rRpb5W1oMCQ7ebrEfPtl8vGnhuvzldyIiOPvroYhFd+MIXLgJ2J1idCAdkjjrqqO6qV71qAbXrXve63dOe9rTy2Y9+9KNikX7ve9/rnvGMZ5RbZ1iZMpPPf/7zF/D8+c9/3v3iF7/YNQfefeMb39id+tSnLp8/73nP665znesUEFRYjizMF73oRd2b3/zmAswO92ZlAiiAdotb3KJYw1FgtKscdthh3ac//elyEDggB6pA2LyZv4c//OHd+c53vvIsAL3HPe7R3epWtyr9fNnLXlb6ApSvdrWrlb598pOfLMDJamZVKq9+9au7D3/4w9373//+Uu/b3/720ob+v+IVryjtXPGKVyyg6x1nq7JGW2kU2O4UaOC53Wd4zvERmI973OO6173udTvuMmxAs88++5TYEUC44x3vWNyot771rbt3vetdxY35pCc9qVhjucGC2/XQQw8tQMNaBa6XuMQlul/+8pfd7W53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"></p><h3 id="1-1基本组成要素"><a href="#1-1基本组成要素" class="headerlink" title="1.1基本组成要素"></a>1.1基本组成要素</h3><p>排队系统的核心由三部分构成：</p><p>顾客（Clients）：请求服务的个体（如人、任务、数据包等），其到达时间通常是随机的。<br>队列（Queue）：顾客等待服务的区域。队列的规则可能是先到先服务（FIFO）、优先级服务等。<br>服务台（Servers）：提供服务的资源（如柜台、CPU、通信信道等），服务时间也可能具有随机性。</p><h3 id="1-2-排队模型的表示（Kendall记号）"><a href="#1-2-排队模型的表示（Kendall记号）" class="headerlink" title="1.2 排队模型的表示（Kendall记号）"></a>1.2 排队模型的表示（Kendall记号）</h3><p>常用A&#x2F;B&#x2F;C&#x2F;D&#x2F;E表示一个排队系统：</p><p>A：顾客到达时间间隔的分布（如M表示泊松过程&#x2F;指数分布，D为确定型，G为一般分布）。<br>B：服务时间的分布（符号同A）。<br>C：服务台数量（如1、s或∞）。<br>D：系统容量（队列的最大长度，默认无限）。<br>E：顾客群体规模（默认无限）。</p><p>经典模型示例：</p><p>M&#x2F;M&#x2F;1：泊松到达、指数服务时间、单服务台、无限队列。<br>M&#x2F;M&#x2F;c：多服务台版本。</p><h3 id="1-3-关键性能指标"><a href="#1-3-关键性能指标" class="headerlink" title="1.3 关键性能指标"></a>1.3 关键性能指标</h3><p>排队论通过以下指标评估系统性能：</p><p>平均队列长度（Lq）：等待服务的顾客数。<br>平均系统内顾客数（L）：包括正在接受服务的顾客。<br>平均等待时间（Wq）：顾客在队列中的等待时间。<br>平均逗留时间（W）：等待时间+服务时间。<br>服务台利用率（ρ）：服务台繁忙时间的比例（ρ&#x3D;λ&#x2F;μ，λ为到达率，μ为服务率）。</p><h3 id="1-4-基本原理与公式"><a href="#1-4-基本原理与公式" class="headerlink" title="1.4 基本原理与公式"></a>1.4 基本原理与公式</h3><p>(1)Little’s Law（利特尔公式）</p><p>适用于稳态排队系统，揭示队列长度与等待时间的关系：<br>$$<br>L&#x3D;\lambda W\<br>L_q&#x3D;\lambda W_q<br>$$<br>其中，λ是平均到达率。</p><p>(2)M&#x2F;M&#x2F;1模型公式</p><p>队列长度：$L&#x3D;\frac{\rho}{1-\rho}$<br>等待时间：$W_q&#x3D;\frac{\rho}{\mu(1-\rho)}$<br>系统空闲概率：$P_0&#x3D;1-\rho$</p><p>(3)泊松过程与指数分布</p><p>到达间隔：若顾客到达符合泊松过程（强度λ），则间隔时间服从指数分布∼Exp(λ)。<br>无记忆性：指数分布的特性使得未来事件与过去无关，简化了分析。</p><h2 id="2-食堂排队情况建模"><a href="#2-食堂排队情况建模" class="headerlink" title="2 食堂排队情况建模"></a>2 食堂排队情况建模</h2><p><strong>问题描述</strong>：食堂在午餐时段（11:30-13:30）开放。食堂共有8个窗口，可动态调整开放数量（最少开放6个，最多10个）。每个窗口可提供3类菜品（如快餐、面食、特色菜）其中之一，不同菜品的制作时间和热门度不同。<br><strong>满意度计算公式</strong>：满意度&#x3D;菜品热门度&#x2F;等待时间<br><strong>学生到达率(人&#x2F;分钟)</strong>(用泊松过程模拟)：11:30-12:00：10人&#x2F;分钟；12:00-13:00：15人&#x2F;分钟；13:00-13:30：5人&#x2F;分钟。<br><strong>学生排队情况</strong>：采用排队论模型。<br><strong>菜品制作时间</strong>：快餐：0.5分钟&#x2F;人；面食：0.8分钟&#x2F;人；特色菜：1分钟&#x2F;人。<br><strong>菜品热门度</strong>(越高越受欢迎)：快餐：0.2；面食：0.3；特色菜：0.5。<br><strong>约束设置</strong>：一个窗口只能服务一条队列，当队列长度达到10人时，后面到达的学生会自动选择其他窗口；特色菜限量供应250份，一旦售完，该窗口将不可用。<br><strong>目标</strong>：在提高窗口利用率的同时，使所有学生的总满意度达到最大，并不产生队列溢出现象（到达的学生无队可排）。<br><strong>问题要求</strong>：给出11:30-12:00、12:00-13:00与13:00-13:30三个时间段食堂开放的窗口数量与每个窗口的菜品类别。</p><h3 id="2-1-理论建模与求解"><a href="#2-1-理论建模与求解" class="headerlink" title="2.1 理论建模与求解"></a>2.1 理论建模与求解</h3><h4 id="2-1-1-符号与参数"><a href="#2-1-1-符号与参数" class="headerlink" title="2.1.1 符号与参数"></a>2.1.1 符号与参数</h4><table><thead><tr><th>时间段</th><th>到达率λ（人&#x2F;分钟）</th><th>持续时间t（分钟）</th><th>总人数</th></tr></thead><tbody><tr><td>1：11：30-12：00</td><td>λ1&#x3D;10</td><td>30</td><td>300人</td></tr><tr><td>2：12：00-13：00</td><td>λ2&#x3D;15</td><td>60</td><td>900人</td></tr><tr><td>3：13：00-13：30</td><td>λ3&#x3D;5</td><td>30</td><td>150人</td></tr></tbody></table><p>总共到达学生人数：300+900+150&#x3D;1350人<br>①设$x_{itk}\in{0,1}$：表示在时间段<em>t</em>中，第<em>i</em>个窗口选择第<em>k</em>类菜品（1&#x3D;快餐，2&#x3D;面食，3&#x3D;特色菜）<br>②设$n_t\in[6,10]$：表示时间段<em>t</em>中开放的窗口数量<br>窗口编号：$i &#x3D; 1,2,…,10$<br>时间段编号：$t &#x3D; 1,2,3$<br>菜品编号：$k &#x3D; 1,2,3$</p><h4 id="2-1-2-模型建立"><a href="#2-1-2-模型建立" class="headerlink" title="2.1.2 模型建立"></a>2.1.2 模型建立</h4><p>1.排队模型（M&#x2F;M&#x2F;1）<br>每个窗口视为一个服务节点，服从M&#x2F;M&#x2F;1模型：<br>对于窗口<em>i</em>提供菜品<em>k</em>，服务率$μ_k &#x3D; 1&#x2F;s_k$，其中：<br>①快餐：$s1 &#x3D; 0.5$分钟，即$μ1 &#x3D; 2$<br>②面食：$s2 &#x3D; 0.8$分钟，即$μ2 &#x3D; 1.25$<br>③特色菜：$s3 &#x3D; 1$分钟，即$μ3 &#x3D; 1$</p><p>2.菜品热门度（决定顾客选择概率）<br>设热门度为：<br>①快餐：$h1 &#x3D; 0.2$<br>②面食：$h2 &#x3D; 0.3$<br>③特色菜：$h3 &#x3D; 0.5$<br>当窗口可选且排队未满（&lt;10人），学生会优先选择热门度高的窗口</p><p>3.满意度公式<br>每位学生的满意度为：$S&#x3D;\frac{h_K}{W}$<br>其中<em>W</em>为等待时间，M&#x2F;M&#x2F;1系统平均等待时间为：$W&#x3D;\frac{1}{\mu_k-\lambda_q}$<br>其中：$λq$为该窗口的到达率（可估算为该窗口所吸引的顾客比例*总到达率）</p><h4 id="2-1-3-优化目标与约束"><a href="#2-1-3-优化目标与约束" class="headerlink" title="2.1.3 优化目标与约束"></a>2.1.3 优化目标与约束</h4><p>目标函数</p><p><img src="data:image/png;base64,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"></p><p>其中：<br>①$N_{itk}$ ：窗口<em>i</em>在时间段<em>t</em>接待的顾客数量（取决于其吸引概率和是否排满）<br>②$λ_{itk} &#x3D; N_{itk}&#x2F;t$ ：窗口到达率 </p><p>约束条件：<br>①每个时间段开放窗口数$n_t\in[6,10]$<br>②每个窗口只能供应一种菜品：</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAH0AAAA7CAMAAABhX3VmAAAAAXNSR0IArs4c6QAAAKtQTFRFAAAAAAAAAAA6AABmADo6ADpmADqQAGaQAGa2OgAAOgA6OgBmOjoAOjqQOmZmOmaQOma2OpDbZgAAZgA6ZjoAZjo6ZjqQZmaQZma2ZpC2ZpDbZrbbZrb/kDoAkDo6kDpmkGY6kGaQkLZmkLaQkLbbkNv/tmYAtmY6tpBmttv/tv//25A625Bm25CQ27Zm27aQ29u22/+22////7Zm/9uQ/9u2/9vb//+2///bIkEJgAAAAAF0Uk5TAEDm2GYAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAAAZdEVYdFNvZnR3YXJlAE1pY3Jvc29mdCBPZmZpY2V/7TVxAAAC3ElEQVRYR+1Yf3PTMAy1Swt4/BjLVgajgQKrszWhHU1C/P0/GbKdtLbsprmSs4+7+Y9s8xw/6elJlkPI8yCkeEsnd7GIEF/vyWayigUPuNVFRPR6+SWe65xOI6ITsmWLSM431ytSRUMnBYuYcZEof4aNxEBJPePlLpA1IqX0ysISnAZDJ01C0eHSJOHQCXD/Ym15zwOik5zS1xZ6GRLdDX0gzWkYN/RB4SH0IcnGvjmhD+q8DH2ssz1U6I9n8nih386P9KYitRPbjO6/hF4cEOsbs3btvc1RQRMpKu9nh/5pTi8fW0eqy0cTqOvVmsQGIxssM8h6bOBSHkBZ7x2jXrLZvZUhJnpHtpzLD9tLkTsFFk8UK3ir6MmFPw9s+hmfxhbJ3QEuXTdF5xFghs5aQsrJzw89qc8nnhuAhd4kUmlckmqKziPAijmabJKZffzZppz2XQFrE8zYOzoA29xqi6UJbKCa3B93uBvCHSFXyjFviaWjJe5RV8lai3L5s1QsIvUSYmoeFtjJBRy3NJvzOAFBkq68mtuNkQaKCJF6VGjkO0YH6fzQbvWJrmKOT0R8WwNxmwVAwgaQkdACwo0Lfuk7EzTPe13BaiUnmKi/79p5UEP98aAoXy8nt4HMlKKv3sBS/Xi3e5p3Wcb3/XAXNbFkMDe9MxSurQFO6AxqkraqYuqPbqicOD5UxFXDJQvykH67Sfz8+OZ9QTdtUVJrH2W/oe1r2ZFvAZ750ikzNg0gtV9reNSfficLsH5rsNZH2aD/6WrQM0B14EpGZ2sZ+2zUb1siRVwG/YrQiXLvvFuJBlF41iI36I45Z+076CX3bKnYIFUP2v3EIn3QoxEM/VCuDAuCoftcj3qxGSOg/8ceuFkJbLXTrIjsROEd0UCnWSne34RDb5sV1bnAkKdyHg7dalY0pwHRPc1KQHR+pZqVOMxDp4KbFcFfDencxlC+26xAKPDH0zGAfHv8BX3KSievQfQ1AAAAAElFTkSuQmCC"></p><p>③每个队列最多容纳10人，当满员后，分配到其他窗口<br>④特色菜最大供应量为250份：</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK0AAAA8CAMAAAAjS8qXAAAAAXNSR0IArs4c6QAAALpQTFRFAAAAAAAAAAA6AABmADo6ADpmADqQAGaQAGa2OgAAOgA6OgBmOjoAOjpmOjqQOmZmOmaQOma2OpDbZgAAZgA6ZgBmZjoAZjo6ZjpmZmaQZma2ZpCQZpC2ZpDbZrbbZrb/kDoAkDo6kDpmkGY6kLaQkLbbkNvbkNv/tmYAtmY6tpBmttuQttvbttv/tv//25A625Bm25CQ27Zm27aQ27a229u22/+22////7Zm/9uQ/9u2/9vb//+2///budLKvAAAAAF0Uk5TAEDm2GYAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAAAZdEVYdFNvZnR3YXJlAE1pY3Jvc29mdCBPZmZpY2V/7TVxAAAEA0lEQVRoQ+1a2VbbMBCVDKS4LYWSAl0TU0rjdIkDtMV2rf//rc5os2xpsjwEuedkHpKTXB3pejR7wtheYmlAZMlszkePsc6nzl2+5MknD7z7kZ3MqheLgbEV17fsPpl5rJrxlJXD0y3wrJ77bMuDBcvPGWveDky/9c3Ev/DimIlsevc95Rw4D0dyfuizFdk5E3kyYcWguKLWHtIppTxx7RtJREU3b2asotk2F4tfQwpjyzQUwYz+miwh9R5Rx/uj9xr4HzRQ8oDITEsj8Z5LZP0kJXJVc9FIPLasGfNeMdOMVRVDIxHpwo1D5eJKrmsuGolIt+D8uHO8rRBpJB5d30ANFxqJxzZgoDbhekYdkaY5GgyUaA9oJCJtz0AtFxqJRxcNNFxj0Ug8tgM23WWoDdiN6epdtzEn8XDJ+RFSrKAX5Cp1iRvOX/10bnM3pluo00y+Ia1HPFxpHeZ8wuox5qu2lRHZ6LHO3By2G9MtTlNsP7HHXyG/r/iZ0VyOmapAL2rZlvjIZcezoCzoZWAn6nYRuBg4fh4YlvQoiWwCamHY9JFS36RHtz1UMmvZ5nh8M+5kXDCybga2W/SR5aw4WCw3aNSg+SzgmejR1N9v6eFHvz2V9CxbNARkO+o805wccHhImXx5vUEIg4qjAlMoCS2AicCowhfFs0pPUulvii28uiurlNrUR5rxET1pKsFRlMhJz+iRNtugbnHkgoHgGvwNZpxBtuoJQhJA9Ibh9ZYtzKSAcfIV3za3W5E5WsOrMZbgKjMnnSaAlKl+tALf8aZDE1XpXVX64QLvYcVKNyaAdRw7WpO+pb3MCSwyaAQlgDTv7p0oIYdloYmqLJQhNNpLI1e28VY/FTCT9oO6VQHNjWDy26AEEPF5AY5wPwUmcCEQ+lRv501UVVIoEFyzsj1ZbiKQKV6pygnYe7nmaHoxn28AwaAEGsOgIGOTDlDeRFWnR+3hwZW57biNHepvgG19BaDKGjVk47PWPqRlBIVGcLmMTaozCk5U2y03X7nCIxW0ldG6u0nbMgFqxURVL9po5Tq2JZkWaETuiWPzBbzU7/+snqhusXId2V4GdpbTiFoEvgOJYM4hVayeqG6xcg1b0anF0HXM1JlG1ilgdzi6eEdkgSbNmUR2x2bNzr5pGpI0Eo2sX7FUqQpnNBKNLLYMnki2NBKNLMR0ii2NxGMbUq2sQoKqHeCv6fFUtz85rgZ6PZ6Y245ClvtWHCAe4V6LtTy9DDeTJPCU1FXlL19BsNuBRtWULLox6AFPSa9/ljeaMGy9oYUFItL1/jVjSfWHFkNgK+v5kCWo/9METCSiamXl33H9/Jn6KBsDNyYYICJbVfm3Ao2q/i1VNQZWWiAa23+IW4A2cmu8zgAAAABJRU5ErkJggg=="></p><p>⑤所有学生必须被接待：</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKkAAAA8CAMAAAAqoGrtAAAAAXNSR0IArs4c6QAAAKhQTFRFAAAAAAAAAAA6AABmADo6ADpmADqQAGaQAGa2OgAAOgA6OgBmOjoAOjpmOjqQOmZmOmaQOma2OpDbZgAAZgA6ZgBmZjoAZjo6ZjpmZma2ZpCQZpC2ZpDbZrbbZrb/kDoAkDo6kGY6kLbbkNvbkNv/tmYAtmY6ttuQttvbttv/tv//25A625Bm25CQ27Zm27aQ27a229u22////7Zm/9uQ/9u2//+2///bjKSCAgAAAAF0Uk5TAEDm2GYAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAAAZdEVYdFNvZnR3YXJlAE1pY3Jvc29mdCBPZmZpY2V/7TVxAAAENUlEQVRoQ+1ai1YaMRBNqFK31Wqlal+4YllaWZSWfeT//6wzk32EzSyQlHDsOczxIHIzmbvJZHITFOJohx4BFQ+mMzlcHTrupniLczn4bjV4/hVfTPP3c96T9wn8VOrhUbwMplaUcnQvsp4x7fMJTBW6z9/ZTLM3c5FcC1F+5seV8wnOtJiM7RjpmVDx/fPPSErgaxnrE5ppIk9spiq+FioZjEXK8RSsT2ii0P8yuu+Loh7sxKC2G3wCMS4/TUXez7S8mf+2StUWn0BMxSLiqlQdrYwHzHhv9gnF9NjvcQRe8QhkkjHaPX2QkA+q4u7moxKtnXyQkExFOZIdYVKOtCLxQYJShVkGFWJaUmknHyQo1VTKs7UAjcrzQUJStROyjuaDhGTKJGSziVpJvB0JShUSskfW+yBBqVoJ2UTzQUJSxYTktakPEpLpK03VBSfffRKS9ak+7M8absSXd8RJvZxLeYpvczi3Sb0lqYmUH54ML5+EZH1SHaDePnZIheK22nuSwaMo4C4EmdbJqOLhqojNvcknIVmf9DLC0yEevXez/Oop1UwS3IFSXDEt0wyJZ2urCLb5zq5q1M7dERWPYRQEnrF2t4opOSQYq2VKf5ajtV0UMmx9V20iuSBwNkxhGHpviFj6LdNicoU52TDFyUemwzW/GXv5gE0cEBANOUx/1vPQOGiNIm5EXM0U5lVeoZDLo4uI1pZmCq8m0zzq690FoUuX4Wr3NEUKxuwvI5xu9TDWa4tjqj/jzAWBqyEIPPiBvwzLNt9smnmaNTOLc1PPvjmICXPTp2O5ILSS8ujrDS7mFJ9d54ExxhtmH1siP220jqoVZVQSKg58ursgpG2hejXzgzdb+EnvRVI7+7opVSR6MOJMvMwq1T5Jl60bogt+ijOI99m4TeNBDYYa3vWyxWpRORSUhDiNut7jWclMv/rsZA+qG1LtWrrIUKXS5Sr/sPpz941fB2qCW+cJXIgX+O4jtiru4COqVwJ2MF0PtFE2sOaDVB1RhuqjDj7BXr4s2FOSdh6Vkk0vpeQaL7f/3drC0O3LB6n7wLvsObwUX1bwbQH8LE1F5MW6s6saffggjTusKLjknsnTOSXrjPlqxpGuWtNUmP615PJBHIM7NdclwjASWmg+iFNot8Z2KtYEfRC32E6tbfWRk0bAJOgqlu2IU2i3xijbLSOmPohbbLfWrVww+BJTH8QttltrbkhJXrBDugVxC31s/X+OwBYFH+yhOoczNWuKE2n2xgzAOiUZWDCesHTW7hAWl7f8wc8ALAXf67RP2lqU0ysYCmA4XZK1mr0D1Aqec9ontW5f1h1CzdS6XWgBW8E3WECq1n+ZNEG7twsNwCj4QzCl1cFOJP3/CZMWtYI/8OxrUW4u8eSt/pM0OwcwCl7VTgEnX4vy1mBmq+8ntWZvrAVsBd9iwZj+BRTNhvIeefnYAAAAAElFTkSuQmCC"></p><h3 id="2-2-求解"><a href="#2-2-求解" class="headerlink" title="2.2 求解"></a>2.2 求解</h3><p>总体思路：<br>①高峰时段尽量最大化窗口数量<br>②低峰时段尽量增加窗口数量，避免过长排队现象，不给高峰时段预留压力或为高峰时段产生的排队现象托底<br>③优先分配热门菜品窗口<br>④控制每类窗口数量避免较大的排队现象<br>⑤优化特色菜分布，控制在250份以内</p><p>分时间段优化</p><p><strong>时间段一：11:30-12:00（λ₁&#x3D;10人&#x2F;分钟）</strong><br>总到达人数：300人<br>设定开放窗口数：6（最小值）<br>初步分配：2快餐+2面食+2特色菜<br><strong>计算每类窗口吞吐能力</strong><br>快餐窗口：1&#x2F;0.5&#x3D;2人&#x2F;分钟→2窗口共4人&#x2F;分钟<br>面食窗口：1&#x2F;0.8≈1.25人&#x2F;分钟→2窗口共2.5人&#x2F;分钟<br>特色菜窗口：1人&#x2F;分钟→2窗口共2人&#x2F;分钟<br>总服务能力&#x3D;8.5人&#x2F;分钟，稍低于λ₁&#x3D;10，不稳定<br><strong>调整</strong>：增加2快餐窗口（4快餐、2面食、2特色菜）→总服务能力&#x3D;12.5人&#x2F;分钟≈不会产生过长的排队现象。<br><strong>预计特色菜份数</strong>：2窗口×30分钟×1人&#x2F;分钟&#x3D;60份</p><p><strong>时间段二：12:00-13:00（λ₂&#x3D;15人&#x2F;分钟）</strong><br>总到达人数：900人<br>高峰，需最大化窗口数→设定窗口数&#x3D;10<br>初步分配：4快餐+3面食+3特色菜<br><strong>计算每类窗口吞吐能力</strong><br>快餐窗口：4×2&#x3D;8人&#x2F;分钟<br>面食窗口：3×1.25&#x3D;3.75人&#x2F;分钟<br>特色菜窗口：3×1&#x3D;3人&#x2F;分钟<br>总服务能力&#x3D;14.75人&#x2F;分钟&lt;λ₂&#x3D;15→队列会产生堆积<br><strong>调整</strong>：将1面食窗口改为快餐窗口（5快餐、2面食、3特色菜）→总服务能力：15.5人&#x2F;分钟≈时间段内可能会有排队积累，但基本不会产生溢出现象。<br><strong>预计特色菜份数</strong>：3窗口×60分钟&#x3D;180份<br><strong>累计</strong>：60（上个时间段）+180&#x3D;240份→接近限制</p><p><strong>时间段三：13:00-13:30（λ₃&#x3D;5人&#x2F;分钟）</strong><br>总到达人数：150人<br>设定窗口数：6（最小值）<br>由于特色菜接近售罄（只剩10份），取消特色菜窗口<br>分配：3快餐+3面食<br><strong>计算每类窗口吞吐能力</strong><br>快餐窗口：3×2&#x3D;6人&#x2F;分钟<br>面食窗口：3×1.25&#x3D;3.75人&#x2F;分钟<br>总服务能力&#x3D;9.75人&#x2F;分钟&gt;λ₃→排队现象不显著，无队列溢出现象</p><h3 id="2-3-最终结果"><a href="#2-3-最终结果" class="headerlink" title="2.3 最终结果"></a>2.3 最终结果</h3><table><thead><tr><th>时间段</th><th>窗口总数</th><th>快餐窗口</th><th>面食窗口</th><th>特色菜窗口</th></tr></thead><tbody><tr><td>11:30-12:00</td><td>8</td><td>4</td><td>2</td><td>2</td></tr><tr><td>12:00-13:00</td><td>10</td><td>5</td><td>2</td><td>3</td></tr><tr><td>13:00-13:30</td><td>6</td><td>3</td><td>3</td><td>0</td></tr></tbody></table><p>①时间段一：11:30-12:00（300人）</p><table><thead><tr><th>类别</th><th>窗口数</th><th>热门度h</th><th>到达人数</th><th>服务率μ</th><th>到达率λ</th><th>满意度</th></tr></thead><tbody><tr><td>快餐</td><td>4</td><td>0.2</td><td>190</td><td>2</td><td>1.58</td><td>0.084</td></tr><tr><td>面食</td><td>2</td><td>0.3</td><td>60</td><td>1.25</td><td>1</td><td>0.075</td></tr><tr><td>特色菜</td><td>2</td><td>0.5</td><td>50</td><td>1</td><td>0.83</td><td>0.085</td></tr></tbody></table><p>时段一总满意度&#x3D;190*0.084+60*0.075+50*0.085&#x3D;24.71</p><p>②时间段二：12:00-13:00（900人）</p><table><thead><tr><th>类别</th><th>窗口数</th><th>热门度h</th><th>到达人数</th><th>服务率μ</th><th>到达率λ</th><th>满意度</th></tr></thead><tbody><tr><td>快餐</td><td>5</td><td>0.2</td><td>590</td><td>2</td><td>1.97</td><td>0.060</td></tr><tr><td>面食</td><td>2</td><td>0.3</td><td>140</td><td>1.25</td><td>1.17</td><td>0.024</td></tr><tr><td>特色菜</td><td>3</td><td>0.5</td><td>170</td><td>1</td><td>0.94</td><td>0.030</td></tr></tbody></table><p>时段二总满意度&#x3D;590*0.060+140*0.024+170*0.030&#x3D;43.86</p><p>③时间段三：13:00-13:30（150人）</p><table><thead><tr><th>类别</th><th>窗口数</th><th>热门度h</th><th>到达人数</th><th>服务率μ</th><th>到达率λ</th><th>满意度</th></tr></thead><tbody><tr><td>快餐</td><td>3</td><td>0.2</td><td>80</td><td>2</td><td>0.89</td><td>0.222</td></tr><tr><td>面食</td><td>3</td><td>0.3</td><td>70</td><td>1.25</td><td>0.78</td><td>0.141</td></tr></tbody></table><p>时段三总满意度&#x3D;80*0.222+70*0.141&#x3D;27.63</p><p>总满意度&#x3D;24.71+43.86+27.63&#x3D;96.2</p><h2 id="3-仿真情况"><a href="#3-仿真情况" class="headerlink" title="3 仿真情况"></a>3 仿真情况</h2><p>尽量按照现实情况和初始参数构建一个学生在食堂排队的模型，并且把理论得到的结果(窗口开放情况)代入进去，看最终得到的满意度。</p><h3 id="3-1-初始参数"><a href="#3-1-初始参数" class="headerlink" title="3.1 初始参数"></a>3.1 初始参数</h3><p>人流量：</p><table><thead><tr><th>时间段</th><th>平均到达率（人&#x2F;分钟）</th></tr></thead><tbody><tr><td>11：30-12：00</td><td>10</td></tr><tr><td>12：00-13：00</td><td>15</td></tr><tr><td>13：00-13：30</td><td>5</td></tr></tbody></table><p>窗口数量：最少开6个，最多开10个</p><p>每个窗口可以卖的菜品有：</p><table><thead><tr><th>菜品</th><th>热门度</th><th>制作时间（分钟&#x2F;人）</th></tr></thead><tbody><tr><td>快餐</td><td>0.2</td><td>0.5</td></tr><tr><td>面食</td><td>0.3</td><td>0.8</td></tr><tr><td>特色菜</td><td>0.5</td><td>1</td></tr></tbody></table><p>约束：每个窗口排队数量最多为10人，后面再来的学生会自动选择其他窗口，特色菜总共限量250份，如果卖完供应特色菜的窗口在本时间段将不可用，在下个窗口选择更新菜品的时候可以重新启用。</p><p>目标：提高窗口利用率，使总满意度达到最大，不产生队列溢出（新来的学生无队可排）。<br>$$<br>单个学生的满意度&#x3D;\frac{菜品热门度}{等待时间}<br>$$</p><h3 id="3-2-模拟规则"><a href="#3-2-模拟规则" class="headerlink" title="3.2 模拟规则"></a>3.2 模拟规则</h3><h4 id="3-2-1-学生到达餐厅"><a href="#3-2-1-学生到达餐厅" class="headerlink" title="3.2.1 学生到达餐厅"></a>3.2.1 学生到达餐厅</h4><p>按照泊松过程随机生成每分钟到达的学生数。 </p><p>为符合真实情况，学生并不是在每一分钟的开始同时刷新出来的，在每一分钟内，学生将在此分钟的60s内<strong>随机某一秒</strong>上刷新，总数为泊松过程随机生成的对应分钟的学生数。</p><h4 id="3-2-2-学生选择窗口"><a href="#3-2-2-学生选择窗口" class="headerlink" title="3.2.2 学生选择窗口"></a>3.2.2 学生选择窗口</h4><p>学生每刷新在餐厅，会在同秒确定排哪个窗口，选择过程为：</p><p>按照三者喜好度的概率随机抽取一种菜品，然后选择此菜品对应供应的窗口：</p><ul><li>按照人的常识，优先选择排队人数较少的窗口；</li><li>如果窗口此时排队数为10人，则不能选该窗口；</li><li>如果所有此菜品的窗口都不可用，或者没有此菜品供应的窗口，那么就在另外的两种菜品中按照喜 好度的概率再随机抽取一个<ul><li>同上进行同样的选择过程；</li><li>如果此菜品所有窗口都不可用，或者没有此菜品供应的窗口，那么只能选择最后一个菜品；<ul><li>同上进行同样的选择过程；</li><li>如果这个菜品仍然不可用，或者没有此菜品供应的窗口，就说明出现了队列溢出，此学生 会愤怒离开食堂，此学生对应的满 意度为负的他所选菜品对应的热门度</li></ul></li></ul></li></ul><p>以上的判断过程均在学生到来的同一秒内完成。</p><h4 id="3-2-3-窗口更换菜品"><a href="#3-2-3-窗口更换菜品" class="headerlink" title="3.2.3 窗口更换菜品"></a>3.2.3 窗口更换菜品</h4><p>窗口更换菜品，在时间段交界处（12：00与13：00）分钟的末尾开始计时，窗口如果此时正在制作菜 品，那么先将现在正在制作的菜品制作‘完成后再更换菜品；如果没有制作菜品或者恰好制作完，那么直 接更改菜品；更改菜品后此窗口的学生队列不管其意愿将继承。如果此窗口关闭了，那么关闭时刻仍然 在此窗口排队的学生在此时刻将进行一次重新选择。</p><p> 所有的特色菜窗口共同消耗一个库存250份，如果库存用完，那么提供特色菜的窗口将全部关闭，此时仍 然在排队学生将在同秒内重新选择；此窗口在下一次窗口更改时才会更换菜品。</p><h4 id="3-2-4-窗口制作菜品"><a href="#3-2-4-窗口制作菜品" class="headerlink" title="3.2.4 窗口制作菜品"></a>3.2.4 窗口制作菜品</h4><p>只有这个窗口有人在排队时，此窗口才开始制作对应的菜品，并且从开始做的时刻，后备库存就减一； 做完的时刻正在等待的学生立即离开，此窗口排队人数立刻减一（在这一秒内如果同时有新学生选择窗 口事件和学生取餐离开事件，先将排队人数-1，再执行新学生选择），同秒窗口开始做下一份，此学生 的等待时间为从开始排队的时间到这一秒，满意度&#x3D;菜品的喜爱度&#x2F;等待时间。</p><h4 id="3-2-5-结束"><a href="#3-2-5-结束" class="headerlink" title="3.2.5 结束"></a>3.2.5 结束</h4><p>待所有学生都取完餐后餐厅关门，而非是餐厅营业时间到了，计算总的满意度。</p><h4 id="3-2-6-基本数据结构"><a href="#3-2-6-基本数据结构" class="headerlink" title="3.2.6 基本数据结构"></a>3.2.6 基本数据结构</h4><p>对每个学生定义一个类，包括其是否愤怒离去，到达的时间，离开的时间，选择的菜品 </p><p>对每个窗口定义一个类，包括是否在开，是否在做菜，正在做的菜剩下的时间，窗口编号，提供的菜品 名称，更改菜品的flag，正在排队的学生的队列（一个元素为student类的列表）</p><h3 id="3-3-代码实现"><a href="#3-3-代码实现" class="headerlink" title="3.3 代码实现"></a>3.3 代码实现</h3><p>此模拟程序<strong>按秒遍历</strong>，相当于<strong>按照给定的窗口分布将整个时间段的完整过程模拟了一遍，并最终求出总的满意度</strong>。可以输出<strong>每秒上来了多少个学生，分别选择了多少个窗口</strong>。而且还可以<strong>动态输出每秒每个窗口的排队人数的柱状图，和累积到这一秒的总满意度的折线图，最后输出的c是总的满意度</strong>（因为随机性每次重新跑值都会不一样），满意度的求法多加了一条如果学生无队可排，学生就会愤怒离去，并且 他的满意度变为负的他所选菜品对应的热门度</p><h4 id="3-3-1-人数模拟"><a href="#3-3-1-人数模拟" class="headerlink" title="3.3.1 人数模拟"></a>3.3.1 人数模拟</h4><p>首先由泊松分布随机生成每分钟到达食堂的人数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">time_ranges = [<br>    (<span class="hljs-number">0</span>, <span class="hljs-number">30</span>, <span class="hljs-number">10</span>),    <span class="hljs-comment"># 11:30-12:00</span><br>    (<span class="hljs-number">30</span>, <span class="hljs-number">90</span>, <span class="hljs-number">15</span>),   <span class="hljs-comment"># 12:00-13:00</span><br>    (<span class="hljs-number">90</span>, <span class="hljs-number">120</span>, <span class="hljs-number">5</span>)    <span class="hljs-comment"># 13:00-13:30</span><br>]<br>np.random.seed(<span class="hljs-number">42</span>)<br>arrivals = []<br>time_points = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">121</span>))  <span class="hljs-comment"># 0-120分钟</span><br><br><span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> time_points:<br>    <span class="hljs-keyword">for</span> start, end, rate <span class="hljs-keyword">in</span> time_ranges:<br>        <span class="hljs-keyword">if</span> start &lt;= t &lt; end:<br>            arrivals.append(np.random.poisson(rate))<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">else</span>:<br>        arrivals.append(<span class="hljs-number">0</span>)  <span class="hljs-comment"># 不在任何时间段内的情况</span><br></code></pre></td></tr></table></figure><p><img src="/img/yunchou/ScreenShot_2025-12-04_120323_082.png"></p><p><img src="/img/yunchou/ScreenShot_2025-12-04_120949_031.png"></p><p>然后将每分钟内到达的总人数随机分配到这分钟内的若干秒上，最后补了一分钟的0，是为了保证每个学生都能完整的取到餐，如果只遍历到7200s，那么最后一分钟来排队的学生或者排长队的学生会取不到餐。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> OrderedDict<br><span class="hljs-keyword">import</span> random<br>total_seconds=<span class="hljs-number">120</span>*<span class="hljs-number">60</span>  <span class="hljs-comment"># 7200秒</span><br>second_dict=OrderedDict([(second,<span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> second <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(total_seconds)])<br><br><span class="hljs-comment"># 随机分配人数到各秒</span><br><span class="hljs-keyword">for</span> minute <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">120</span>):<br>    minute_people=arrivals[minute]<br>    start_second=minute * <span class="hljs-number">60</span><br>    <br>    <span class="hljs-comment"># 为每个人随机分配秒数（0-59，对应start_second到start_second+59）</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(minute_people):<br>        random_second=random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">59</span>)<br>        total_second=start_second+random_second<br>        second_dict[total_second]+=<span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7200</span>,<span class="hljs-number">7260</span>):<span class="hljs-comment">#为了保证全部学生都能取到菜，将食堂开放时间延长一分钟</span><br>    second_dict[i]=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>然后定义<strong>窗口</strong>和<strong>学生</strong>两个class：</p><ul><li>对窗口定义了其编号，是否开放，提供菜品，队伍列表，是否在做菜，做菜剩下的时间，改菜品的 标志。</li><li>对学生定义了其到达时间，离开时间，选择的菜品，选择的窗口，是否愤怒离去</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,OpenOrClose,dishname,sign</span>):<br>        <span class="hljs-variable language_">self</span>.sign=sign<span class="hljs-comment">#窗口编号，从一开始</span><br>        <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">open</span>=OpenOrClose<br>        <span class="hljs-variable language_">self</span>.dish=dishname<br>        <span class="hljs-variable language_">self</span>.queue_num=<span class="hljs-number">0</span><br>        <span class="hljs-variable language_">self</span>.queue=[]<br>        <span class="hljs-variable language_">self</span>.iscooking=<span class="hljs-literal">False</span><br>        <span class="hljs-variable language_">self</span>.cooktimeleft=<span class="hljs-number">0</span><br>        <span class="hljs-variable language_">self</span>.change_flag=<span class="hljs-number">0</span><br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">close</span>(<span class="hljs-params">self</span>):<span class="hljs-comment">#关门函数</span><br>        <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">open</span>=<span class="hljs-literal">False</span><br>        <span class="hljs-variable language_">self</span>.iscooking=<span class="hljs-literal">False</span><br>        <span class="hljs-variable language_">self</span>.queue_num=<span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">checkiscooking</span>(<span class="hljs-params">self</span>):<span class="hljs-comment">#检查是否在做饭</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.queue_num==<span class="hljs-number">0</span>:<br>            <span class="hljs-variable language_">self</span>.iscooking=<span class="hljs-literal">False</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">change</span>(<span class="hljs-params">self,openstatus,dishname</span>):<span class="hljs-comment">#更换窗口</span><br>        <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">open</span>=openstatus<br>        <span class="hljs-variable language_">self</span>.dish=dishname<br>        <span class="hljs-variable language_">self</span>.change_flag=<span class="hljs-number">0</span><br> <br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,arrive_time</span>):<br>        <span class="hljs-variable language_">self</span>.arrive_time=arrive_time<br>        <span class="hljs-variable language_">self</span>.over_time=<span class="hljs-number">0</span><br>        <span class="hljs-variable language_">self</span>.chosen_times=<span class="hljs-number">0</span><br>        <span class="hljs-variable language_">self</span>.chosen_dish=<span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>.chosen_window=<span class="hljs-number">0</span><br>        <span class="hljs-variable language_">self</span>.is_angry=<span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>然后定义一些初始参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">dishes = &#123;<br>    <span class="hljs-string">&quot;快餐&quot;</span>: (<span class="hljs-number">0.2</span>, <span class="hljs-number">30</span>),<br>    <span class="hljs-string">&quot;面食&quot;</span>: (<span class="hljs-number">0.3</span>, <span class="hljs-number">48</span>),<br>    <span class="hljs-string">&quot;特色菜&quot;</span>: (<span class="hljs-number">0.5</span>, <span class="hljs-number">60</span>)<br>&#125;<br>max_windows=<span class="hljs-number">10</span><span class="hljs-comment">#最大窗口数</span><br>min_windows=<span class="hljs-number">6</span><span class="hljs-comment">#最小窗口数</span><br>max_queue_length=<span class="hljs-number">10</span><span class="hljs-comment">#队伍最长存在的人数</span><br>special_dish_store=<span class="hljs-number">250</span><span class="hljs-comment">#特色菜的限制</span><br></code></pre></td></tr></table></figure><p>定义学生选择窗口的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs python">options=[<span class="hljs-string">&quot;快餐&quot;</span>,<span class="hljs-string">&quot;面食&quot;</span>,<span class="hljs-string">&quot;特色菜&quot;</span>]<br>weights=[<span class="hljs-number">0.2</span>,<span class="hljs-number">0.3</span>,<span class="hljs-number">0.5</span>]<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">choose_window</span>(<span class="hljs-params">student,windows_list,students_list</span>):<br>    choice=random.choices(options,weights=weights,k=<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]<span class="hljs-comment">#按照权重随机选择一个</span><br>    student.chosen_dish=choice<br>    window_signs=[]<span class="hljs-comment">#提供这个菜品的窗口</span><br>    window_queue_num=[]<span class="hljs-comment">#对应排队人数</span><br>    change_flag=<span class="hljs-number">0</span><span class="hljs-comment">#是否改变选择的标志</span><br>    <span class="hljs-keyword">for</span> window <span class="hljs-keyword">in</span> windows_list:<br>        <span class="hljs-keyword">if</span> window.<span class="hljs-built_in">open</span>==<span class="hljs-literal">False</span>:<span class="hljs-comment">#如果没开门不管他</span><br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">if</span> window.dish==choice:<span class="hljs-comment">#如果提供对应菜品</span><br>            window_signs.append(window.sign)<span class="hljs-comment">#记录对应的窗口号与队列人数</span><br>            window_queue_num.append(<span class="hljs-built_in">len</span>(window.queue))<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(window_signs)==<span class="hljs-number">0</span>:<br>        change_flag=<span class="hljs-number">1</span><br>        student.chosen_times+=<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(window_signs)!=<span class="hljs-number">0</span>:<span class="hljs-comment">#如果存在卖他的窗口</span><br>        queue_num_min=<span class="hljs-built_in">min</span>(window_queue_num)<span class="hljs-comment">#找到排队人数最少的窗口号</span><br>        sign_min=window_signs[window_queue_num.index(queue_num_min)]<br>        <span class="hljs-keyword">if</span> queue_num_min&lt;<span class="hljs-number">10</span>:<span class="hljs-comment">#如果最小值小于10，就排这一条</span><br>            student.chosen_window=sign_min<br>            windows_list[sign_min-<span class="hljs-number">1</span>].queue.append(student)<br>            windows_list[sign_min-<span class="hljs-number">1</span>].queue_num+=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> queue_num_min==<span class="hljs-number">10</span>:<span class="hljs-comment">#如果最小值为10，说明全部排满了</span><br>            change_flag=<span class="hljs-number">1</span><br>            student.chosen_times+=<span class="hljs-number">1</span><br>            <br>    <span class="hljs-keyword">if</span> change_flag==<span class="hljs-number">1</span>:<span class="hljs-comment">#如果确实发生了第二次选择</span><br>        change_flag=<span class="hljs-number">0</span><br>        options_tool=[<span class="hljs-string">&quot;快餐&quot;</span>,<span class="hljs-string">&quot;面食&quot;</span>,<span class="hljs-string">&quot;特色菜&quot;</span>]<br>        weights_tool=[<span class="hljs-number">0.2</span>,<span class="hljs-number">0.3</span>,<span class="hljs-number">0.5</span>]<br>        index_tool=options_tool.index(choice)<span class="hljs-comment">#在剩下的两个菜中选</span><br>        <span class="hljs-keyword">del</span> options_tool[index_tool]<br>        <span class="hljs-keyword">del</span> weights_tool[index_tool]<br>        choice=random.choices(options_tool,weights=weights_tool,k=<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]<br>        student.chosen_dish=choice<br>        window_signs=[]<span class="hljs-comment">#提供这个菜品的窗口</span><br>        window_queue_num=[]<span class="hljs-comment">#对应排队人数</span><br>        <span class="hljs-keyword">for</span> window <span class="hljs-keyword">in</span> windows_list:<br>            <span class="hljs-keyword">if</span> window.<span class="hljs-built_in">open</span>==<span class="hljs-literal">False</span>:<span class="hljs-comment">#如果没开门不管他</span><br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">if</span> window.dish==choice:<span class="hljs-comment">#如果提供对应菜品</span><br>                window_signs.append(window.sign)<span class="hljs-comment">#记录对应的窗口号与队列人数</span><br>                window_queue_num.append(<span class="hljs-built_in">len</span>(window.queue))<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(window_signs)==<span class="hljs-number">0</span>:<br>            change_flag=<span class="hljs-number">2</span><br>            student.chosen_times+=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(window_signs)!=<span class="hljs-number">0</span>:<span class="hljs-comment">#如果存在卖他的窗口</span><br>            queue_num_min=<span class="hljs-built_in">min</span>(window_queue_num)<span class="hljs-comment">#找到排队人数最少的窗口号</span><br>            sign_min=window_signs[window_queue_num.index(queue_num_min)]<br>            <span class="hljs-keyword">if</span> queue_num_min&lt;<span class="hljs-number">10</span>:<span class="hljs-comment">#如果最小值小于10，就排这一条</span><br>                student.chosen_window=sign_min<br>                windows_list[sign_min-<span class="hljs-number">1</span>].queue.append(student)<br>                windows_list[sign_min-<span class="hljs-number">1</span>].queue_num+=<span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> queue_num_min==<span class="hljs-number">10</span>:<span class="hljs-comment">#如果最小值为10，说明全部排满了</span><br>                change_flag=<span class="hljs-number">2</span><br>                student.chosen_times+=<span class="hljs-number">1</span><br>                <br>    <span class="hljs-keyword">if</span> change_flag==<span class="hljs-number">2</span>:<span class="hljs-comment">#如果发生了第三次选择</span><br>        change_flag=<span class="hljs-number">0</span><br>        index_tool=options_tool.index(choice)<span class="hljs-comment">#在剩下的两个菜中选</span><br>        <span class="hljs-keyword">del</span> options_tool[index_tool]<br>        <span class="hljs-keyword">del</span> weights_tool[index_tool]<br>        choice=options_tool[<span class="hljs-number">0</span>]<br>        student.chosen_dish=choice<br>        window_signs=[]<span class="hljs-comment">#提供这个菜品的窗口</span><br>        window_queue_num=[]<span class="hljs-comment">#对应排队人数</span><br>        <span class="hljs-keyword">for</span> window <span class="hljs-keyword">in</span> windows_list:<br>            <span class="hljs-keyword">if</span> window.<span class="hljs-built_in">open</span>==<span class="hljs-literal">False</span>:<span class="hljs-comment">#如果没开门不管他</span><br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">if</span> window.dish==choice:<span class="hljs-comment">#如果提供对应菜品</span><br>                window_signs.append(window.sign)<span class="hljs-comment">#记录对应的窗口号与队列人数</span><br>                window_queue_num.append(<span class="hljs-built_in">len</span>(window.queue))<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(window_signs)==<span class="hljs-number">0</span>:<br>            change_flag=<span class="hljs-number">3</span><br>            student.chosen_times+=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(window_signs)!=<span class="hljs-number">0</span>:<span class="hljs-comment">#如果存在卖他的窗口</span><br>            queue_num_min=<span class="hljs-built_in">min</span>(window_queue_num)<span class="hljs-comment">#找到排队人数最少的窗口号</span><br>            sign_min=window_signs[window_queue_num.index(queue_num_min)]<br>            <span class="hljs-keyword">if</span> queue_num_min&lt;<span class="hljs-number">10</span>:<span class="hljs-comment">#如果最小值小于10，就排这一条</span><br>                student.chosen_window=sign_min<br>                windows_list[sign_min-<span class="hljs-number">1</span>].queue.append(student)<br>                windows_list[sign_min-<span class="hljs-number">1</span>].queue_num+=<span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> queue_num_min==<span class="hljs-number">10</span>:<span class="hljs-comment">#如果最小值为10，说明全部排满了</span><br>                change_flag=<span class="hljs-number">3</span><br>                student.chosen_times+=<span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">if</span> change_flag==<span class="hljs-number">3</span>:<span class="hljs-comment">#如果第三次仍然没有选择</span><br>        student.is_angry=<span class="hljs-literal">True</span><br>        students_list.append(student)<br></code></pre></td></tr></table></figure><p>目前所有准备工作都完成了，可以开始进入主循环了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs python">windows_set=[<br>    [(<span class="hljs-literal">True</span>,<span class="hljs-string">&quot;快餐&quot;</span>),(<span class="hljs-literal">True</span>,<span class="hljs-string">&quot;快餐&quot;</span>),(<span class="hljs-literal">True</span>,<span class="hljs-string">&quot;快餐&quot;</span>),(<span class="hljs-literal">True</span>,<span class="hljs-string">&quot;快餐&quot;</span>),(<span class="hljs-literal">True</span>,<span class="hljs-string">&quot;面食&quot;</span>),(<span class="hljs-literal">True</span>,<span class="hljs-string">&quot;面食&quot;</span>),(<span class="hljs-literal">True</span>,<span class="hljs-string">&quot;特色菜&quot;</span>),(<span class="hljs-literal">True</span>,<span class="hljs-string">&quot;特色菜&quot;</span>),(<span class="hljs-literal">False</span>,<span class="hljs-string">&quot;&quot;</span>),(<span class="hljs-literal">False</span>,<span class="hljs-string">&quot;&quot;</span>)],<br>    [(<span class="hljs-literal">True</span>,<span class="hljs-string">&quot;快餐&quot;</span>),(<span class="hljs-literal">True</span>,<span class="hljs-string">&quot;快餐&quot;</span>),(<span class="hljs-literal">True</span>,<span class="hljs-string">&quot;快餐&quot;</span>),(<span class="hljs-literal">True</span>,<span class="hljs-string">&quot;快餐&quot;</span>),(<span class="hljs-literal">True</span>,<span class="hljs-string">&quot;面食&quot;</span>),(<span class="hljs-literal">True</span>,<span class="hljs-string">&quot;面食&quot;</span>),(<span class="hljs-literal">True</span>,<span class="hljs-string">&quot;特色菜&quot;</span>),(<span class="hljs-literal">True</span>,<span class="hljs-string">&quot;特色菜&quot;</span>),(<span class="hljs-literal">True</span>,<span class="hljs-string">&quot;快餐&quot;</span>),(<span class="hljs-literal">True</span>,<span class="hljs-string">&quot;特色菜&quot;</span>)],<br>    [(<span class="hljs-literal">True</span>,<span class="hljs-string">&quot;快餐&quot;</span>),(<span class="hljs-literal">True</span>,<span class="hljs-string">&quot;快餐&quot;</span>),(<span class="hljs-literal">True</span>,<span class="hljs-string">&quot;快餐&quot;</span>),(<span class="hljs-literal">False</span>,<span class="hljs-string">&quot;&quot;</span>),(<span class="hljs-literal">True</span>,<span class="hljs-string">&quot;面食&quot;</span>),(<span class="hljs-literal">True</span>,<span class="hljs-string">&quot;面食&quot;</span>),(<span class="hljs-literal">True</span>,<span class="hljs-string">&quot;面食&quot;</span>),(<span class="hljs-literal">False</span>,<span class="hljs-string">&quot;&quot;</span>),(<span class="hljs-literal">False</span>,<span class="hljs-string">&quot;&quot;</span>),(<span class="hljs-literal">False</span>,<span class="hljs-string">&quot;&quot;</span>)]]<span class="hljs-comment">#代入理论值结果</span><br>windows_list=[]<span class="hljs-comment">#初始化</span><br>students_list=[]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    window=Window(windows_set[<span class="hljs-number">0</span>][i][<span class="hljs-number">0</span>],windows_set[<span class="hljs-number">0</span>][i][<span class="hljs-number">1</span>],i+<span class="hljs-number">1</span>)<br>    windows_list.append(window)<br><span class="hljs-built_in">print</span>(windows_list)<br><br><br><span class="hljs-keyword">import</span> matplotlib<br>matplotlib.use(<span class="hljs-string">&#x27;QtAgg&#x27;</span>)<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>%matplotlib qt5<br>x2=[]<br>y2=[]<br>plt.ion()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7260</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;首先更新所有窗口的状态&#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">for</span> window <span class="hljs-keyword">in</span> windows_list:<br>        <span class="hljs-keyword">if</span> i==<span class="hljs-number">1800</span>:<br>            window.change_flag=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> i==<span class="hljs-number">5400</span>:<br>            window.change_flag=<span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> window.iscooking):<span class="hljs-comment">#对于没有在做菜的窗口</span><br>             <span class="hljs-keyword">if</span> window.change_flag!=<span class="hljs-number">0</span>:<span class="hljs-comment">#如果到了改菜品的时候</span><br>                window.change(windows_set[window.change_flag][window.sign-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>],windows_set[window.change_flag][window.sign-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])<span class="hljs-comment">#更改的菜品以及窗口开关</span><br>                <span class="hljs-keyword">if</span> (window.dish==<span class="hljs-string">&quot;特色菜&quot;</span> <span class="hljs-keyword">and</span> special_dish_store==<span class="hljs-number">0</span>):<span class="hljs-comment">#仅针对换菜事件，如果换的是特色菜但是没库存了，关闭窗口</span><br>                    window.<span class="hljs-built_in">open</span>=<span class="hljs-literal">False</span><br>                    window.iscooking=<span class="hljs-literal">False</span><br>                    window.queue_num=<span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> window.iscooking:<span class="hljs-comment">#做菜的窗口,菜的剩余时间-1</span><br>            window.cooktimeleft-=<span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> window.cooktimeleft==<span class="hljs-number">0</span>:<span class="hljs-comment">#如果时间剩余0，即完成了菜，那么队列排队人数-1</span><br>                student_tool=window.queue.pop(<span class="hljs-number">0</span>)<br>                window.queue_num-=<span class="hljs-number">1</span> <br>                student_tool.over_time=i<span class="hljs-comment">#队首的学生记录结束时间</span><br>                student_tool.chosen_dish=window.dish<span class="hljs-comment">#记录最后拿到的菜品是window此时正在卖的菜品</span><br>                students_list.append(student_tool)<span class="hljs-comment">#完成的学生存入另一个列表中用于计算满意度</span><br>                <br>                <span class="hljs-keyword">if</span> window.change_flag!=<span class="hljs-number">0</span>:<span class="hljs-comment">#如果完成后到了改菜品的时候了</span><br>                    window.change(windows_set[window.change_flag][window.sign-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>],windows_set[window.change_flag][window.sign-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])<span class="hljs-comment">#更改的菜品以及窗口开关</span><br>                    <span class="hljs-keyword">if</span> (window.dish==<span class="hljs-string">&quot;特色菜&quot;</span> <span class="hljs-keyword">and</span> special_dish_store==<span class="hljs-number">0</span>):<span class="hljs-comment">#仅针对换菜事件，如果换的是特色菜但是没库存了，关闭窗口</span><br>                        window.<span class="hljs-built_in">open</span>=<span class="hljs-literal">False</span><br>                        window.iscooking=<span class="hljs-literal">False</span><br>                        window.queue_num=<span class="hljs-number">0</span><br>                    <span class="hljs-keyword">if</span> window.<span class="hljs-built_in">open</span>==<span class="hljs-literal">False</span>:<span class="hljs-comment">#如果关窗口了</span><br>                        <span class="hljs-keyword">for</span> student <span class="hljs-keyword">in</span> window.queue:<span class="hljs-comment">#原队列所有人重新选择</span><br>                            choose_window(student,windows_list,students_list)<br>                        window.queue=[]<br>                        <br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(window.queue)==<span class="hljs-number">0</span>:<span class="hljs-comment">#检查走后是否还剩下人</span><br>                    window.iscooking=<span class="hljs-literal">False</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">if</span> window.dish==<span class="hljs-string">&quot;特色菜&quot;</span>:<span class="hljs-comment">#检查窗口是否提供特色菜</span><br>                       <span class="hljs-keyword">if</span> special_dish_store!=<span class="hljs-number">0</span>:<span class="hljs-comment">#如果是而且库存没空</span><br>                           window.cooktimeleft=dishes[window.dish][<span class="hljs-number">1</span>]<span class="hljs-comment">#重置做饭时间</span><br>                           special_dish_store-=<span class="hljs-number">1</span><span class="hljs-comment">#减一份库存</span><br>                           <span class="hljs-keyword">if</span> special_dish_store==<span class="hljs-number">0</span>:<span class="hljs-comment">#如果库存空了</span><br>                                window.<span class="hljs-built_in">open</span>=<span class="hljs-literal">False</span><br>                                window.iscooking=<span class="hljs-literal">False</span><br>                                window.queue_num=<span class="hljs-number">0</span><span class="hljs-comment">#关窗口</span><br>                           <span class="hljs-keyword">for</span> student <span class="hljs-keyword">in</span> window.queue:<br>                               choose_window(student,windows_list,students_list)<br>                           window.queue=[]   <br>                    <span class="hljs-keyword">if</span> window.dish!=<span class="hljs-string">&quot;特色菜&quot;</span>:<span class="hljs-comment">#非特色菜</span><br>                        window.cooktimeleft=dishes[window.dish][<span class="hljs-number">1</span>]<span class="hljs-comment">#重置做饭时间</span><br>    <span class="hljs-string">&#x27;&#x27;&#x27;再更新新学生&#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">if</span> second_dict[i]==<span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;第<span class="hljs-subst">&#123;<span class="hljs-built_in">int</span>(i/<span class="hljs-number">60</span>)&#125;</span>分<span class="hljs-subst">&#123;i%<span class="hljs-number">60</span>&#125;</span>秒，有0个学生&quot;</span>)<br>    <span class="hljs-keyword">if</span> second_dict[i]!=<span class="hljs-number">0</span>:<span class="hljs-comment">#如果有新客人来 </span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;第<span class="hljs-subst">&#123;<span class="hljs-built_in">int</span>(i/<span class="hljs-number">60</span>)&#125;</span>分<span class="hljs-subst">&#123;i%<span class="hljs-number">60</span>&#125;</span>秒，有<span class="hljs-subst">&#123;second_dict[i]&#125;</span>个学生&quot;</span>)<br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(second_dict[i]):<br>            student=Student(i)<br>            choose_window(student,windows_list,students_list)<br>            <span class="hljs-keyword">if</span> student.is_angry:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;    有一位学生感到愤怒！&quot;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;    有一位同学去了<span class="hljs-subst">&#123;student.chosen_window&#125;</span>窗口,选择的菜品是<span class="hljs-subst">&#123;student.chosen_dish&#125;</span>&quot;</span>)<br>    <br>        <br><br>    x1=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]<br>    y1=[]<br>    <span class="hljs-keyword">for</span> window <span class="hljs-keyword">in</span> windows_list:<br>        y1.append(<span class="hljs-built_in">len</span>(window.queue))<br>    <br>    <span class="hljs-keyword">for</span> window <span class="hljs-keyword">in</span> windows_list:<span class="hljs-comment">#针对新上人的窗口</span><br>        <span class="hljs-keyword">if</span> window.<span class="hljs-built_in">open</span>:<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> window.iscooking <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(window.queue)!=<span class="hljs-number">0</span>):<br>                window.iscooking=<span class="hljs-literal">True</span><br>                <span class="hljs-keyword">if</span> window.dish==<span class="hljs-string">&quot;特色菜&quot;</span>:<span class="hljs-comment">#对特色菜窗口</span><br>                    <span class="hljs-keyword">if</span> special_dish_store==<span class="hljs-number">0</span>:<span class="hljs-comment">#如果库存为0关门，队伍重新选窗口</span><br>                        window.<span class="hljs-built_in">open</span>=<span class="hljs-literal">False</span><br>                        window.iscooking=<span class="hljs-literal">False</span><br>                        window.queue_num=<span class="hljs-number">0</span><br>                        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(window.queue)):<br>                            choose_window(window.queue[j],windows_list,students_list)<br>                        window.queue=[]<br>                    <span class="hljs-keyword">if</span> special_dish_store!=<span class="hljs-number">0</span>:<br>                        special_dish_store-=<span class="hljs-number">1</span><br>                        window.cooktimeleft=dishes[window.dish][<span class="hljs-number">1</span>]<span class="hljs-comment">#重置做饭时间</span><br>                <span class="hljs-keyword">else</span>:<br>                    window.cooktimeleft=dishes[window.dish][<span class="hljs-number">1</span>]<span class="hljs-comment">#重置做饭时间</span><br>    c=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> student <span class="hljs-keyword">in</span> students_list:<br>        <span class="hljs-keyword">if</span> student.is_angry:<br>            c-=dishes[student.chosen_dish][<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">else</span>:<br>            c+=dishes[student.chosen_dish][<span class="hljs-number">0</span>]*<span class="hljs-number">60</span>/(student.over_time-student.arrive_time)<br>    x2.append(i)<br>    y2.append(c)<br>    plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br>    plt.clf()  <span class="hljs-comment"># 清除之前画的图</span><br>    plt.plot(x2,y2)  <span class="hljs-comment">#画出当前x列表和y列表中的值的图形</span><br>    plt.pause(<span class="hljs-number">0.001</span>)  <span class="hljs-comment">#暂停一段时间，不然画的太快会卡住显示不出来</span><br></code></pre></td></tr></table></figure><p>(↑这两段纯手搓，我都不知道当时怎么有这么大的耐心)最后输出一下满意度和特色菜库存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">c=<span class="hljs-number">0</span><br>plt.plot(x2,y2)<br><span class="hljs-keyword">for</span> student <span class="hljs-keyword">in</span> students_list:<br>    <span class="hljs-keyword">if</span> student.is_angry:<br>        c-=dishes[student.chosen_dish][<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">else</span>:<br>        c+=dishes[student.chosen_dish][<span class="hljs-number">0</span>]*<span class="hljs-number">60</span>/(student.over_time-student.arrive_time)<br><span class="hljs-built_in">print</span>(c)<br><span class="hljs-built_in">print</span>(special_dish_store)<br></code></pre></td></tr></table></figure><p>最后运行情况如下：(柱状图表示每秒每个窗口排队情况，折线图是满意度累积情况)</p><p><img src="/img/yunchou/lQLPJx23xXGm3SfNAa7NAj6w_a4oXooKD6AIH75qMKGFAA_574_430.png"></p><p><video src="/img/yunchou/QQ2025529-215613.mp4" position="absolute" width="100%" height="100%" controls="controls"></video></p><p><video src="/img/yunchou/QQ2025529-215731.mp4" position="absolute" width="100%" height="100%" controls="controls"></video></p><p>满意度如下：</p><p><img src="/img/yunchou/ScreenShot_2025-12-04_122116_853.png"></p>]]></content>
    
    
    <categories>
      
      <category>python项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GAN对抗生成网络</title>
    <link href="/2025/05/10/GAN%E5%AF%B9%E6%8A%97%E7%94%9F%E6%88%90%E7%BD%91%E7%BB%9C/"/>
    <url>/2025/05/10/GAN%E5%AF%B9%E6%8A%97%E7%94%9F%E6%88%90%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<p>施工中。。。细节可见<a href="https://github.com/DKESTXD/my-university-life">DKESTXD&#x2F;my-university-life</a></p><span id="more"></span>]]></content>
    
    
    <categories>
      
      <category>python项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>如何用刻意的算法绕远路实现一个化学式自动配平器</title>
    <link href="/2025/04/09/%E5%A6%82%E4%BD%95%E7%94%A8%E5%88%BB%E6%84%8F%E7%9A%84%E7%AE%97%E6%B3%95%E7%BB%95%E8%BF%9C%E8%B7%AF%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8C%96%E5%AD%A6%E5%BC%8F%E8%87%AA%E5%8A%A8%E9%85%8D%E5%B9%B3%E5%99%A8/"/>
    <url>/2025/04/09/%E5%A6%82%E4%BD%95%E7%94%A8%E5%88%BB%E6%84%8F%E7%9A%84%E7%AE%97%E6%B3%95%E7%BB%95%E8%BF%9C%E8%B7%AF%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8C%96%E5%AD%A6%E5%BC%8F%E8%87%AA%E5%8A%A8%E9%85%8D%E5%B9%B3%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>施工中。。。细节可见<a href="https://github.com/DKESTXD/my-university-life">DKESTXD&#x2F;my-university-life</a></p><span id="more"></span>]]></content>
    
    
    <categories>
      
      <category>matlab</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数值计算方法学习笔记</title>
    <link href="/2025/04/08/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/04/08/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>施工中。。。细节可见<a href="https://github.com/DKESTXD/my-university-life">DKESTXD&#x2F;my-university-life</a></p><span id="more"></span>]]></content>
    
    
    <categories>
      
      <category>matlab</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/03/29/hello-world/"/>
    <url>/2025/03/29/hello-world/</url>
    
    <content type="html"><![CDATA[<p>写在前面，本博客创建于2025.3.29，捣鼓了一下午搞好的博客，其实没那么难，hexo还是太良心了。前后研究了三个主题敲定了Fluid，审美比较在线。自上大学来，我每学期都把全部的课程内容上传到一个GitHub仓库中，但是这样访问太不方便了，我决定将其中技术性的部分写在博客里，但是缺点是之前课程的很多markdown笔记中附带的图片早已经删除了，只留下了一份pdf，因此不能直观表现在博客中，比如数值计算方法、运筹学等等。再者，有一些很久远的项目细节也记不得了，比如一年前暑假做的微信小程序，因此，部分内容在表现上存在缺陷。</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>latex学习笔记</title>
    <link href="/2025/03/12/latex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/03/12/latex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>施工中。。。细节可见<a href="https://github.com/DKESTXD/my-university-life">DKESTXD&#x2F;my-university-life</a></p><span id="more"></span>]]></content>
    
    
    <categories>
      
      <category>其他工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构学习笔记</title>
    <link href="/2024/10/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/10/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>此处只作为补录，实际在大二就上过了，因为里面所有图片的源链接都是找的一个在线图床，为了防止崩掉放一个pdf链接在这里： <a href="/img/shujujiegou/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.pdf">数据结构.pdf</a> </p><span id="more"></span><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="课程要求"><a href="#课程要求" class="headerlink" title="课程要求"></a>课程要求</h2><img src="https://s2.loli.net/2024/09/09/wVjpahfxnA426CJ.jpg" alt="_20240909165535.png" style="zoom: 67%;" /><h2 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h2><h3 id="1-数据结构基本概念"><a href="#1-数据结构基本概念" class="headerlink" title="1 数据结构基本概念"></a>1 数据结构基本概念</h3><h4 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h4><p>数据：描述客观事物的数字字符以及一切能输入到计算机中，并且能被计算机程序处理的符号的集合</p><p>数据元素：表示一个事务的一组数据，是数据的基本单位，又称结点，在计算机程序中通常作为一个整体进行处理。一个数据元素由若干     个数据项组成</p><p>数据对象：具有相同性质的数据元素组成的集合。</p><p>数据结构：数据元素之间的关系，数据的组织形式</p><h4 id="1-2-研究内容"><a href="#1-2-研究内容" class="headerlink" title="1.2 研究内容"></a>1.2 研究内容</h4><p>逻辑结构：数据元素之间的客观联系</p><p>存储结构：研究具有某种逻辑关系的数据在计算机存储器内的存储方式</p><p>算法：研究如何在数据的各种结构的基础上对数据实施一系列有效的基本操作</p><h5 id="数据结构（逻辑结构）"><a href="#数据结构（逻辑结构）" class="headerlink" title="数据结构（逻辑结构）"></a>数据结构（逻辑结构）</h5><p>计算机处理的数据元素的组织形式及其相互间的关系，记为：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pascal">Data_Structure=(D,R)<br></code></pre></td></tr></table></figure><p>D是数据元素的有限集，R是所有数据元素之间关系的有限集合，有四种基本数据结构</p><p>1，集合结构：数据元素间除了同属于一个集合外，无其他关系</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">SET</span>=(D,R)<br><span class="hljs-attr">D</span>=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br><span class="hljs-attr">R</span>=&#123;&#125;<br></code></pre></td></tr></table></figure><p>2，线性结构</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">LINEARITY</span>=(D,R)<br><span class="hljs-attribute">D</span>=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;<br><span class="hljs-attribute">R</span>=&#123;&lt;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&gt;,&lt;<span class="hljs-number">3</span>.<span class="hljs-number">2</span>&gt;,&lt;<span class="hljs-number">2</span>,<span class="hljs-number">4</span>&gt;&#125;<br></code></pre></td></tr></table></figure><p>数据元素之间的关系1：1</p><p>1→3→2→4</p><p>除首尾，每个数据元素都有一个前趋和后继</p><p>3，树结构</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">TREE</span>=(D,R)<br><span class="hljs-attribute">D</span>=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br><span class="hljs-attribute">R</span>=&#123;&lt;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&gt;,&lt;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&gt;,&lt;<span class="hljs-number">3</span>.<span class="hljs-number">4</span>&gt;,&lt;<span class="hljs-number">3</span>,<span class="hljs-number">5</span>&gt;&#125;<br></code></pre></td></tr></table></figure><p>数据之间的联系1：N</p><p>4，图结构</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">GRAPH</span>=(D,R)<br><span class="hljs-attribute">D</span>=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;<br><span class="hljs-attribute">R</span>=&#123;&lt;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&gt;,&lt;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&gt;,&lt;<span class="hljs-number">4</span>,<span class="hljs-number">1</span>&gt;,&lt;<span class="hljs-number">4</span>,<span class="hljs-number">2</span>&gt;,&lt;<span class="hljs-number">4</span>,<span class="hljs-number">3</span>&gt;&#125;<br></code></pre></td></tr></table></figure><p>数据之间的联系 M：N</p><h5 id="存储结构（物理结构）"><a href="#存储结构（物理结构）" class="headerlink" title="存储结构（物理结构）"></a>存储结构（物理结构）</h5><p>数据在计算机中的表示称为数据的存储结构，有<font color="red">四种基本的存储方法</font></p><p>1，顺序存储结构：用数据元素在存储器中的相对位置来表示数据元素之间的逻辑关系</p><p>2，链式存储结构：在每一个数据元素中增加一个存放地址的指针，用此指针来表示数据元素之间的逻辑关系</p><p>3，索引存储方法：</p><p>4，散列存储方式</p><p>一个逻辑结构可以结合任一种或多种存储结构</p>  <img src="https://s2.loli.net/2024/09/22/f5OAqL6uYaK894o.jpg" alt="_20240922084740.png" style="zoom:50%;" /><h4 id="1-3-算法和算法分析"><a href="#1-3-算法和算法分析" class="headerlink" title="1.3 算法和算法分析"></a>1.3 算法和算法分析</h4><p>算法是用来解决某个问题的指令的集合</p><h5 id="算法性质"><a href="#算法性质" class="headerlink" title="算法性质"></a>算法性质</h5><p>输入性 有0或者多个输入</p><p>输出性 有一个或者多个输出，或者处理结果</p><p>确定性 每步都是确切有意义的</p><p>有穷性 算法应该在执行有穷步后结束，整个指令序列在有限时间内完成</p><p>可行性 算法的每一步都应能够被有效的执行，并得到确定的结果</p><h5 id="算法设计目的"><a href="#算法设计目的" class="headerlink" title="算法设计目的"></a>算法设计目的</h5><p>正确性   可读性   健壮性   高时间效率   高空间效率</p><h5 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h5><p>时间复杂度T(n)     空间复杂度S(n)     其他</p><p><font color="red">时间复杂度</font>：若有一辅助函数O(f(n))，当n趋于无穷大，T(n)&#x2F;f(n)为一不等于0的实数，T(n)&#x3D;O(f(n))，称O(f(n))为时间复杂度，</p><p>​用于描述程序中语句的执行次数</p><p>计算规则：</p><p>加法：<br>$$<br>T_1(n)+T_2(n)&#x3D;O(max(f_1(n),f_2(n)))<br>$$<br>乘法：<br>$$<br>T_1(n) \times T_2(n)&#x3D;O(max(f_1(n) \times f_2(n)))<br>$$<br><font color="red">时间复杂度按数量级递增为：</font></p><table><thead><tr><th>常数阶</th><th align="center">对数阶</th><th>线性阶</th><th>线性对数阶</th><th>平方阶</th><th>立方阶</th><th>…</th><th>K次方阶</th><th>指数阶</th></tr></thead><tbody><tr><td>O（1）</td><td align="center">O(log2n)</td><td>O(n)</td><td>O(nlog2n)</td><td>O(n^2)</td><td>O(n^#)</td><td></td><td>O(n^K)</td><td>O(2^m)</td></tr></tbody></table><p>例题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>,k=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>k+=i;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用频度4，时间复杂度O(1)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>x++;<br>s+=x;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用频度n+2n，时间复杂度O(n)</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(i=<span class="hljs-number">1</span>;i&lt;=n;i++)</span></span>&#123;<br><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(j=<span class="hljs-number">1</span>;j&lt;=n;j++)</span></span>&#123;<br><span class="hljs-attribute">x</span>++;<br>s+=<span class="hljs-attribute">x</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用频度2n+2n^2，时间复杂度O(n^2)</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-variable language_">x</span>=n;<br><span class="hljs-variable language_">y</span>=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(<span class="hljs-variable language_">x</span>&gt;(<span class="hljs-variable language_">y</span>+<span class="hljs-number">1</span>)*(<span class="hljs-variable language_">y</span>+<span class="hljs-number">1</span>))&#123;<br><span class="hljs-variable language_">y</span>++;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用频度sqrt(n)-1，时间复杂度O(sqrt(n))</p><hr><h2 id="第二章-基本数据结构"><a href="#第二章-基本数据结构" class="headerlink" title="第二章 基本数据结构"></a>第二章 基本数据结构</h2><h3 id="2-1线性表"><a href="#2-1线性表" class="headerlink" title="2.1线性表"></a>2.1线性表</h3><h4 id="2-1-1-基本概念"><a href="#2-1-1-基本概念" class="headerlink" title="2.1.1 基本概念"></a>2.1.1 基本概念</h4><p>逻辑结构是线性结构</p><p>n个数据元素的有限序列，记作(a0,a1,a2,…,an-1)</p><p>数据类型有任意性和一致性</p><p>除首尾，每个结点都有唯一一个前驱和后继</p><p>相邻数据元素之间存在序偶关系，含义为顺序和配对</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">ADT List=<span class="hljs-params">(</span><br><span class="hljs-params"><span class="hljs-attr">D</span>=&#123;ai|<span class="hljs-attr">i</span>=1,2,...,n,n&gt;=0&#125;</span><br><span class="hljs-params"><span class="hljs-attr">R</span>=&#123;&lt;ai-1,ai&gt;|<span class="hljs-attr">i</span>=2,...,n&#125;</span><br><span class="hljs-params">)</span><br></code></pre></td></tr></table></figure><h5 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h5><p>1，初始化操作</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">InitList</span><span class="hljs-params">(&amp;L)</span></span>#创建新列表<br></code></pre></td></tr></table></figure><p>2，结构销毁</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">DestoryList</span><span class="hljs-params">(&amp;L)</span></span>#销毁线性表<br></code></pre></td></tr></table></figure><p>3，引用形操作，不改变原表</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Empty</span><span class="hljs-params">(L)</span></span>#判断表是否为空<br><span class="hljs-function"><span class="hljs-title">Length</span><span class="hljs-params">(L)</span></span>#求表长度<br><span class="hljs-function"><span class="hljs-title">Prior</span><span class="hljs-params">(L,x,&amp;pre)</span></span>#求前驱<br><span class="hljs-function"><span class="hljs-title">Next</span><span class="hljs-params">(L,x,&amp;next)</span></span>#求后继<br><span class="hljs-function"><span class="hljs-title">Get</span><span class="hljs-params">(L,i)</span></span>#获得某个数据元素<br><span class="hljs-function"><span class="hljs-title">Locate</span><span class="hljs-params">(L,x)</span></span>#确定某元素在表中的位置<br></code></pre></td></tr></table></figure><p>4，加工形操作，改变原表</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Clear</span><span class="hljs-params">(L)</span></span>#线性表置空<br><span class="hljs-function"><span class="hljs-title">PutElem</span><span class="hljs-params">(&amp;L,i,x)</span></span>#改变数据元素的值<br></code></pre></td></tr></table></figure><p>线性表常用的两种存储结构：</p><p>顺式存储结构（顺序表）</p><p>链式存储结构（链表）</p><p>任一种存储结构，不仅要存储数据对象，也要存储数据对象之间的逻辑关系，并且在数据操作过程中不能破坏这种逻辑关系</p><h4 id="2-1-2-顺序表"><a href="#2-1-2-顺序表" class="headerlink" title="2.1.2 顺序表"></a>2.1.2 顺序表</h4><p>线性表的顺序存储结构：将线性表中的元素相继存放在一个连续的存储空间，数组</p><p>元素存储位置体现逻辑关系</p><p>一维数组实现顺序表，需要预先定义数组大小，可以任意存取（直接指定下标存储）</p><h5 id="顺序表操作"><a href="#顺序表操作" class="headerlink" title="顺序表操作"></a>顺序表操作</h5><p>顺序表定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize </span><br>Type SeqList[MaxSize];<br><span class="hljs-type">int</span> last; \\最后元素的下标<br></code></pre></td></tr></table></figure><p>元素查找，从前到后，顺序查找</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fortran">Locate(<span class="hljs-keyword">Type</span> x,<span class="hljs-keyword">Type</span> &amp;<span class="hljs-keyword">data</span>)&#123;<br><span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i&lt;=last&amp;&amp;<span class="hljs-keyword">data</span>[i]<span class="hljs-comment">!=x)&#123;</span><br>i++;<br>&#125;<br><span class="hljs-keyword">if</span>(i&gt;last) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><p>插入函数</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs fortran">Insert(<span class="hljs-built_in">int</span> i,<span class="hljs-keyword">Type</span> x,<span class="hljs-keyword">Type</span> &amp;<span class="hljs-keyword">data</span>)&#123;<br><span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>||i&gt;last+<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span>&#123;<br>last++;<br>for(j=last;j&gt;i;j--) <span class="hljs-keyword">data</span>[j]=<span class="hljs-keyword">data</span>[j-<span class="hljs-number">1</span>];\\最后一位直接丢了？<br><span class="hljs-keyword">data</span>[i]=x;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>删除函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">Delect(<span class="hljs-type">int</span> i,Type &amp;data)&#123;<br><span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>||i&gt;last||last&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=last;j++) data[j<span class="hljs-number">-1</span>]=data[j];<br>last--;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="顺序表特点"><a href="#顺序表特点" class="headerlink" title="顺序表特点"></a>顺序表特点</h5><p>随机存取，数据元素寻址时间确定</p><p>元素需设置最大个数，如果设置不当会造成数据溢出或浪费</p><p>插入或删除操作需要耗费较多时间移动数据元素，其时间复杂度为O(n)，n为线性表长度</p><h4 id="2-1-3-链表"><a href="#2-1-3-链表" class="headerlink" title="2.1.3 链表"></a>2.1.3 链表</h4><p>特点：用一组地址任意的存储单元存放线性表中的数据元素，用指针反映数据元素之间的线性关系，以“结点的序列”来表示线性表。</p><p>元素&#x3D;指针（指示后继元素的存储位置）+结点（表示数据元素）</p><p>分为：单链表，双向链表，循环链表，循环双向链表</p><h5 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h5><p>链表首结点作为链表的存储地址，称为头指针（head），用一个指针指向尾结点（last）</p><p>尾结点里面是空指针</p><h5 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h5><p>节点定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">Typedef <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>&#123;</span><br>Type data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;LNode *head;<br></code></pre></td></tr></table></figure><p>单链表查找(i是第i个)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">GetElem</span><span class="hljs-params">(<span class="hljs-type">int</span> i,Type &amp;e )</span>&#123;<br>LNode* p=head;<br><span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>&amp;&amp;j&lt;i<span class="hljs-number">-1</span>)&#123;<br>p=p-&gt;next;<br>j++;<br>&#125;<br><span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>||p-&gt;next==<span class="hljs-literal">NULL</span>||i&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>e=p-&gt;next-&gt;data;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>插入(在第i个结点前插入x)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Insert</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> x,<span class="hljs-type">const</span> <span class="hljs-type">int</span> i)</span>&#123;<br>LNode*p=head,*q;<br><span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>&amp;&amp;j&lt;i<span class="hljs-number">-1</span>)&#123;<br>p=p-&gt;next;<br>j++;<br>&#125;<br><span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>&amp;&amp;head!=<span class="hljs-literal">NULL</span>||i&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>LNode *newcode;<br>newcode=(LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>newcode-&gt;data=x;<br><span class="hljs-keyword">if</span>(head=<span class="hljs-literal">NULL</span>||i=<span class="hljs-number">0</span>)&#123;<br>newcode-&gt;next=head;<br>head=newcode;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>newcode-&gt;next=p-&gt;next;<br>p-&gt;next=newcode;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>删除第i个结点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Remove</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>LNode *p=head;<br><span class="hljs-type">int</span> k;<br><span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>&amp;&amp;k&lt;i<span class="hljs-number">-1</span>)&#123;<br>p=p-&gt;next;<br>k++;<br>&#125;<br><span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>||p-&gt;==<span class="hljs-literal">NULL</span>||i&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)&#123;<br>q=head;<br>p=head-&gt;next;<br>q-&gt;next=<span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>q=p-&gt;next;<br>p-&gt;next=q-&gt;next;<br>q-&gt;next=<span class="hljs-literal">NULL</span>;<br>&#125;<br>k=q-&gt;data;<br><span class="hljs-built_in">free</span>(k);<br>retutn k;<br>&#125;<br></code></pre></td></tr></table></figure><p>带表头结点的单链表</p><p>在头结点前加一个表头结点，表头结点的指针指向链表头指针</p><p>令指向表头结点的指针作为链表头指针head;</p><h6 id="表头结点的特点与作用"><a href="#表头结点的特点与作用" class="headerlink" title="表头结点的特点与作用"></a>表头结点的特点与作用</h6><p>表头结点与其它结点在结构上完全相同。</p><p>表头结点位于表的最前端，数据域通常不带数据，仅标志表头；表头结点指针域指向链表的首元素（首结点）。</p><p>设置表头结点的目的是简化链表操作，例如在进行结点插入和删除操作时无需额外判断是否在表头位置进行，可将不同情形下的处理统一起来。</p><p>表头结点的插入操作</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">newnode-&gt;next<span class="hljs-operator">=</span>p-&gt;link<span class="hljs-comment">;</span><br>if(p-&gt;next<span class="hljs-operator">=</span><span class="hljs-operator">=</span>NULL) last<span class="hljs-operator">=</span>newnode<span class="hljs-comment">;</span><br>p-&gt;next<span class="hljs-operator">=</span>newcode<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>表头结点的删除操作</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">q</span><span class="hljs-operator">=</span>p-&gt;next<span class="hljs-comment">;</span><br>p-&gt;next<span class="hljs-operator">=</span>q-&gt;next<br>delect q<span class="hljs-comment">;</span><br>if(p-&gt;next<span class="hljs-operator">=</span><span class="hljs-operator">=</span>NULL) last<span class="hljs-operator">=</span>p<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>一个链表类应存在的操作：</p><p>构造函数，析构函数，置空函数，求链表长度函数，查找函数，取值函数，结点插入函数，结点删除函数</p><h5 id="链表特点"><a href="#链表特点" class="headerlink" title="链表特点"></a>链表特点</h5><p>数据元素（结点）由数据域和指针域共同构成；</p><p>链表属于顺序存取结构，数据元素的搜索需按指针方向逐个结点顺序进行，寻址时间取决于被搜寻结点在表中的位置；</p><p>在主存允许的情况下，链表可以按需扩充，不存在空间浪费或空间溢出问题；</p><p>插入或删除操作只需修改相关结点的指针，操作简单。</p><h5 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h5><p>循环链表的尾结点的next指针指向头结点（或者表头结点）</p><p><img src="https://s2.loli.net/2024/09/16/XpotTNuj6qnUkWH.jpg" alt="_20240915095038.png"></p><p>循环链表只要知道表中某一结点的地址就可以找到所有其他结点</p><h5 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h5><p>在前驱和后继方向都有指针指向的线性链表</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gauss">Typedef <span class="hljs-keyword">struct</span> <span class="hljs-type">DNode</span>&#123;<br><span class="hljs-built_in">Type</span> data;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">DNode</span> *llink;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">DNode</span> *rlink;<br>&#125;DNode *head;<br></code></pre></td></tr></table></figure><h5 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h5><p>头结点的llink指向尾结点，尾结点的rlink指向头结点</p><img src="https://s2.loli.net/2024/09/16/4xEpV3XwaKmLco2.jpg" alt="_20240915095239.png" style="zoom:67%;" /><p>带表头结点的双向循环链表</p><img src="https://s2.loli.net/2024/09/22/FUDwcuV816NjnpO.jpg" alt="_20240922092243.png" style="zoom: 67%;" /><p>双向循环链表搜索算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">DblNode*current;<span class="hljs-comment">// 当前结点</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Find</span><span class="hljs-params">(<span class="hljs-type">const</span> Type &amp;target)</span>&#123;<br>DblNode*p=head-&gt;rlink;<br><span class="hljs-keyword">while</span>(p!=first&amp;&amp;p-&gt;data!=target) p=p-&gt;rlink;<br><span class="hljs-keyword">if</span>(p!=first)&#123;current=p;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>双向循环链表插入算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Insert</span><span class="hljs-params">(<span class="hljs-type">const</span> Type&amp;value)</span>&#123;<br>DblNode *p;<br><span class="hljs-keyword">if</span>(first-&gt;rlink==first)&#123;<span class="hljs-comment">//空表插入，只能插入后方</span><br>    p=&#123;value,first,first&#125;;<br>current=p;<br>current=first-&gt;rlink;<br>first-&gt;llink=current;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//非空表插入，插入current的前方</span><br>p=&#123;value,current-&gt;llink,current&#125;;<br>current-&gt;llink=p;<br>current=current0&gt;llink;<br>current-&gt;llink-&gt;rlink=current;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>双向循环链表删除操作</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros">void <span class="hljs-built_in">Remove</span>() &#123;<br><span class="hljs-keyword">if</span>(current!=<span class="hljs-literal">NULL</span>)&#123;<br>DblNode*<span class="hljs-attribute">temp</span>=current;<br><span class="hljs-attribute">current</span>=current-&gt;rlink;<br>current-&gt;<span class="hljs-attribute">llink</span>=temp-&gt;llink;<br>temp-&gt;llink-&gt;<span class="hljs-attribute">rlink</span>=current;<br>delect temp;<br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-attribute">current</span>==first)<br><span class="hljs-attribute">current</span>=<span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="循环链表和双向链表特点"><a href="#循环链表和双向链表特点" class="headerlink" title="循环链表和双向链表特点"></a>循环链表和双向链表特点</h6><p>循环链表可由任意一个结点出发访问其它结点；</p><p>双向链表可以快速访问任意结点的直接前驱结点；</p><h5 id="EXAMPLE"><a href="#EXAMPLE" class="headerlink" title="EXAMPLE"></a>EXAMPLE</h5><img src="https://s2.loli.net/2024/09/22/1c2Vhdr3OgEDoBs.jpg" alt="_20240922100422.png" style="zoom:50%;" /><p>1，如何删除2的结点</p><p>将2处结点赋值为3，3处结点赋值为2，然后删除值为2的结点，也满足要求；</p><p>2，反向打印单链表</p><p>递归</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss">void <span class="hljs-built_in">PrintListReversingly</span>(LNode*head)&#123;<br><span class="hljs-built_in">if</span>(head!=NULL)&#123;<br><span class="hljs-built_in">if</span>(head-&gt;next!=NULL)&#123;<br><span class="hljs-built_in">PrintListReversingly</span>(head-&gt;next);<br>&#125;<br><span class="hljs-built_in">printf</span>(&quot;%d&quot;,head-&gt;value);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3，输入一个链表，输出倒数第k个元素，计数从1开始</p><p>用两个指针，一个从头开始遍历，行动到k-1步时，第二个指针开始从头行动，等第一个指针行动到末尾时，第二个指针正好行动到倒数第k个位置。</p><p>4，如何找到单向链表的中间结点</p><p>两个指针，一个步长1一个步长2，等2的到终点，1的到中间。</p><h3 id="2-2-栈和队列"><a href="#2-2-栈和队列" class="headerlink" title="2.2 栈和队列"></a>2.2 栈和队列</h3><p>栈和队列是限定删除和插入操作只能在表的端点处实现的线性表</p><h4 id="2-2-1-堆栈"><a href="#2-2-1-堆栈" class="headerlink" title="2.2.1 堆栈"></a>2.2.1 堆栈</h4><p>栈是限定仅在表的一端（一般表尾）进行插入和删除的线性表</p><p>允许插入和删除的这一端叫栈顶，另一端叫栈底，栈的插入叫做入栈、进栈；栈的删除叫做出栈、退栈。</p><img src="https://s2.loli.net/2024/09/22/pbHRitUgNQfFykc.jpg" alt="_20240922103048.png" style="zoom: 50%;" /><p>按a0,a1,a2的顺序入栈，a0是栈底，an是栈顶，遵循后进先出的原则。又称LIFO表。</p><p>入栈要求栈不能满，否则报错overflow（上溢）；出栈要求栈不能空，否则报错underflow（下溢）。</p><p>抽象模型</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">ADT Stack&#123;<br><span class="hljs-symbol">data:</span><span class="hljs-built_in">a0</span>,<span class="hljs-built_in">a1</span>,<span class="hljs-built_in">a2</span>;<br><span class="hljs-symbol">relation:</span>&lt;<span class="hljs-built_in">a0</span>,<span class="hljs-built_in">a1</span>&gt;,&lt;<span class="hljs-built_in">a1</span>,<span class="hljs-built_in">a2</span>&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p>栈也有两种储存结构：顺序存储和链式存储</p><h5 id="2-2-1-1-顺序栈"><a href="#2-2-1-1-顺序栈" class="headerlink" title="2.2.1.1 顺序栈"></a>2.2.1.1 顺序栈</h5><p>顺序栈存储结构是一组连续地址的存储单元依次自栈底到栈顶存储，同时有top指针（下标），指示栈顶元素的当前位置。</p><p>top&#x3D;-1表示空栈，入栈top+1，出栈top-1</p><p>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 1000</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stack</span>&#123;</span><br><span class="hljs-type">int</span> elem[MAXSIZE];<br><span class="hljs-type">int</span> top;<br>&#125;SQSTACK;<br></code></pre></td></tr></table></figure><p>基本操作</p><p>初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">InitStack</span><span class="hljs-params">(SQSTACK *ps)</span>&#123;<br>ps-&gt;top=<span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>判断栈是否空</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">StackEmpty</span><span class="hljs-params">(SQSTACK s)</span></span>&#123;<br><span class="hljs-keyword">if</span>(s.top==<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>入栈</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coq">int Push(SQSTACK *ps,int e)&#123;<br><span class="hljs-keyword">if</span>(ps-&gt;<span class="hljs-built_in">top</span>==MAXSIZE) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>ps-&gt;<span class="hljs-built_in">top</span>++;<br>ps-&gt;elem[ps-&gt;<span class="hljs-built_in">top</span>]=e;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>出栈</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coq">int Pop(SQSTACK *ps,int *pe)&#123;<br><span class="hljs-keyword">if</span>(ps-&gt;<span class="hljs-built_in">top</span>==<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>*pe=ps-&gt;elem[ps-&gt;<span class="hljs-built_in">top</span>];<br>ps-&gt;<span class="hljs-built_in">top</span>--;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>读栈顶元素</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetTop</span><span class="hljs-params">(SQSTACK s,<span class="hljs-type">int</span> *pe)</span></span>&#123;<br><span class="hljs-keyword">if</span>(s.top==<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>*pe=s.elem[s.top];<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-2-1-2-链栈"><a href="#2-2-1-2-链栈" class="headerlink" title="2.2.1.2 链栈"></a>2.2.1.2 链栈</h5><p>链式存储结构，是一种特殊的单链表，仅限在表头处进行插入和删除的单链表</p><p>链栈中指针的方向是从栈顶指向栈底</p><p>top→a0（栈顶）→a1→a2→a3（栈底）</p><p>链栈中没必要附加表头结点</p><p>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">snode</span>&#123;</span><br><span class="hljs-type">int</span> data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>* <span class="hljs-title">next</span>;</span><br>&#125;SNODE;<br>SNODE top;<br></code></pre></td></tr></table></figure><p>基本操作</p><p>入栈：相当于在单链表第一个节点前进行插入操作</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">void push(SNODE **pps,int e)&#123;<br>SNODE *p;<br>p=(SNODE*)malloc(sizeof(SNODE));<br>p-&gt;<span class="hljs-attribute">data</span>=e;<br>p-&gt;<span class="hljs-attribute">next</span>=*pps;<br>*<span class="hljs-attribute">pps</span>=p;<br>&#125;<br></code></pre></td></tr></table></figure><p>出栈：相当于单链表中删除第一个结点</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros">int pop(SNODE**pps,int *pe)&#123;<br>SNODE*p;<br><span class="hljs-keyword">if</span>(*<span class="hljs-attribute">pps</span>==NULL) return 1;<br>*<span class="hljs-attribute">pe</span>=*pps-&gt;data;<br><span class="hljs-attribute">p</span>=*pps;<br>*<span class="hljs-attribute">pps</span>=p-&gt;next;<br>delect p;<br>retutn 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>给定序列ABC，用栈实现其所有的序列变换</p><p>ABC: pushA; pop; pushB; pop; pushC; pop;</p><p>ACB: pushA; pop; pushB; pushC; pop; pop;</p><p>BCA: pushA; pushB; pop; pushC; pop; pop;</p><p>BAC: pushA; pushB; pop; pop; pushC; pop;</p><p>CBA: pushA; pushB; pushC; pop; pop; pop;</p><p>不能实现CAB</p><h5 id="2-2-1-3-栈的应用"><a href="#2-2-1-3-栈的应用" class="headerlink" title="2.2.1.3 栈的应用"></a>2.2.1.3 栈的应用</h5><p>1，进制转换，十进制数N转换为r进制数，用辗转相除法</p><img src="https://s2.loli.net/2024/09/22/xOe1vZbB3JD5cf9.jpg" alt="_20240922114247.png" style="zoom: 33%;" /><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">void</span> <span class="hljs-keyword">conversion</span>(<span class="hljs-type">int</span> N,<span class="hljs-type">int</span> r)&#123;<br>SQSTACK *ps;<span class="hljs-type">int</span> x;<br>InitStack(ps);<br><span class="hljs-keyword">while</span>(N)&#123;<br>push(ps,N%r);<br>N=N/r;<br>&#125;<br><span class="hljs-keyword">while</span>(!StackEmpty(*ps))&#123;<br>Pop(ps,&amp;x);<br>printf(&quot;%d&quot;,&amp;x);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2，程序嵌套调用，如递归算法</p><p>3，表达式求值</p><p>一个表达式由操作数（运算对象），操作符（运算符），分界符（空格 # ；等）</p><p>算术表达式有三种表达形式</p><p>中缀：&lt;操作数&gt;&lt;操作符&gt;&lt;操作数&gt; A+B</p><p>前缀：&lt;操作符&gt;&lt;操作数&gt;&lt;操作数&gt; +AB</p><p>后缀：&lt;操作数&gt;&lt;操作数&gt;&lt;操作符&gt; AB+</p><p>操作符有四种类型：</p><p>算数操作符：双目操作符（++，–），单目操作符（% + - * &#x2F;）</p><p>关系操作符：&lt;  &lt;&#x3D;  &gt;  &gt;&#x3D;  &#x3D;&#x3D;  !&#x3D;</p><p>逻辑操作符：&amp;&amp;   ||</p><p>括号：（）</p><p>中缀表示的相邻两个操作符计算次序：</p><p>优先级高的先算</p><p>优先级相同的按结合顺序</p><p>有括号先算括号内</p><p><B>中缀算术表达式求值流程：</B></p><p>两个栈：操作数栈s1，操作符栈s2，先都初始化为空栈</p><p>​对输入的字符如果是操作数，放入栈s1</p><p>​对输入的字符如果是操作符，比较char与s2栈顶元素的优先级：</p><p>​如果s2_top&lt;char，则char进s2栈</p><p>​如果s2_top&gt;char，则依次弹出s1的两个栈顶元素a2，a1，从s2栈弹出栈顶操作符θ，然后运算(a1)θ(a2)，运算结结果进s1栈，继续判断此操作符与新栈顶元素操作符的优先级</p><p>​如果s2_top&#x3D;char，则判断s2_top的结合性</p><p>​如果是左到右，则从s1栈依次弹出两个栈顶元素a2和a1，从s2栈弹出操作符θ，然后运算(a1)θ(a2)，运算结结果进s1栈，char进s2栈</p><p>​如果是右到左，直接进s2栈。</p><p>所有char都读完后，根据s2栈情况做判断。</p><p>​如果s2栈为空，s1栈栈顶元素即为所求值，</p><p>​如果s2栈不空，从s1栈依次弹出两个栈顶元素a2和a1，从s2栈弹出操作符θ，然后运算(a1)θ(a2)，运算结结果进s1栈，重复此操作直至s2栈变空。</p><p>求A</p><p>​<img src="https://s2.loli.net/2024/10/01/tGgs8xRFhavPXNf.jpg" alt="_20241001182148.png"></p><p>后缀表达式：与相应的中缀表达式操作数次序相同  没有括号</p><p><B>中缀转化为后缀规则：</B></p><p>​如果是操作数，直接输出到队列</p><p>​如果当前运算符高于栈顶运算符 入栈</p><p>​如果当前运算符小于栈顶运算符，栈顶的退栈，输出到队列，再比较</p><p>​如果当前运算符等于栈顶运算符：</p><p>​栈顶为（ ，当前为），则栈顶退栈</p><p>​栈顶为# ，当前为#，栈顶退栈，运算结束.</p><p><img src="https://s2.loli.net/2024/10/04/U8csKxTbCPkNzZl.jpg" alt="_20241004114812.png"></p><p><B>后缀表达式求值：</B></p><p>遇到数就入栈，遇到操作符就弹出依次栈顶元素b、a，运算a操作符b，结果再入栈，重复直至无操作符，栈顶元素即结果。</p><p>计算机计算中缀表达式就是先换为后缀表达式，再计算。</p><h5 id="2-2-1-4-思考题"><a href="#2-2-1-4-思考题" class="headerlink" title="2.2.1.4 思考题"></a>2.2.1.4 思考题</h5><p>1，如何得到栈的最小元素</p><p>添加一个辅助栈，第一个数据入栈时，辅助栈也同时入栈，后续再有数据入栈时，和辅助栈栈顶元素比较，如果更小就入辅助栈，否则不入栈。每次出栈时，也同时辅助栈比较出栈。</p><img src="https://s2.loli.net/2024/10/14/rzQePiujT3c7Yka.jpg" alt="_20241014132828.png" style="zoom: 67%;" /><p>2，栈升序排列</p><p>原栈，升序栈，辅助栈</p><p>原栈弹出元素，入升序栈；后续原栈弹出元素，此元素与升序栈栈顶元素比较，符合升序就入栈，不符合就升序栈弹出栈顶，辅助栈入栈，再比较，符合升序就入栈，不符合继续弹，直至符合入栈后，辅助栈再依次出栈入栈。</p><h4 id="2-2-2-队列"><a href="#2-2-2-队列" class="headerlink" title="2.2.2 队列"></a>2.2.2 队列</h4><p>先进先出，一个底部是空的栈，当满的时候再输入，会把最前面的挤出来。</p><img src="https://s2.loli.net/2024/10/14/iAS59W71bMr3nQ6.jpg" alt="_20241014133949.png" style="zoom:50%;" /><h5 id="2-2-2-1-顺序队列"><a href="#2-2-2-1-顺序队列" class="headerlink" title="2.2.2.1 顺序队列"></a>2.2.2.1 顺序队列</h5><p>一维数组来表示，入队要考虑队满，出队要考虑队空。有队首指针front，队尾指针rear。</p><p>front始终指向队列第一个元素，rear始终指向队尾元素下一个单元。</p><p>入队时在rear处添加元素，rear+&#x3D;1；</p><p>出队时取出front元素，front+&#x3D;1；</p><p>front之前的区域被忽视了，会出现假溢出现象。</p><h5 id="2-2-2-2-循环队列"><a href="#2-2-2-2-循环队列" class="headerlink" title="2.2.2.2 循环队列"></a>2.2.2.2 循环队列</h5><p>为区别队满队空，规定队列中始终留一个空单元</p><p>队首指针进1：front&#x3D;（front+1）%MAXSIZE；</p><p>队尾指针进1：rear&#x3D;（rear+1）%MAXSIZE；</p><p>队列初始化：front&#x3D;rear&#x3D;0；</p><p>队空条件：front&#x3D;&#x3D;rear</p><p>队满条件：（rear+1）%MAXSIZE&#x3D;&#x3D;front</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//定义队列</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QUEUE</span>&#123;</span><br>    <span class="hljs-type">int</span> count;<br>    <span class="hljs-type">int</span> front,rear;<br>    <span class="hljs-type">int</span> QUEAE_array[MAXSIZE];<br>&#125;Queue;<br><span class="hljs-comment">//初始化队列</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">InitQueue</span><span class="hljs-params">(Queue *q)</span>&#123;<br>    count=<span class="hljs-number">0</span>;<br>    rear=front=<span class="hljs-number">0</span>;<br>    q-&gt;QUEUE_array=(<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*MAXSIZE);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//判断空</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Empty</span><span class="hljs-params">(Queue *q)</span>&#123;<br>    <span class="hljs-keyword">if</span>(q-&gt;count==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//判断满</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Full</span><span class="hljs-params">(Queue *q)</span>&#123;<br>    <span class="hljs-keyword">if</span>((rear+<span class="hljs-number">1</span>)%MAXSIZE==front)) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//入队</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Append</span><span class="hljs-params">(Queue *q,<span class="hljs-type">int</span> e)</span>&#123;<br>    <span class="hljs-keyword">if</span>(Full(q)) <span class="hljs-keyword">return</span> overflow;<br>    q-&gt;QUEUE_array[rear]=e;<br>    rear=(rear+<span class="hljs-number">1</span>)%MAXSIZE;<br>    count++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">//出队</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Serve</span><span class="hljs-params">(Queue *q,<span class="hljs-type">int</span> &amp;item)</span>&#123;<br>    <span class="hljs-keyword">if</span>(Empty(q)) <span class="hljs-keyword">return</span> underflow;<br>    item=q-&gt;QUEUE_array[front];<br>    front=(front+<span class="hljs-number">1</span>)%MAXSIZE;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">//取队首元素</span><br></code></pre></td></tr></table></figure><h5 id="2-2-2-3-链队列"><a href="#2-2-2-3-链队列" class="headerlink" title="2.2.2.3 链队列"></a>2.2.2.3 链队列</h5><p>队首在链头，队尾在链尾</p><p>链队列在进队时不用考虑队满，出队要考虑队空。</p><p>队空条件 front&#x3D;&#x3D;NULL；</p><p>进队只需改变rear，出队改变front</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//入队</span><br><span class="hljs-keyword">if</span>(front==<span class="hljs-literal">NULL</span>) front=rear=newnode;<br><span class="hljs-keyword">else</span>&#123;<br>    rear-&gt;next=newnode;<br>    rear=rear-&gt;next;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//出队</span><br><span class="hljs-keyword">if</span>(front==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> underflow;<br>e=front-&gt;data;<br>front=front-&gt;next;<br></code></pre></td></tr></table></figure><h4 id="2-2-3-summary"><a href="#2-2-3-summary" class="headerlink" title="2.2.3 summary"></a>2.2.3 summary</h4><p>相同点:</p><p>逻辑结构相同，都是线性的;都可以用顺序存储或链表存储;栈和队列是两种特殊的线性表，即受限的线性表(只是对插入、删除运算    加以限制)</p><p>不同点:<br>① 运算规则不同，线性表为随机存取，而栈是只允许在一端进行插入和删除运算，因而是后进先出表LIFO;队列是只允许在一端进行插入、另一端进行删除运算，因而是先进先出表 FIFO。<br>②用途不同，线性表比较通用;堆栈用于元素的保存次序与使用顺序相反的情况;队列用于元素的保存次序与使用顺序相同的情况。</p><p>两个栈实现一个队列</p><p>入队时，元素弹入s1。出队时，判断s2是否为空，不为空就弹出栈顶元素；为空就先将s1元素逐个出栈再入栈，相当于反方向入栈，再弹出栈顶元素。0</p><h2 id="第三章-树"><a href="#第三章-树" class="headerlink" title="第三章 树"></a>第三章 树</h2><h3 id="3-1-定义与基本术语"><a href="#3-1-定义与基本术语" class="headerlink" title="3.1 定义与基本术语"></a>3.1 定义与基本术语</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>D中的元素都有相同的数据类型</p><p>存在唯一的成为根root的元素，其余结点又可分为若干互不相交的有限子集，每个自己都符合树的定义，成为子树。</p><img src="https://s2.loli.net/2024/10/21/DCwrj7KYxLBVuGz.jpg" alt="_20241021135259.png" style="zoom:50%;" /><p>结点：数据元素+若干指向其子树的分支</p><p>结点的度：结点的子结点的个数</p><p>树的度：树中所有结点的度的最大值</p><p>叶子结点：度为0的结点</p><p>分支结点：度大于0的结点</p><p>双亲和孩子：结点的子树的根节点成为该节点的孩子，反之结点是孩子的双亲</p><p>层：根节点为层一，任意结点的层等于其双亲层数加一</p><p>深度：各叶子结点层数最大值</p><p>兄弟：有同一双亲结点</p><p>堂兄弟：双亲在同一层的结点</p><p>路径：根节点到某节点经过的分支和结点组成</p><p>祖先：从根结点到此结点所经分支上所有结点；结点的子树上所有结点都是其子孙</p><p>森林：m棵互不相交的树的集合；任一个非空树是一个二元组Tree&#x3D;(root,F)，root是根节点，F是子树森林</p><p>有序树&amp;无序树：子树之间从左到右存在次序关系不能互换，称为有序树；子树之间不存在次序关系，称为无序树。</p><h4 id="基本操作："><a href="#基本操作：" class="headerlink" title="基本操作："></a>基本操作：</h4><h5 id="查找类："><a href="#查找类：" class="headerlink" title="查找类："></a>查找类：</h5><p>Root(T)                   &#x2F;&#x2F; 求树的根结点</p><p>Value(T, cur_e)     &#x2F;&#x2F; 求当前结点的元素值</p><p>Parent(T, cur_e)   &#x2F;&#x2F; 求当前结点的双亲结点</p><p>LeftChild(T, cur_e) &#x2F;&#x2F; 求当前结点的最左孩子 </p><p>RightSibling(T, cur_e)  &#x2F;&#x2F; 求当前结点的右兄弟</p><p>TreeEmpty(T)      &#x2F;&#x2F; 判定树是否为空树 </p><p>TreeDepth(T)       &#x2F;&#x2F; 求树的深度</p><p>TraverseTree( T, Visit() )    &#x2F;&#x2F; 遍历</p><h5 id="插入类："><a href="#插入类：" class="headerlink" title="插入类："></a>插入类：</h5><p>InitTree(&amp;T) &#x2F;&#x2F;初始化，置空树</p><p>CreateTree(&amp;T, definition) &#x2F;&#x2F; 按定义构造树</p><p>Assign(T, cur_e, value)  &#x2F;&#x2F; 给当前结点赋值</p><p>InsertChild(&amp;T, &amp;p, i, c) &#x2F;&#x2F; 将以c为根的树插入为结点2p的第i棵</p><h5 id="删除类："><a href="#删除类：" class="headerlink" title="删除类："></a>删除类：</h5><p>ClearTree(&amp;T)   &#x2F;&#x2F;将树清空</p><p>DestroyTree(&amp;T)  &#x2F;&#x2F; 销毁树的结构</p><p>DeleteChild(&amp;T, &amp;p, i) &#x2F;&#x2F; 删除结点p的第i棵子树</p><h3 id="3-2-树的存储结构"><a href="#3-2-树的存储结构" class="headerlink" title="3.2 树的存储结构"></a>3.2 树的存储结构</h3><h4 id="3-2-1-双亲数组表示法（顺序存储结构）"><a href="#3-2-1-双亲数组表示法（顺序存储结构）" class="headerlink" title="3.2.1 双亲数组表示法（顺序存储结构）"></a>3.2.1 双亲数组表示法（顺序存储结构）</h4><p>每个结点含两个域：</p><p>数据域：放结点本身信息</p><p>双亲域：指示本结点双亲结点在数组中位置</p><p>找双亲容易，找孩子难</p><h4 id="3-2-2-孩子链表表示法"><a href="#3-2-2-孩子链表表示法" class="headerlink" title="3.2.2 孩子链表表示法"></a>3.2.2 孩子链表表示法</h4><p>每个结点除了数据域还有指针域存储其孩子结点的指针。</p><p>各结点结构相同：指针个数相等，都是树的度</p><p>各结点结构不同：指针个数不等，是该节点的度</p> <img src="https://s2.loli.net/2024/10/21/oa27UmdDgRprHnN.jpg" alt="_20241021150101.png" style="zoom:50%;" /><h4 id="3-2-3-左孩子右兄弟表示法"><a href="#3-2-3-左孩子右兄弟表示法" class="headerlink" title="3.2.3 左孩子右兄弟表示法"></a>3.2.3 左孩子右兄弟表示法</h4><p>用二叉链表：每个结点的两个指针分别指向第一个孩子结点和下一个兄弟结点</p><img src="https://s2.loli.net/2024/10/21/aNUxdbBMzrhoXSt.jpg" alt="_20241021150307.png" style="zoom:50%;" /><h3 id="3-3-二叉树"><a href="#3-3-二叉树" class="headerlink" title="3.3 二叉树"></a>3.3 二叉树</h3><h4 id="3-3-1-定义"><a href="#3-3-1-定义" class="headerlink" title="3.3.1 定义"></a>3.3.1 定义</h4><p>每个结点最多有两个孩子结点的树</p><p>二叉树五种形态：空树，只含根节点，左子树为空树，右子树为空树，左右均不为空树。</p><h5 id="二叉树基本操作："><a href="#二叉树基本操作：" class="headerlink" title="二叉树基本操作："></a>二叉树基本操作：</h5><p>Root(T)：求二叉树T的根结点；</p><p>Value(T, e)：求结点e的值；    </p><p>Parent(T, e)：求结点e的双亲结点；</p><p>LeftChild(T, e)：求结点e的左孩子结点；</p><p>RightChild(T, e)：求结点e的右孩子结点；</p><p>LeftSibling(T, e)：求结点e的左兄弟结点；</p><p>RightSibling(T, e)：求结点e的右兄弟结点；</p><p>BiTreeEmpty(T)：判 断二叉树T是否为空树；</p><p>BiTreeDepth(T)：求二叉树T的深度；</p><p>InitBiTree(&amp;T)：初始化二叉树T为空树；</p><p>Assign(T, &amp;e, value)：为结点e赋值；</p><p>CreateBiTree(&amp;T, definition)：根据定义创建 二叉树；</p><p>InsertChild(T, p, LR, c)：将c插入到二叉树T中成为结点p的左（或右）孩子结点；</p><p>ClearBiTree(&amp;T)：清空二叉树T；</p><p>DestroyBiTree(&amp;T)： 销毁二叉树T；</p><p>DeleteChild(T, p, LR)：删除二叉树T中结点p的左（或右）孩子结点</p><h5 id="二叉树的遍历："><a href="#二叉树的遍历：" class="headerlink" title="二叉树的遍历："></a>二叉树的遍历：</h5><p>PreOrderTraverse(T, Visit())：前序遍历</p><p>InOrderTraverse(T, Visit())：中序遍历</p><p>PostOrderTraverse(T, Visit())：后序遍历</p><p>LevelOrderTraverse(T, Visit())：层序遍历</p><h5 id="重要性质："><a href="#重要性质：" class="headerlink" title="重要性质："></a>重要性质：</h5><h6 id="性质一："><a href="#性质一：" class="headerlink" title="性质一："></a>性质一：</h6><p>在二叉树的第i层上最多有2^(i-1)个结点</p><h6 id="性质二："><a href="#性质二：" class="headerlink" title="性质二："></a>性质二：</h6><p>深度为k的二叉树上至多有2^k-1个结点。</p><h6 id="性质三："><a href="#性质三：" class="headerlink" title="性质三："></a>性质三：</h6><p>对任何一个二叉树，如果他有n0个叶子结点，n2个度为2的结点，则必有n0&#x3D;n2+1</p><h6 id="两种二叉树："><a href="#两种二叉树：" class="headerlink" title="两种二叉树："></a>两种二叉树：</h6><p>满二叉树：每一层上的结点数都是最大结点数，，所有支结点都有左右子树，结点可以连续编号。</p><p>完全二叉树：深度为k，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1到n的结点一一对应，该二叉树称为完全二叉树。或者深度为k的满二叉树从1到n的前n个编号组成了一个完全二叉树，要求n大到编号到最后一层。</p><img src="https://s2.loli.net/2024/10/21/UryR1MzO8PBgQwK.jpg" alt="_20241021180654.png" style="zoom:50%;" /><p>区别：满二叉树是叶子一个也不少的树(所有 k层的结点全满)，而完全二叉树虽然前 k-1 层是满的，但最后一层(第k层)却允许在右边缺少连续若干个结点。满二叉树是完全二叉树的一个特例:满二叉树一定是完全二叉树，而完全二叉树不一定是满二叉树。</p><h6 id="性质四："><a href="#性质四：" class="headerlink" title="性质四："></a>性质四：</h6><p>具有n个结点的完全二叉树的深度为[log_2 n]+1(以2为底n的对数)</p><h6 id="性质五："><a href="#性质五：" class="headerlink" title="性质五："></a>性质五：</h6><p>对含n个结点的完全二叉树从上到下，从左到右进行1-n的编号，对任一个编号为i的结点：</p><p>如果i&#x3D;1，则是根节点，无双亲；否则[i&#x2F;2]就是其双亲结点。</p><p>如果2i&gt;n，则此结点无左孩子结点；如果2i+1&gt;n,则此结点无右孩子结点。</p><h4 id="3-3-2-二叉树的存储结构"><a href="#3-3-2-二叉树的存储结构" class="headerlink" title="3.3.2 二叉树的存储结构"></a>3.3.2 二叉树的存储结构</h4><h5 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h5><h6 id="完全二叉树的顺序存储："><a href="#完全二叉树的顺序存储：" class="headerlink" title="完全二叉树的顺序存储："></a>完全二叉树的顺序存储：</h6><p>按照自上而下、从左到右的顺序给结点编号，用数组存储，结点从1开始编号，数组也从1下标开始存储。编号为i的结点，其双亲结点为[i&#x2F;2]，左孩子结点2i，右孩子结点2i+1</p><img src="https://s2.loli.net/2024/10/21/XHEe6cVhd2U4uwp.jpg" alt="_20241021183349.png" style="zoom: 50%;" /><h6 id="非完全二叉树顺序存储："><a href="#非完全二叉树顺序存储：" class="headerlink" title="非完全二叉树顺序存储："></a>非完全二叉树顺序存储：</h6><p>一律转为完全二叉树，补充空结点，此时结点编号之间的关系仍存在。</p><img src="https://s2.loli.net/2024/10/21/j3MFcLxJrNudeE4.jpg" alt="_20241021183455.png" style="zoom:50%;" /><p>编号从零开始时，i结点的双亲结点[(i+1)&#x2F;2]-1，左孩子结点2i+1，右孩子结点2(i+1)。(建议别用)</p><p>一般二叉树都要改为完全二叉树，会造成存储空间浪费。</p><h6 id="结构数组："><a href="#结构数组：" class="headerlink" title="结构数组："></a>结构数组：</h6><p>每个元素都是一个结构体，包含data，parent，leftchild，rightchild，四个域分别存储数据，双亲结点、左孩子、右孩子结点所在的数组单元下标。如果不存在那么相对域的下标取-1；</p><img src="https://s2.loli.net/2024/10/21/P4qGQo91c5StuOy.jpg" alt="_20241021184754.png" style="zoom:50%;" /><h5 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h5><h6 id="二叉链表："><a href="#二叉链表：" class="headerlink" title="二叉链表："></a>二叉链表：</h6><p>每个结点由lchild，data，rchild组成。lchild指向左孩子结点，rchild指向右孩子结点。</p><h6 id="三叉链表："><a href="#三叉链表：" class="headerlink" title="三叉链表："></a>三叉链表：</h6><p>每个结点由parent，lchild，data，rchild。多了个parent指向双亲结点。</p><img src="https://s2.loli.net/2024/10/21/rHnBJ8VtagLeuY2.jpg" alt="_20241021185124.png" style="zoom:50%;" /><h4 id="3-3-3-二叉树的遍历"><a href="#3-3-3-二叉树的遍历" class="headerlink" title="3.3.3 二叉树的遍历"></a>3.3.3 二叉树的遍历</h4><p>设访问根结点记作V，遍历根的左子树记作L，遍历根的右子树记作R。</p><p>可能的遍历次序有：</p><p>前序VLR，逆前序VRL</p><p>中序LVR，逆中序RVL</p><p>后序LRV，逆后序RLV</p><p>层序遍历</p><h5 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h5><img src="https://s2.loli.net/2024/10/21/U2VvKsLwQlBgWSn.jpg" alt="_20241021195332.png" style="zoom:50%;" /><p>递归算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>  <span class="hljs-title function_">PreorderTraverse</span><span class="hljs-params">(BTNode  *T)</span>&#123;  <br><span class="hljs-keyword">if</span>  (T!=<span class="hljs-literal">NULL</span>) &#123;<br>        visit(T-&gt;data) ;<span class="hljs-comment">/*  访问根结点*/</span><br>        PreorderTraverse(T-&gt;Lchild) ;<br>        PreorderTraverse(T-&gt;Rchild) ;<br>    &#125;&#125;<br></code></pre></td></tr></table></figure><p>非递归算法略</p><h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><img src="https://s2.loli.net/2024/10/30/i7P1vVGA2JR3zSo.jpg" alt="_20241030185744.png" style="zoom: 50%;" /><p>递归算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>   <span class="hljs-title function_">InorderTraverse</span><span class="hljs-params">(BTNode  *T)</span>&#123;  <br><span class="hljs-keyword">if</span>  (T!=<span class="hljs-literal">NULL</span>) &#123;<br> InorderTraverse(T-&gt;Lchild) ;<br>        visit(T-&gt;data) ;<span class="hljs-comment">/*  访问根结点*/</span><br>         InorderTraverse(T-&gt;Rchild) ;<br>    &#125;&#125;<br></code></pre></td></tr></table></figure><h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><img src="https://s2.loli.net/2024/10/30/i4g6FapmJCL3Hv5.jpg" alt="_20241030185954.png" style="zoom:50%;" /><p>递归算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>   <span class="hljs-title function_">PostorderTraverse</span><span class="hljs-params">(BTNode  *T)</span>&#123;  <br><span class="hljs-keyword">if</span>  (T!=<span class="hljs-literal">NULL</span>) &#123;<br> PostorderTraverse(T-&gt;Lchild) ;<br>         PostorderTraverse(T-&gt;Rchild) ;<br>         visit(T-&gt;data) ;<span class="hljs-comment">/*  访问根结点*/</span><br>    &#125;&#125;<br></code></pre></td></tr></table></figure><h5 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h5><img src="https://s2.loli.net/2024/10/30/Ain7e1wX6O8ILaE.jpg" alt="_20241030190117.png" style="zoom:50%;" /><img src="https://s2.loli.net/2024/10/30/9H5Ec1Oe3gxKyRQ.jpg" alt="_20241030190241.jpg" style="zoom:33%;" /><p>简单判断：<img src="https://s2.loli.net/2024/10/30/K7BgaTlHP69DpL2.jpg" alt="_20241030190353.png" style="zoom: 33%;" />对二叉树做如图画线，在每个结点左方，下方，右方各标记一个小圆圈。如图画线后，前序遍历按照画到左侧标记的顺序来；中序遍历按照画到下侧标记的顺序来；后序遍历按照画到右侧标记的顺序来；层序遍历从上到下，从左到右，一层一层。</p><p>前序：ABDEFGC</p><p>中序：DBFEGAC</p><p>后序：DFGEBCA</p><p>层序：ABCDEFG</p><p>前序遍历+中序遍历和后序遍历+中序遍历 可以唯一确定一棵二叉树</p><p>前序遍历+后序遍历不可唯一确定一棵二叉树</p><img src="https://s2.loli.net/2024/10/30/JvFXMCr5lQWbxfz.jpg" alt="_20241030192714.png" style="zoom: 67%;" /><p>由前序和中序，前序定抽取顺序，从中序开始分支。</p><h5 id="遍历算法的应用有（未完待续）"><a href="#遍历算法的应用有（未完待续）" class="headerlink" title="遍历算法的应用有（未完待续）"></a>遍历算法的应用有（未完待续）</h5><ol><li><p>求二叉树中的节点个数</p></li><li><p>求二叉树的深度</p></li><li><p>前序遍历，中序遍历，后序遍历</p></li><li><p>分层遍历二叉树（按层次从上往下，从左往右）</p></li><li><p>将二叉  查找树变为有序的双向链表</p></li><li><p>求二叉树第K层的节点个数</p></li><li><p>求二叉树中叶子节点的个数</p></li><li><p>判断两棵二叉树是否结构相同</p></li><li><p>判断二叉树是不是平衡 二叉树</p></li><li><p>求二叉树的镜像</p></li><li><p>求二叉树中两个节点的最低公 共祖先节点</p></li><li><p>求二叉树中节点的最大距离</p></li><li><p>由前序遍历序列和中序遍历序列重建二叉树</p></li><li><p>判断二叉树是不是完全二叉树</p></li></ol><h4 id="3-3-4树与森林转换"><a href="#3-3-4树与森林转换" class="headerlink" title="3.3.4树与森林转换"></a>3.3.4树与森林转换</h4><h5 id="树转化为二叉树"><a href="#树转化为二叉树" class="headerlink" title="树转化为二叉树"></a>树转化为二叉树</h5><p>同父亲兄弟结点连接</p><p>对每一个非叶子结点只保留第一个孩子的链</p><p>树向左旋转45°</p><img src="https://s2.loli.net/2024/10/30/rkXcWSqaIHfowFl.jpg" alt="_20241030194756.png" style="zoom:50%;" /><h5 id="森林转化为二叉树"><a href="#森林转化为二叉树" class="headerlink" title="森林转化为二叉树"></a>森林转化为二叉树</h5><p>如果F &#x3D;{T, T.…, T} 是森林，则可按如下规则转换成一棵二叉树 B &#x3D;{root, LB, RB}。</p><p>(1)若F为空，则B为空树;<br>(2)若F非空，则B的根 root 为森林中第一棵树的根 Root(T,)，B 的左子树 LB 是从 T 中根结点的子树森林转换而成的二叉树;</p><img src="https://s2.loli.net/2024/10/30/lr5CuAz8E3NJoKT.jpg" alt="_20241030195119.png" style="zoom:50%;" /><h5 id="二叉树转换为树"><a href="#二叉树转换为树" class="headerlink" title="二叉树转换为树"></a>二叉树转换为树</h5><img src="https://s2.loli.net/2024/10/30/r4IweAzBRFfC52y.jpg" alt="_20241030195201.png" style="zoom:50%;" /><h5 id="二叉树转化为森林"><a href="#二叉树转化为森林" class="headerlink" title="二叉树转化为森林"></a>二叉树转化为森林</h5><p>如果 B &#x3D; {root, LB, RB}是一棵二叉树，则可按如下规则转换成森林 F &#x3D;{T,T,…, T…}<br>(1)若B为空，则F为空树;<br>(2)若B非空，则为森林中第一棵树的根 Root(T)即为 B的根 root， T 中根结点的子树森林是有 B 的左子树 LB 转换而来的森林;F 中除T, 之外的其余树组成的森林，是由 B的右子树转换而成的。</p><img src="https://s2.loli.net/2024/10/30/lGcMVYBqQixsNeK.jpg" alt="_20241030195338.png" style="zoom:50%;" /><h4 id="3-4-5-树和森林遍历"><a href="#3-4-5-树和森林遍历" class="headerlink" title="3.4.5 树和森林遍历"></a>3.4.5 树和森林遍历</h4><p>树的先根次序遍历：和先序遍历一样</p><p>树的后跟次序遍历：和后序遍历一样</p><p>树的广度优先遍历：和层序遍历一样</p><p>均可用二叉树中画圈的方法写出次序</p><p>森林的先根次序遍历：按树的顺序，先序遍历</p><p>森林的中根次序遍历：按树的顺序，中序遍历</p><p>森林的广度优先遍历：按树的顺序，层序遍历</p><h3 id="3-4-哈夫曼树与哈夫曼编码"><a href="#3-4-哈夫曼树与哈夫曼编码" class="headerlink" title="3.4 哈夫曼树与哈夫曼编码"></a>3.4 哈夫曼树与哈夫曼编码</h3><p>结点的路径长度：从根到此结点的路径分支数目</p><p>树的路径长度：树中每个结点的路径长度的和</p><p>树的带权路径长度：每个叶子的权重乘此叶子结点的路径长度的和</p><p>最优树就是寻找带权路径长度最短的树</p><h5 id="3-4-1-构造最优树"><a href="#3-4-1-构造最优树" class="headerlink" title="3.4.1 构造最优树"></a>3.4.1 构造最优树</h5><p>（1）给定n个权值W&#x3D;{w1,w2…wn}，构造n棵二叉树的集合F&#x3D;{T1,T2…Tn}，其中每棵树都是只含有权值为wi的根节点，左右子树都是空树。（最开始时是n个根）</p><p>（2）找出根节点权重最小的两棵树，将这两棵树分别作为第二层层左右子树，其双亲结点也就是根节点，是这两棵子树的根节点的权重之和。从F中删去这两棵树，并且添加进新树。</p><p>（3）重新进行（2）纸质F中只剩下一棵树。    （简直就是天才）</p><img src="https://s2.loli.net/2024/10/30/WSGxai7OFheB3gE.jpg" alt="_20241030200959.png" style="zoom:50%;" /><h5 id="3-4-2-哈夫曼编码"><a href="#3-4-2-哈夫曼编码" class="headerlink" title="3.4.2 哈夫曼编码"></a>3.4.2 哈夫曼编码</h5><p>在远程通讯中，要将字符串转化为二进制，为了转换效率与避免歧义，采用前缀编码；即任何一个字符的编码都不是另一个字符编码的前缀。可以用二叉树来设计，约定左分支是0，右分支是1，通过根节点到叶子节点的路径来规定编码，路径越少的字符为越常用的字符，这样可以提高效率。</p><p>构建哈夫曼编码，哈夫曼树每个结点的度都不为1，含有n个叶子结点的哈夫曼树共含有2n-1个结点。根据所给的字符及其对应的权重，通过构建哈夫曼树的原理，从叶子到根节点构建，规定左分支为0，右分支为1（不一定）。然后再从根节点到对应字符的路径读出编码。</p><img src="https://s2.loli.net/2024/10/30/hulp1We8TQx32rI.jpg" alt="_20241030202238.png" style="zoom:67%;" /><p>构造哈夫曼树的算法（未完待续）</p><h2 id="第四章-图（未施工）"><a href="#第四章-图（未施工）" class="headerlink" title="第四章 图（未施工）"></a>第四章 图（未施工）</h2><h2 id="第五章-搜索树"><a href="#第五章-搜索树" class="headerlink" title="第五章 搜索树"></a>第五章 搜索树</h2><h3 id="5-1-二叉搜索树"><a href="#5-1-二叉搜索树" class="headerlink" title="5.1 二叉搜索树"></a>5.1 二叉搜索树</h3><p>二叉搜索树（二叉排序树）满足如下条件：</p><p>​如果他的左子树不空，那么左子树上所有结点都小于根节点；如果他的右子树不空，那么他的右子树上所有结点都大于根节点 ；</p><p>​他的左右子树也都是二叉排序树。</p><p>即对于任何一个结点，如果他或者他的某个祖宗结点是其双亲结点的左结点，那么这个结点的值小于这个双亲结点；反之如果是右结点，那么这个结点的值大于这个双亲结点。</p><p>​<img src="https://s2.loli.net/2024/10/30/ZyBIPNhKln3Ykve.jpg" alt="_20241030203322.png" style="zoom:33%;" /></p><h4 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h4><img src="https://s2.loli.net/2024/10/30/yH9Iz1bTaV8N3XQ.jpg" alt="_20241030203438.png" style="zoom:33%;" /><p>对新来的数，与每层根节点比较，看自己该去左子树上还是右子树上，比他大的去右边，小的去左边。</p><p>输入的序列不同，构建的二叉排序树也不同</p><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>如果对一个二叉搜索树中序遍历，那么输出的值将从小到大排序（我验证过了，是真的）</p><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>如果定值等于根节点，查找成功；</p><p>如果定值小于根节点，进到左子树上找；</p><p>如果定值大于根节点，进到右子树上找；</p><p>如果最后指向了空树，查找失败。</p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>二叉搜索树的插入都插入在叶子结点上，其规则与构建二叉搜索树相同。</p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>应该保障删除后二叉排序树特性不变，且中序遍历结果仍然从小到大。</p><p>1）如果删除的是叶子结点，直接删</p><p>2）如果删除的结点只有左子树或者右子树，那么直接将左子树或者右子树的根节点替代被删除的结点即可</p><p>3）如果左右子树都不空：</p><p>①将删除结点的右子树，作为左子树最右结点的右子树，左子树根节点再代替删除节点。</p><p>（右派投奔左派，但是比左派中最右的还要右）</p><p>怎么判断是最右结点，我的建议是把图画清楚点，一眼就能看出来；理论上说，按从上到下遍历，第一个 是双亲结点的右子结点并且没有右子结点的结点就是最右结点。一般来说最右结点要么没有子结点，要么只有左子结点。（这个最右结点其实就是这棵树中的最大值）</p><p>②先将删除结点的左子树的最右结点代替删除结点； 如果这个最右结点有左子树，就将这个左子树替代这个结点；如果没有，就当作删除了个叶子结点。（同理也可以选择右子树的最左结点，即右子树的最小值，然后再将最左结点的右子树替代他，没有就算了）。</p><p>（用左中最大值替代，被替代的结点看作被删除，按前面的规律来）</p><h4 id="查找性能"><a href="#查找性能" class="headerlink" title="查找性能"></a>查找性能</h4><p>对于任一棵确定的二叉搜索树，按照他的平均查找长度ASL来定义其性能，每经过一个结点查找长度加一。</p><img src="https://s2.loli.net/2024/10/30/fz3aFQgKsLbdCyq.jpg" alt="_20241030211646.png" style="zoom: 50%;" /><p>二叉排序树的查找性能与折半查找差不多</p><p>二叉排序树的插入与删除更方便，无需移动太多结点，适用于动态查找环境。</p><h3 id="5-2-平衡二叉树（AVL树）"><a href="#5-2-平衡二叉树（AVL树）" class="headerlink" title="5.2 平衡二叉树（AVL树）"></a>5.2 平衡二叉树（AVL树）</h3><p>为了提高查找速度，避免最坏情况出现，我们要约束平衡性。</p><img src="https://s2.loli.net/2024/10/30/rJtuOeUZEsqhiNL.jpg" alt="_20241030212630.png" style="zoom:33%;" /><p>平衡因子：结点的平衡度是左子树高度减去右子树高度</p><p>平衡二叉树：左子树与右子树的高度差只能为+1，0，-1</p><p>​其左子树与右子树也是平衡二叉树。</p><p>平衡二叉树的平均查找长度为O(log2n)</p><h4 id="平衡"><a href="#平衡" class="headerlink" title="平衡"></a>平衡</h4><p>危机结点，平衡度不为0，再插入新结点可能会导致失衡的结点</p><p>关键：将导致出现危机结点的情况全部分析清楚，就可以使得平衡分类二叉树的性质保持不变！！</p><p>（太经典了，后面红黑树的平衡就是基于他的平衡操作）</p><h5 id="LL型"><a href="#LL型" class="headerlink" title="LL型"></a>LL型</h5><p>最低失衡点为A，如果在A的左子树B的左子树上插入新结点S后失衡。</p><p>此时应该让B做根节点位置，将A作为B的右子，B的右子作为A的左子。</p><p>（二换一，旧右补新右）</p><img src="https://s2.loli.net/2024/10/30/twUajHFgVW62f5Y.jpg" alt="_20241030213702.png" style="zoom: 50%;" /><h5 id="LR型"><a href="#LR型" class="headerlink" title="LR型"></a>LR型</h5><p>最低失衡点为A，如果在A的左子树B的右子树C上插入新结点S后失衡。</p><p>此时应该让C做根节点位置，B做C的左子（只保留B与左子链接），C原来的左子CL改为B的右子；A做C的右子（只保留右子链接），C原来的右子CR改为A的左子</p><p>（三层变一层，二变左，只剩左；一变右，只剩右；原三左补左，右补右）</p><img src="https://s2.loli.net/2024/10/30/rbDC5VFHX2yStKQ.jpg" alt="_20241030214713.png" style="zoom: 50%;" /><h5 id="RR型"><a href="#RR型" class="headerlink" title="RR型"></a>RR型</h5><p>最低失衡点为A，如果在A的右子树B的右子树上插入新结点S后失衡。</p><p>此时应该让B做根节点位置，将A作为B的左子，B的左子作为A的右子。</p><p>（二换一，旧左补新左）与LL型对称</p><img src="https://s2.loli.net/2024/10/30/nXWsYgzUMkCPJBv.jpg" alt="_20241030215241.png" style="zoom:50%;" /><h5 id="RL型"><a href="#RL型" class="headerlink" title="RL型"></a>RL型</h5><p>最低失衡点为A，如果在A的右子树B的左子树C上插入新结点S后失衡。</p><p>此时应该让C做根节点位置，B做C的右子（只保留B与右子链接），C原来的右子CR改为B的左子；A做C的左子（只保留左子链接），C原来的左子CL改为A的右子</p><p>（三层变一层，二变右，只剩右；一变左，只剩左；原三左补左，右补右）与LR型对称</p><img src="https://s2.loli.net/2024/10/30/alZIvXDVSBUK6EN.jpg" alt="_20241030215805.png" style="zoom:50%;" /><p>扩充二叉树<del>（没什么用）</del>（非常有用）</p><p>增加了外部节点用于替代树中的空子树</p><img src="https://s2.loli.net/2024/10/30/yC36tmnbEGBJvPs.jpg" alt="_20241030215909.png" style="zoom:33%;" /><h3 id="5-3-红黑树"><a href="#5-3-红黑树" class="headerlink" title="5.3 红黑树"></a>5.3 红黑树</h3><p>与AVL树对比：</p><p>AVL树要求完全平衡，过于严格，会影响性能</p><p>红黑树只要求局部平衡：懒汉平衡，不要求每个结点都必须平衡。</p><p>时间复杂度与AVL相同，统计性能比AVL树更好；任何不平衡都能在三次选择中解决；增删算法性能好、易于实现；减少了开销，性能几乎没有下降。</p><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>平衡的扩充二叉搜索树，且满足：</p><p>每个结点永远为黑色或红色</p><p>根节点永远为黑色</p><p>扩充的外部节点都是黑色的空结点，每个叶结点再补两个空黑色结点作为外部结点，或者有缺的结点也补一个。</p><p>红色结点的两个子结点都是黑色的，红色结点不能连续</p><p>对于某个结点，从该结点到其所有子孙叶结点的路径中包含的黑色结点数目必须相同</p><p>每个结点的结构体定义包括颜色指针。</p><h4 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h4><p>结点的阶：平衡性指标</p><p>为从这个结点到其子树中任意外部结点的任意一条路径上的黑色结点数量，不包括该结点本身，包括叶结点。</p><img src="https://s2.loli.net/2024/10/31/T84u6eqQjn2GxR1.jpg" alt="_20241031193443.png" style="zoom:50%;" /><p>外部结点的阶为零</p><p>根节点的阶就是树的阶</p><p>设r是红黑树的阶，h是红黑树的高（不包括外部结点），n是内部结点的个数<br>$$<br>r\leq h\leq 2r\<br>n\geq 2^r-1,最少是满二叉树\<br>h\leq 2\log_2{n+1}<br>$$<br>红黑树搜索插入的时间复杂度都为O(logn)</p><h4 id="插入（避免双红）："><a href="#插入（避免双红）：" class="headerlink" title="插入（避免双红）："></a>插入（避免双红）：</h4><p>先调用二叉排序树的插入算法，插入的地方为补充的外部结点，插入后再补上新的外部结点</p><p>把新结点着色为红色，如果父节点是黑色，就ok；</p><p>如果父亲结点是红色，进行双红调整：</p><p>（叔父结点：结点的父亲结点的兄弟结点）</p><h5 id="当叔父结点为黑色：XYb"><a href="#当叔父结点为黑色：XYb" class="headerlink" title="当叔父结点为黑色：XYb"></a>当叔父结点为黑色：XYb</h5><p>需要选择或同构，每个结点的阶保持原样。</p><h6 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h6><p>四种情况LLb，RRb，LRb，RLb</p><p>取双红结点以及新结点的祖父结点三者的中位数为新的根节点，并且着色为黑色。（另外两个均统一为红）</p><p>如果父结点为中位数，按照AVL树LL，RR情况旋转</p><p>如果新结点为中位数，按照AVL树LR，RL情况旋转</p><img src="https://s2.loli.net/2024/10/31/gRN3DB1HwfMGntr.jpg" alt="_20241031200026.png" style="zoom:50%;" /><h5 id="当叔父结点为红色：XYr"><a href="#当叔父结点为红色：XYr" class="headerlink" title="当叔父结点为红色：XYr"></a>当叔父结点为红色：XYr</h5><p>需要换色，换色后继续检查平衡</p><h6 id="换色"><a href="#换色" class="headerlink" title="换色"></a>换色</h6><p>四种情况：LLr，RRr，LRr，RLr</p><p>先父祖换色，将新结点的父亲结点与叔父结点改为黑色，祖父结点改为红色；（相当于父亲辈与祖父换颜色）再分析祖父结点是否存在双红现象，在判断是XYb还是XYr类型进行平衡。</p><img src="https://s2.loli.net/2024/10/31/JwWf9QUG2YOiqzN.jpg" alt="_20241031200745.png" style="zoom:50%;" /><img src="https://s2.loli.net/2024/10/31/H9kNfdU853OV6Xe.jpg" alt="_20241031200807.png" style="zoom:50%;" /><img src="https://s2.loli.net/2024/10/31/2f8WYE3w9jnsIRD.jpg" alt="_20241031200844.png" style="zoom:50%;" /><p>先按二叉排序树插入，再看插入新结点的父结点是否为红色：</p><p>​如果是黑色，没问题</p><p>​如果是红色，看他的叔父结点是否为红色</p><p>​如果是黑色，移动双红结点以及祖父结点，找中位数</p><p>​中位数是二层，单旋转，中位数结点为黑色，其他两个为红色</p><p>​中位数是三层，双旋转，中位数结点为黑色，其他两个为红色</p><p>​如果是红色，叔父、父结点与祖父换色，再分析祖父结点是否双红，双红结点传递给祖父结点。</p><h4 id="删除："><a href="#删除：" class="headerlink" title="删除："></a>删除：</h4><h6 id="先进行平衡二叉树（BTS）删除的算法："><a href="#先进行平衡二叉树（BTS）删除的算法：" class="headerlink" title="先进行平衡二叉树（BTS）删除的算法："></a>先进行平衡二叉树（BTS）删除的算法：</h6><p>如果被删除的结点有一个或者两个外部结点，直接删除（就是平衡二叉树删除的前两种情况）</p><p>如果有两个非叶子结点，则在右子树中找到最小值结点，与这个结点交换，颜色不变（不变的是结点自身带的颜色，不是这个位置的颜色）。__删除的结点就传递到这个最小值结点，由此传递下来，任何一个删除操作，最终都会传递为删除一个有一个或两个外部结点的情况。__因此只需对这种情况进行分析。</p><h6 id="双黑概念："><a href="#双黑概念：" class="headerlink" title="双黑概念："></a>双黑概念：</h6><p>当删除的结点为黑色，代替他的结点也为黑色，那么这个子节点就会被标记为双黑。</p><img src="https://s2.loli.net/2024/10/31/WdxS3fAwCVHO9ls.jpg" alt="_20241031204312.png" style="zoom:50%;" /><p>我们要在删除完结点后解决双黑不平衡问题</p><p>以双黑结点是删除结点的左子结点为例（右子结点情况对称过来即可）</p><p>有三种情况：</p><h6 id="双黑结点兄弟是黑的，兄弟结点的子节点右红色"><a href="#双黑结点兄弟是黑的，兄弟结点的子节点右红色" class="headerlink" title="双黑结点兄弟是黑的，兄弟结点的子节点右红色"></a><b>双黑结点兄弟是黑的，兄弟结点的子节点右红色</b></h6><p><em>第一种：双黑结点与他的红色侄子八字形外撇，离着远</em></p><p>单旋转调整：兄弟结点C提上去，继承原来父结点的颜色；父结点与红色侄子结点都改为黑色。</p><p>（其实就是AVL二叉树LL型与RR型的旋转操作，甚至连对应的位置都一样）（别忘了颜色变化）</p><img src="https://s2.loli.net/2024/10/31/azWeMcjZGmtybvi.jpg" alt="_20241031205159.png" style="zoom:50%;" /><p><em>第二种：双黑结点与他的红色侄子同边顺，就是离着近</em></p><p>双旋转调整：侄子结点提上去，继承原来父结点的颜色；父结点改为黑色。</p><p>（还真是AVL二叉树LR型RL型的旋转操作，位置情况都一样）（改的色就是把侄子继承父结点颜色，父结点改为黑色）</p><img src="https://s2.loli.net/2024/10/31/EtFP69A7hdk2NnV.jpg" alt="_20241031205815.png" style="zoom:50%;" /><h6 id="双黑结点兄弟结点是黑的，且兄弟有两个黑色子节点"><a href="#双黑结点兄弟结点是黑的，且兄弟有两个黑色子节点" class="headerlink" title="双黑结点兄弟结点是黑的，且兄弟有两个黑色子节点"></a>双黑结点兄弟结点是黑的，且兄弟有两个黑色子节点</h6><p><em>第一种：如果双黑结点的父结点是红色</em></p><p>只需将双黑结点的兄弟结点改为红色，父结点改为黑色即可</p><img src="https://s2.loli.net/2024/10/31/tMdiKZBxQfD6vEs.jpg" alt="_20241031210838.png" style="zoom:67%;" /><p><em>第二种：如果双黑结点的父结点为黑色</em></p><p>把兄弟结点改为红色，双黑结点传递到父结点，对父结点再进行去双黑处理。（开始递归了）</p><h6 id="双黑结点的兄弟结点是红色"><a href="#双黑结点的兄弟结点是红色" class="headerlink" title="双黑结点的兄弟结点是红色"></a>双黑结点的兄弟结点是红色</h6><p>直接一个单旋转转变为情况1 或情况2</p><p>注意转完后把原父结点改色为红色，这个兄弟结点改色为黑色。但是双黑结点不变，还是他。</p><img src="https://s2.loli.net/2024/10/31/zqF9M7UYGwAkxXc.jpg" alt="_20241031211552.png" style="zoom: 50%;" /><p>先看是不是双黑，再看双黑的兄弟是不是黑，</p><p>​如果是红，单旋转再判断；如果是黑，看有没有红色儿子，</p><p>​如果没有，看父结点是不是红的：</p><p>​如果是，就父祖换色；如果不是就兄弟改红，双黑传递到父结点</p><p>​如果有，看侄子结点是靠近双黑还是远离双黑；</p><p>​（与AVL单旋转一样）如果远离就单旋转，二变一，兄弟继承父结点颜色，父结点和红侄子变黑</p><p>​（与AVL双旋转一样）如果靠近就双旋转，三变一，侄子继承父结点颜色，父结点变黑</p><p>红黑树平均和最差检索的时间复杂度O（log2 n）</p><h3 id="5-4-B-树"><a href="#5-4-B-树" class="headerlink" title="5.4 B-树"></a>5.4 B-树</h3><p>二叉搜索树只适合内存中组织较少的索引，对于存放在外存中较大的文件系统，引入高度数搜索树。</p><p>（在面对特别复杂的文件系统中，二叉搜索树往往不能胜任，因此要引入更高度数的搜索树。）</p><h4 id="5-4-1-索引顺序访问方法"><a href="#5-4-1-索引顺序访问方法" class="headerlink" title="5.4.1 索引顺序访问方法"></a>5.4.1 索引顺序访问方法</h4><p>建立顺序表时建立一个索引项，包括两项：关键字项和指针项</p><p>其中索引项按关键字有序，顺序表分块有序</p><p>将表分成若干块，这个块里的最大值作为索引表对应位置的关键字，索引表对应位置指针指向所在块的第一位，在索引表上，这些块上的最大值呈现有序排列。</p><img src="https://s2.loli.net/2024/11/01/eZX5zhOPNWJEoYg.jpg" alt="_20241101123308.png" style="zoom:50%;" /><h5 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h5><p>将表分成几块，块内无序，块间有序。先确定待查记录所在块，再在块内查找。（有点像概统的分布函数）</p><img src="https://s2.loli.net/2024/11/01/gAL19sNSBal8mD6.jpg" alt="_20241101123548.png" style="zoom:50%;" /><h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><p>磁盘的顺序索引访问方法：</p><p>数据组织形式：磁盘空间被分成很多块，字典元素以升序存储在块中。</p><p>顺序访问：依次在每个块中按升序访问元素。</p><p>随机访问：建立索引表，索引中关键值数量与块数相同，包含每个块的最大关键值。对于任意要访问的值先找到包含这个块的索引，再在块内遍历即可</p><p>跨磁盘字典存储模式：不仅每个磁盘中有块索引，还有磁盘索引，保存了磁盘中的最大值。要访问值时按磁盘索引找到在哪个磁盘，再按磁盘中的块索引找到在哪个块，再遍历。</p><p>优点是索引快，缺点是插入和删除时在块之间移动元素代价高。</p><p>二叉搜索树只适合内存中组织较少的索引，对于存放在外存中较大的文件系统，引入高度数搜索树</p><h4 id="5-4-2-m叉搜索树"><a href="#5-4-2-m叉搜索树" class="headerlink" title="5.4.2 m叉搜索树"></a>5.4.2 m叉搜索树</h4><p>1）每个结点最多可以含有m个子女和（m-1）个元素，外部结点不含元素和子女（一个结点可以含有多个元素）</p><p>2）每个含有p个元素的结点，含有p+1个子女，（子女中有多少个元素不管）</p><p>3）设k1…kp是p个元素的关键值，有k1&lt;k2&lt;…&lt;kp；c0…cp是起p+1个子女</p><p>​c0为根的子树中的元素的关键值都小于k1</p><p>​cp为根的子树中的元素的关键值都大于kp</p><p>​以ci为根的子树中的元素的关键值大于ki小于ki+1</p><img src="https://s2.loli.net/2024/11/01/Q1gnHNLcXUJG4im.jpg" alt="_20241101130523.png" style="zoom:50%;" /><p>(太棒了这个图画的，子女结点穿插在父结点元素之间，正好展现出对应子结点元素值处在两个父结点元素间的情况)</p><p>（这么一看二叉搜索树真是m叉搜索树最简单一种情况）</p><h5 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h5><img src="https://s2.loli.net/2024/11/01/TwaYsnfOGxBPlSR.jpg" alt="_20241101131511.png" style="zoom: 67%;" /><p>一层层夹出来</p><h5 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h5><img src="https://s2.loli.net/2024/11/01/v1yNkUz5gLhqZTs.jpg" alt="_20241101131807.png" style="zoom: 67%;" /><p>一层层向下顺延对比</p><h5 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h5><p>找到已有节点，直接删除对应元素</p><p>如果这个节点只有一个元素，那么就在其非空相邻子树中找到一个对应的最大或者最小值代替，如果没子树，删了就删了。</p><img src="https://s2.loli.net/2024/11/01/Ezw1cfR46VULZhY.jpg" alt="_20241101132812.png" style="zoom:67%;" /><h5 id="高度"><a href="#高度" class="headerlink" title="高度"></a>高度</h5><p>一棵高度为h的m叉搜索树最少有j个元素，最多有$$m^h-1$$个元素；</p><p>一棵结点树为n的m叉搜索树高度在$$log_m(n+1)$$到n之间；</p><p>m叉平衡搜索树确保高度值接近$$log_m(n+1)$$</p><p>m叉平衡搜索树有上限，无下限。</p><h4 id="5-4-3-m序-B-树"><a href="#5-4-3-m序-B-树" class="headerlink" title="5.4.3 m序 B-树"></a>5.4.3 m序 B-树</h4><p>m序B-树是一棵m叉搜索树，满足</p><p>1）根节点至少有两个孩子</p><p>2）除了根节点外，所有内部节点至少有$$ [\frac{m}{2}]+1$$个孩子（注意是孩子节点的个数，不要和元素个数搞混）</p><p>这就说明了每个节点包含的元素树$$[m&#x2F;2]\leq k\leq m-1$$，例如7序的内部节点元素数为3~6。</p><p>3）所有外部节点处在同一层上。</p><img src="https://s2.loli.net/2024/11/01/buze5AGXfV1o98M.jpg" alt="_20241101134218.png" style="zoom:67%;" /><p>B-树非叶子结点的结构，指针与元素穿插排列</p><img src="https://s2.loli.net/2024/11/01/ZAsju1UyCnNQD79.jpg" alt="_20241101134306.png" style="zoom:50%;" /><p>B-树的美德：（应该不考）</p><img src="https://s2.loli.net/2024/11/01/PHCOcKsGy7SdZFm.jpg" alt="_20241101134915.png" style="zoom:50%;" /><p>B-树的例子</p><img src="https://s2.loli.net/2024/11/01/Y9GQD1V5EkiqWHp.jpg" alt="_20241101135148.png" style="zoom:50%;" /><p>特殊的B-树</p><p>二序B-树：一棵满二叉树</p><p>三序B-树：内部节点可以有2或3个孩子，称23树</p><p>四序B-树：内部节点可以有2或3或4个孩子，称234树</p><h4 id="5-4-4-B-树的高度"><a href="#5-4-4-B-树的高度" class="headerlink" title="5.4.4 B-树的高度"></a>5.4.4 B-树的高度</h4><p>设T是一棵高度为h的m序B-树，d&#x3D;[m&#x2F;2]+1（比如是5序，d&#x3D;[5&#x2F;2]+1&#x3D;3）且n是T中的元素个数，则有</p><p>$$2d^{h-1}-1 \leq n \leq m^h-1$$</p><p>$$ log_m(n+1)\leq h\leq log_d(\frac{n+1}{2})+1$$</p><p>一棵高度为3的200序B-树至少可存放$$2\times 100^2-1$$个元素。2层5序B-树，至少有$$2\times 3^1-1&#x3D;5$$个元素</p><p>3层5序B-树，至少有$$2\times 3^2-1&#x3D;17$$个元素</p><p>B-树的搜索与m叉搜索树的应用，磁盘访问次数最多是(高度)h。</p><h4 id="5-4-5-B-树的插入"><a href="#5-4-5-B-树的插入" class="headerlink" title="5.4.5 B-树的插入"></a>5.4.5 B-树的插入</h4><p>先要检查是否有相同值存在，B-树不允许重复值存在。</p><h5 id="5-4-5-1-如果插入的节点没有饱和，直接插入"><a href="#5-4-5-1-如果插入的节点没有饱和，直接插入" class="headerlink" title="5.4.5.1 如果插入的节点没有饱和，直接插入"></a>5.4.5.1 如果插入的节点没有饱和，直接插入</h5><p>按照m叉搜索树插入</p><h5 id="5-4-5-2-如果插入的节点已经饱和，即原来元素数已经达到了m-1，需要分裂节点"><a href="#5-4-5-2-如果插入的节点已经饱和，即原来元素数已经达到了m-1，需要分裂节点" class="headerlink" title="5.4.5.2 如果插入的节点已经饱和，即原来元素数已经达到了m-1，需要分裂节点"></a>5.4.5.2 如果插入的节点已经饱和，即原来元素数已经达到了m-1，需要分裂节点</h5><p>设P是饱和节点，把新元素插进去，得到一个有m个元素和m+1和孩子的溢出节点</p><p>对于新得到的溢出节点，</p><p>如果m是奇数，那么这m个元素有一个中位数，左右可均分，把这个中位数插入到父结点中，中位数左边的作为左子节点，右边的作为右子节点（别忘了分成两个节点，别只移走数就不管了）。</p><p>如果m是偶数，那么这m个元素的中位数将是个指针，不用移出数就能均分，直接均分，不必再向父结点插入新数。</p><img src="https://s2.loli.net/2024/11/01/129QXaiwN6P7yBA.jpg" alt="_20241101142829.png" style="zoom:50%;" /><p>插入后再观察父结点是否变为溢出节点，如果是继续分裂，不是就算了。</p><img src="https://s2.loli.net/2024/11/01/TUBgLEVSZtr2J8k.jpg" alt="_20241101142939.png" style="zoom:50%;" /><p>当插入引起了s个节点的分类，磁盘访问次数变为h（读搜索路径）+2s（回写两个新节点）+1（回写新的根节点）&#x3D;h+2s+1次</p><p>最多可达3h+1次（s&#x3D;h）</p><h5 id="5-4-5-3-B-树的生长过程"><a href="#5-4-5-3-B-树的生长过程" class="headerlink" title="5.4.5.3 B-树的生长过程"></a>5.4.5.3 B-树的生长过程</h5><img src="https://s2.loli.net/2024/11/01/ctGZsWgrSnQl2X1.jpg" alt="_20241101143457.png" style="zoom: 67%;" /><p>先按m叉搜索树那么插入，看看插入的结点是否饱和</p><p>​没饱和，直接插入。</p><p>​饱和了，看插入过后结点含有的元素数目m是奇数还是偶数</p><p>​是奇数，取出溢出结点的中位数插入父结点相应位置，两侧均分为左子节点和右子节点。看父结点插入后是否溢出</p><p>​是偶数，直接均分，裂开分成左子节点与右子节点。</p><h4 id="5-4-6-B-树的删除"><a href="#5-4-6-B-树的删除" class="headerlink" title="5.4.6 B-树的删除"></a>5.4.6 B-树的删除</h4><p> 删除元素的节点孩子都为外部结点，也就是叶结点</p><p>删除元素在非叶子节点上，可以用该元素的左相邻子树最大元素或者右相邻子树的最小元素来替代，这样就把删除传递给其子树上，都转化为删除叶子节点的问题。</p><h5 id="5-4-6-1-当这个叶节点的元素数目大于-m-2-，也就是允许的最小数目"><a href="#5-4-6-1-当这个叶节点的元素数目大于-m-2-，也就是允许的最小数目" class="headerlink" title="5.4.6.1 当这个叶节点的元素数目大于[m&#x2F;2]，也就是允许的最小数目"></a>5.4.6.1 当这个叶节点的元素数目大于[m&#x2F;2]，也就是允许的最小数目</h5><p>直接删就行，删完了再写回去</p><h5 id="5-4-6-2-当这个叶节点元素数目等于允许的最小数目，但是兄弟至少有一个不是"><a href="#5-4-6-2-当这个叶节点元素数目等于允许的最小数目，但是兄弟至少有一个不是" class="headerlink" title="5.4.6.2 当这个叶节点元素数目等于允许的最小数目，但是兄弟至少有一个不是"></a>5.4.6.2 当这个叶节点元素数目等于允许的最小数目，但是兄弟至少有一个不是</h5><p>可以从左右相邻兄弟节点中取出一个元素来替代他。注意选取的节点包含的元素数应该大于[m&#x2F;2]。</p><p> 调整步骤：如果是取的左兄弟的元素</p><p>1）将双亲结点中刚好小于删除值的元素移下来；</p><p>2）把左兄弟中最大值元素移上去补位；</p><p>3）左兄弟结点中最右侧的指针（孤单的指针）移动到被删除值的结点最左侧子树指针；</p><p>4）再调整其左兄弟节点指针，并且其元素数-1。</p><p>如果取得是右兄弟指针，左右大小对称操作就行。（就近补位：就是在左兄弟中找最右的，右兄弟中找最左的）</p><p>​ <img src="https://s2.loli.net/2024/11/01/XT1ofFJn7gwMGeR.jpg" alt="_20241101150211.png" style="zoom:50%;" /></p><img src="https://s2.loli.net/2024/11/01/dwLvXst6cjBAGT9.jpg" alt="_20241101150415.png" style="zoom:50%;" /><h5 id="5-4-6-3-当这个节点元素数目达到最低，相邻兄弟也是最低"><a href="#5-4-6-3-当这个节点元素数目达到最低，相邻兄弟也是最低" class="headerlink" title="5.4.6.3 当这个节点元素数目达到最低，相邻兄弟也是最低"></a>5.4.6.3 当这个节点元素数目达到最低，相邻兄弟也是最低</h5><p>选定一个相邻兄弟，把删除元素结点与这个兄弟节点之夹的父结点上的元素拉下来，这几个元素合并成一个新结点。这时把删除节点问题传递给了父结点，如果父结点本来也是最小数目，那么再看父结点的相邻兄弟节点有没有救济的，进行移动或者再合并。</p><p>这种一层层的传递最终可能会传到根结点那里。注意到非叶结点的移动，指针的跟随与平移。</p><p>注意合并后的指针到了谁与谁之间，相邻兄弟救济时，兄弟的指针跟随过来。</p><p>指针的位置可以根据子树与值的关系来判断</p><img src="https://s2.loli.net/2024/11/01/jbT8pDygV9Nolzx.jpg" alt="_20241101151327.png" style="zoom:50%;" /><img src="https://s2.loli.net/2024/11/01/EPw7jhrM1Y3T2JO.jpg" alt="_20241101151354.png" style="zoom:50%;" /><p>如果一直传递到根节点且把根节点拉成不含关键值的了，那么就删除原来根节点，合并后的根节点作为新的根节点。</p><img src="https://s2.loli.net/2024/11/01/TGDZp6neJc1tmFA.jpg" alt="_20241101152029.png" style="zoom:50%;" /><p>移动时就跟拼积木一样，该是谁夹谁的指针，改了之后相对位置也不变</p><p>最坏情况：波及到根节点，高度之间少了一层</p><img src="https://s2.loli.net/2024/11/01/N8wW3ufjxc2syai.jpg" alt="_20241101152334.png" style="zoom:50%;" /><img src="https://s2.loli.net/2024/11/01/usGj6KXg2Ncl4rk.jpg" alt="_20241101152356.png" style="zoom:50%;" /><p>先看删除的是否为叶节点，</p><p>​不是，用这个元素的左相邻子树上最大元素或者右相邻子树上最小元素替代，删除操作传递到子树上，直到传到叶结点。</p><p>​是，看这个节点元素数目是否大于允许的最小元素数[m&#x2F;2]</p><p>​大于，直接删就行</p><p>​恰好等于，看看这个节点左右相邻兄弟是否存在元素数目大于[m&#x2F;2]的。</p><p>​存在，看看这位好兄弟是左兄弟还是右兄弟：</p><p>​左兄弟，父结点中恰好小于删除值的元素移下来，左兄弟的最大值移上去。</p><p>​右兄弟，父结点中恰好大于删除值的元素移下来，右兄弟的最小值移上去。</p><p>​不存在，随机挑一个相邻好兄弟，把这个节点与相邻兄弟节点之间夹的父结点上的元素拉下来合并成一个全新节点，删除问题就传递给了父结点。</p><p>一定要注意挪动元素时对应的指针跟随移动。</p><h4 id="5-4-7-B-树和B-树"><a href="#5-4-7-B-树和B-树" class="headerlink" title="5.4.7 B+树和B*树"></a>5.4.7 B+树和B*树</h4><h5 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h5><p>B+树是B-树的一种变形</p><p>B+树基本定义与B-树一样。区别有：</p><p>1）B+树非叶子节点的关键值数目与指针数目一样，关键值ki对应的子树的值满足$$k_i\leq e&lt; k_{i+1}$$</p><p>2）给所有叶子节点加了一个链指针</p><p>3）所有关键字都在叶子节点出现</p><img src="https://s2.loli.net/2024/11/01/dBNAfcJZGIlhMUQ.jpg" alt="_20241101160113.png" style="zoom:50%;" /><p>特性：</p><p>1）所有关键字都在叶子节点的链表中（稠密索引），且恰好是有序的</p><p>2）不可能出出现在非叶子节点</p><p>3）非叶子节点相当于叶子节点的索引（稀疏索引），叶子节点是数据层</p><p>4）更适合文件管理系统，比如mysql数据库</p><h5 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h5><p>在B+树的基础上，非根非叶子结点再加一个指向兄弟的指针，增加空间利用率。</p><img src="https://s2.loli.net/2024/11/01/vdVRnHPf3UA94kG.jpg" alt="_20241101160618.png" style="zoom:50%;" /><h5 id="对比："><a href="#对比：" class="headerlink" title="对比："></a>对比：</h5><p>B树：二叉搜索树，每个结点只存一个关键字，等于就是命中，小于走左，大于走右</p><p>B-树：多路搜索树，每个结点存[m&#x2F;2]到m-1个关键字。非叶子结点指针指向范围，相当于判断区间层层收缩，最终锁定到最小区间，性能更好。非叶子节点可以命中</p><p>B+树：在B-树基础上，为叶子增加链表指针，只能在叶子节点命中，非叶子节点为叶子节点的索引</p><p>B*树：在B+树基础上，为非叶子节点增加指向兄弟的链表指针，提高节点利用率。</p><h2 id="第六章-查找与排序"><a href="#第六章-查找与排序" class="headerlink" title="第六章 查找与排序"></a>第六章 查找与排序</h2><h3 id="6-1-查找"><a href="#6-1-查找" class="headerlink" title="6.1 查找"></a>6.1 查找</h3><p>关键字：每个对象有若干属性，其中有一个属性，能够唯一的标识这个对象，称为关键字。使用基于关键字的搜索，查找结果是唯一的。</p><h4 id="6-1-1-顺序查找"><a href="#6-1-1-顺序查找" class="headerlink" title="6.1.1 顺序查找"></a>6.1.1 顺序查找</h4><p>依次遍历对比。</p><p>查找算法的平均查找长度ASL：给定值进行关键字比较的次数的期望</p><p>顺序查找时间复杂度O(n)</p><p>查找长度：</p><p>​成功：最少比较次数1，最多比较次数n，平均比较次数（n+1）&#x2F;2</p><p>​失败：最少比较次数n，最多比较次数n，平均比较次数n</p><p>算法简单，但是效率太低了</p><h4 id="6-1-2-折半查找（二分查找）"><a href="#6-1-2-折半查找（二分查找）" class="headerlink" title="6.1.2 折半查找（二分查找）"></a>6.1.2 折半查找（二分查找）</h4><p>如果静态查找表是有序表，可以进行折半查找</p><p>每次先求出查找区间正中对象的下标mid，用其关键字与给定值x比较，然后根据比较结果将查找区间缩小一半，直到找到查找对象。</p><p>假设是升序：</p><p>x&#x3D;MID，成功；x&lt;MID，区间缩小为前半部分；x&gt;MID， 区间缩小为后半部分。</p><img src="https://s2.loli.net/2024/11/01/59s1DFNBvXWgEal.jpg" alt="_20241101164911.png" style="zoom:50%;" /><p>查找成功：$$ASL_{suss}&#x3D;\frac{n+1}{n}log_2(n+1)-1$$</p><p>时间复杂度$$O(log_2n)$$</p><p>查找效率高，但是查找结构有限制，插入删除操作困难。</p><h4 id="6-1-3-二叉搜索树"><a href="#6-1-3-二叉搜索树" class="headerlink" title="6.1.3 二叉搜索树"></a>6.1.3 二叉搜索树</h4><p>二叉搜索树，平衡二叉树，B-树 都看上一章的搜索树</p><p>二叉搜索树，平衡二叉树其时间复杂度都是$$O(log_2n)$$</p><p>B-树时间复杂度是$$O(log_mn)$$</p><h3 id="6-2-哈希表"><a href="#6-2-哈希表" class="headerlink" title="6.2 哈希表"></a>6.2 哈希表</h3><p>哈希查找根本思想：在记录的存储地址和它的关键字之间建立一个确定的对应关系，不用经过比较，一次存取就能读出。</p><p>哈希函数：在记录的关键词与关键字的位置之间建立一个函数关系，以f(key)作为关键字key的位置。称f为哈希函数</p><p>哈希地址：由哈希函数求出的记录存储位置称为哈希地址，表示成addr(ai)&#x3D;f(ki)</p><p>ai是表中的一个元素(记录)；addr（ai）是ai的存储地址；ki是ai的关键字</p><p>哈希表：应用哈希函数，由记录的关键字确定记录在表中的地址，并将记录放入此地址，这样的表叫做哈希表（散列表）</p><p>哈希查找：又叫散列查找，利用哈希函数进行查找的过程</p><p>哈希函数是一个从关键字集合到一个地址集合的映射</p><p>由于哈希函数是一个压缩映像，一般情况下，很容易产生冲突现象。即f(key1)&#x3D;f(key2)</p><p>很难找到一个不冲突的哈希函数，只能尽量减少冲突或者冲突时解决它。</p><h4 id="6-2-1-构造哈希函数的几种方法"><a href="#6-2-1-构造哈希函数的几种方法" class="headerlink" title="6.2.1 构造哈希函数的几种方法"></a>6.2.1 构造哈希函数的几种方法</h4><p>有 直接定址法，数字分析法，平方取中法，折叠法，除留余数法，随机数法</p><p>如果是非数字关键字，要先对其进行数字化处理</p><h5 id="6-2-1-1-直接定址法"><a href="#6-2-1-1-直接定址法" class="headerlink" title="6.2.1.1 直接定址法"></a>6.2.1.1 直接定址法</h5><p>构造：取关键字或者关键字的某个线性函数作为哈希函数<br>$$<br>H(key)&#x3D;key\<br>或者 H(key)&#x3D;a\times key+b<br>$$<br>特点：直接定址法所得的地址集合与关键字集合大小相等，不会发生冲突。</p><p>实际能用这种哈希函数的情况很少。</p><h5 id="6-2-1-2-数字分析法"><a href="#6-2-1-2-数字分析法" class="headerlink" title="6.2.1.2 数字分析法"></a>6.2.1.2 数字分析法</h5><p>构造：对关键字进行分析，取关键字的若干位或其组合作哈希函数</p><p>特点：适于关键字位数比哈希地址位数大的，且可能出现的关键字事先知道的情况</p><h5 id="6-2-1-3-平方取中法"><a href="#6-2-1-3-平方取中法" class="headerlink" title="6.2.1.3 平方取中法"></a>6.2.1.3 平方取中法</h5><p>构造：以关键字的平方值的中间几位作为存储地址。求关键字的平方值的目的是扩大差别，同时平方值的中间各位又能受到整个关键字中各位的影响</p><p>特点：关键字中的每一位都有某些数字重复出现频度很高的情况</p><h5 id="6-2-1-4-折叠法"><a href="#6-2-1-4-折叠法" class="headerlink" title="6.2.1.4 折叠法"></a>6.2.1.4 折叠法</h5><p>构造：将关键字分割成位数相同的几部分，然后取这几部分的叠加和（舍去进位）作为哈希地址。</p><p>种类：</p><p>移位叠加：将分割后的几部分低位对齐相加</p><p>间界叠加：从一端沿分割界来回折送，然后对齐相加。</p><p>特点：适于关键字位数很多，且每一位上数字分布大致均匀的情况</p><img src="https://s2.loli.net/2024/11/01/frgu9XUnV2kzS83.jpg" alt="_20241101182107.png" style="zoom: 67%;" /><p>移位：按哈希位数分关键字，右对齐相加，再去后面所需位数</p><p>间界：一条龙从最右端开始，右到左，拐过来到右，再拐回去。</p><h5 id="6-1-2-5-除留余数法"><a href="#6-1-2-5-除留余数法" class="headerlink" title="6.1.2.5 除留余数法"></a>6.1.2.5 除留余数法</h5><p>构造：取关键字被某个不大于哈希表表长m的数p除后得到的余数作哈希地址。</p><p>即H（key）&#x3D;key%p</p><p>p&lt;&#x3D;m且p一般应为接近m的素数或是不含20以下的质因子</p><p>特点：简单、常用：可以与上述几种方法结合使用</p><p>​    p的选取很重要，p选的不好会产生同义词</p><img src="https://s2.loli.net/2024/11/01/Y4lquhZm5AejCxa.jpg" alt="_20241101183300.png" style="zoom:50%;" /><h5 id="6-1-2-6-随机数法"><a href="#6-1-2-6-随机数法" class="headerlink" title="6.1.2.6 随机数法"></a>6.1.2.6 随机数法</h5><p>构造：取关键字的随机函数值作哈希地址H（key）&#x3D;random（key）</p><p>适用于关键字长度不等的情况</p><p>实际造表时，采用何种构造哈希函数的方法取决于建表的关键字集合的情况(包括关键字的范围和形态)，总的原则是使产生冲突的可能性降到尽可能地小。</p><img src="https://s2.loli.net/2024/11/01/7I1acEqDKGgzJvs.jpg" alt="_20241101183737.png" style="zoom:50%;" /><h4 id="6-2-2-处理冲突的方法"><a href="#6-2-2-处理冲突的方法" class="headerlink" title="6.2.2 处理冲突的方法"></a>6.2.2 处理冲突的方法</h4><p>为产生冲突的地址寻找下一个哈希地址。</p><p>两种方法：开放定址法，链地址法。</p><h5 id="6-2-2-1-开放定址法"><a href="#6-2-2-1-开放定址法" class="headerlink" title="6.2.2.1 开放定址法"></a>6.2.2.1 开放定址法</h5><p>思想：为产生冲突的关键字寻找一个新的地址Hi(key)，求得一个地址序列：</p><p>m是表长。<br>$$<br>H_0,H_1,…,H_S \ \ \ \ \ \ 1\leq s\leq m-1\<br>其中：H_0&#x3D;H(key) \<br>H_1&#x3D;(H(key)+d_1) % m\<br>H_2&#x3D;(H(key)+d2)% m\<br>…\<br>H_i&#x3D;(H(key)+d_i)%m\<br>i&#x3D;1,2,…,s<br>$$<br>就是对冲突地址加一个增量再对表长取余数（其实就是用不同的方式挪到表的其他位置，再看是否冲突）</p><p>其中增量di的取值有三种取法：</p><p>线性探测再散列：$$d_i&#x3D;1,2,3,…,m-1$$，相当于从原冲突地址位数开始，向正方向一个个遍历看是否冲突，到底的时候再从开头遍历。</p><p>二次探测再散列：$$d_i&#x3D;1^2,-1^2,2^2,-2^2,…,k^2,-k^2$$,相当于向前看一位，向后看一位，再向前看4位，向后看4位等等。</p><p>伪随机探测再散列：$$d_i&#x3D;$$伪随机数列</p><p>增量di应该具有完备性，即产生的Hi均不相等，且所产生的s个Hi值能覆盖哈希表中所有地址。</p><p>要求平方探测时的表长m必须为形如4j+3的素数，如7，11，19，23等等。</p><p>随机探测时m和di没有公因子。</p><img src="https://s2.loli.net/2024/11/01/2GIb9SCTdO4MFnl.jpg" alt="_20241101190511.png" style="zoom: 67%;" /><h5 id="6-2-2-2-链地址法"><a href="#6-2-2-2-链地址法" class="headerlink" title="6.2.2.2 链地址法"></a>6.2.2.2 链地址法</h5><p>将所有哈希地址相同的记录都链接在同一链表中</p><img src="https://s2.loli.net/2024/11/01/f3Ptpv9rLHYVa4z.jpg" alt="_20241101190802.png" style="zoom:67%;" /><h4 id="6-2-3-查找方法"><a href="#6-2-3-查找方法" class="headerlink" title="6.2.3 查找方法"></a>6.2.3 查找方法</h4><p>查找过程与造表过程一致，对于给定值，由哈希函数和解决冲突的方法定位记录的存储位置</p><img src="https://s2.loli.net/2024/11/01/yQUNhoxFP2fMHOg.jpg" alt="_20241101191121.png" style="zoom:67%;" /><p>一个实例：（注意图中的哈希表的地址没对应好，只看文字就行）</p><img src="https://s2.loli.net/2024/11/01/pljqX5TRt6VQZ8h.jpg" alt="_20241101191401.png" style="zoom:50%;" /><img src="https://s2.loli.net/2024/11/01/DPKf3u5tTv72z1M.jpg" alt="_20241101191600.png" style="zoom:50%;" /><p>哈希表的平均查找长度实际上并不等于零。</p><p>决定哈希表查找的ASL因素：</p><p>1）选用的哈希函数</p><p>2）选用的处理冲突的方法</p><p>3）哈希表饱和的程度，装载因子$$\alpha&#x3D;\frac{n}{m}$$，其中n是记录数，m是表长。</p><p>哈希表的ASL是处理冲突方法和装载因子的函数。</p><p>求哈希表ASL的方法</p><img src="https://s2.loli.net/2024/11/01/tFlwhGDmrbJBoX7.jpg" alt="_20241101192721.png" style="zoom: 67%;" /><p>用哈希函数查找每一个元素，一次查找到就计1，冲突时用对应的冲突解决方法，看要用几次，算上一开始的查找一共经历的次数为这个元素对应的查找次数。所有元素的查找次数之和&#x2F;元素个数&#x3D;平均查找长度。</p><p>图中是用链地址法，更加直观一点。</p><img src="https://s2.loli.net/2024/11/01/wzaeiluhSFAQJWO.jpg" alt="_20241101193159.png" style="zoom:50%;" /><h3 id="6-3-排序"><a href="#6-3-排序" class="headerlink" title="6.3 排序"></a>6.3 排序</h3><p>内部排序：不用访问外存就能排序</p><p>外部排序：排序的数量很大，不可能在内存中完成。</p><p>排序的稳定性能：对于两个关键字相等的记录，他们在序列中的相对位置，在排序之前与排序之后没有改变，称之为稳定，反之不稳定。</p><p>稳定的排序方法对任何例子 都稳定，不稳定的排序方法一定存在一个反例体现其不稳定。</p><h4 id="6-3-1冒泡排序"><a href="#6-3-1冒泡排序" class="headerlink" title="6.3.1冒泡排序"></a>6.3.1冒泡排序</h4><p>对序列相邻记录进行对比，通过相邻的两两交换，把最大的记录放到最后一位上。第二轮遍历时只需遍历到倒数第二位。</p><p>同理第i次遍历只需遍历到n+i-1位置上。</p><img src="https://s2.loli.net/2024/11/01/iV6K8ekOvYuPU2c.jpg" alt="_20241101193935.png" style="zoom:50%;" /><p>时间复杂度$$O(n^2）$$，稳定但是效率低。</p><h4 id="6-3-2-选择排序"><a href="#6-3-2-选择排序" class="headerlink" title="6.3.2 选择排序"></a>6.3.2 选择排序</h4><p>先将tool变量赋一个初值，然后与遍历整个序列，遇到比他小的就把tool赋值为这个更小值，记录下标。遍历完后找到最小值及其下标，把这个最小值与第一位值交换位置。第二遍的时候从第二位开始，最后也与第二位交换。同理第i遍从第i位开始，最后与第i位交换。</p><img src="https://s2.loli.net/2024/11/01/x3oEK1DTZlyekFC.jpg" alt="_20241101194421.png" style="zoom:50%;" /><p>时间复杂度$$O(n^2）$$，不稳定且效率低。</p><h4 id="6-3-3-插入排序"><a href="#6-3-3-插入排序" class="headerlink" title="6.3.3 插入排序"></a>6.3.3 插入排序</h4><p>先将第一个记录看作有序的，将下一个记录插入到前面有序序列的合适位置；第二次时前两位是有序的，把第三位记录插入到前两位的合适位置；同理到第i次时，此时前i位序列是有序的，把第i+1位插入到前i位的合适位置。以此类推直到全都有序。</p><p>可分为直接插入类型和折半插入类型</p><img src="https://s2.loli.net/2024/11/01/WxElhA467kqbu8L.jpg" alt="_20241101194912.png" style="zoom:50%;" /><p>时间复杂度$$O(n^2）$$，稳定但是效率低。</p><h4 id="6-3-4-归并排序"><a href="#6-3-4-归并排序" class="headerlink" title="6.3.4 归并排序"></a>6.3.4 归并排序</h4><p>先将序列分为两个或者两个以上子序列，对这些子序列分别排序，再把这些有序子序列归并起来。可用递归的思想，把序列两两分得的子序列再两两分直到全分为只包含一个记录的序列，再两两归并回去。重点在于归并。</p><p>对归并一般采用2路归并排序</p><img src="https://s2.loli.net/2024/11/01/2ikwzoeTjaBtqpH.jpg" alt="_20241101200159.png" style="zoom:50%;" /><p>归并排序就是两两分开再排好的过程</p><img src="https://s2.loli.net/2024/11/01/NXlYwIpijma6eDc.jpg" alt="_20241101200401.png" style="zoom:50%;" /><p>归并排序时间复杂度$$O(nlog_n)$$。</p><h4 id="6-3-5-快速排序"><a href="#6-3-5-快速排序" class="headerlink" title="6.3.5 快速排序"></a>6.3.5 快速排序</h4><p>先找到一个枢轴，小于它的关键字都移到它左边，大于它的移到它右边。这样枢轴的绝对位置其实就已经定下来了，枢轴把原序列分成了两个新序列，再分别对两个新序列进行快速排序，连续递归直到都有序。</p><p>一次快速排列的过程：</p><p>假设在第一位值有一个low指针，最后一位有个high指针。</p><p>确定一个枢轴，从high指针逆向移动遍历，比较第一个：</p><p>​如果比枢轴大，就让这个值不动，high指针向前移动一位；</p><p>​如果这个值比枢轴小，把枢轴与这个值交换位置，转而开始移动low指针，high指针还是指向这个位置。</p><p>​从low指针开始正向移动遍历，比较其与枢轴大小：</p><p>​如果它比枢轴小，这个值不动，low向后移动一位。</p><p>​如果它比枢轴大，把枢轴与这个值交换位置，转而开始移动high指针，low指针还是指向这个位置。</p><p>以此类推形成递归，直到high与low都指向枢轴。枢轴右侧时high逆向移动，要求比枢轴大；枢轴左侧时low正向移动，要求比枢轴小。</p><p>同时发现异常时直接交换枢轴与异常值位置并且改变移动的指针。</p><p>例：34   66   27   18   72   40   45 把34作为枢轴</p><p>先比较high指针：发现45  40  72  都比34大，到18时比34小，交换34与18，此时high指向倒数第四位。</p><p>交换后：18   66   27   34   72   40   45</p><p>开始比较low指针：18比它小，66比他大异常，此时low指向第二位</p><p>交换后：18   34   27   66   72   40   45</p><p>再动high指针：66比他大，27比他小异常，交换</p><p>交换后：18   27   34   66   72   40   45</p><p>在动low：27比他小，再动low指向34了，high也指向34.遍历完成。</p><p>此时完成了一次快速排序。</p><p>最终结果：18   27   34   66   72   40   45</p><p>此时对34前面的（18  27）；后面的（66   72   40   45）分别进行快速排序，再得出枢纽或者到只含有一个元素的有序序列。再拼起来。</p><img src="https://s2.loli.net/2024/11/01/e18iRmBbEYPSoq3.jpg" alt="_20241101202358.png" style="zoom:50%;" /><p><a href="%5B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E2%80%94%E5%9B%BE%E6%96%87%E8%AF%A6%E8%A7%A3%EF%BC%8C%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81-CSDN%E5%8D%9A%E5%AE%A2%5D(https://blog.csdn.net/qq_39181839/article/details/109478094)">快速排序详解</a></p><p>快速排序时间复杂度$$O(nlog_n)$$。</p><h4 id="6-3-6-堆排序"><a href="#6-3-6-堆排序" class="headerlink" title="6.3.6 堆排序"></a>6.3.6 堆排序</h4><h5 id="堆的定义："><a href="#堆的定义：" class="headerlink" title="堆的定义："></a>堆的定义：</h5><p>n个元素的序列，满足<br>$$<br>k_i\leq k_{2i}\ \ \ \ \ 2i\leq n\<br>k_i\leq k_{2i+1}\ \ \ \ \ 2i+1\leq n\<br>或者\<br>k_i\geq k_{2i}\ \ \ \ \ 2i\leq n\<br>k_i\geq k_{2i+1}\ \ \ \ \ 2i+1\leq n\<br>$$<br>可以看出来堆是一棵完全二叉树，从二叉树按照从上到下，从左到右的编号后输出的序列就是堆的序列。</p><h5 id="堆的性质："><a href="#堆的性质：" class="headerlink" title="堆的性质："></a>堆的性质：</h5><p>1）堆是一棵采用顺序存储结构的完全二叉树，k1是根节点</p><p>2）堆的根节点是最小或最大值，分别称为小根堆或者大根堆</p><p>3）从根节点到每一个叶结点的路径上经过的元素都是非递减（递增加相等）或者非递增（递减加相等）的</p><p>4）堆的任一子树也是堆</p><p>5）任一个节点的子节点均大于或者小于这个节点。</p><h5 id="堆排序思想"><a href="#堆排序思想" class="headerlink" title="堆排序思想"></a>堆排序思想</h5><p>1）对一组序列，先建立堆。</p><p>2）将堆顶记录和最后一个记录交换位置，前n-1个是无序的，而最后一个位置是有序的。（注意只交换数，位置不动）</p><p>3）将前n-1个记录再调整成堆，然后堆顶元素再和倒数第二个位置交换。</p><p>4）一直重复直到记录全部排好序。</p><h5 id="堆的建立"><a href="#堆的建立" class="headerlink" title="堆的建立"></a>堆的建立</h5><p>比如建立大根堆</p><p>对序列 100  5  3  11  33   6   8   7</p><p><img src="https://pic2.zhimg.com/v2-6db33bd4ddb7937ca5946283ef2acc5d_1440w.jpg"></p><p>从最小子树开始构建堆，即左下角11  7，发现11&gt;7满足，已经是堆了</p><p>再看右边子树3   6   8，3&lt;6   3&lt;8，大根堆，最大的肯定要做父结点，把三者最大的8作为父结点，3   8换位。</p><p>再看左边5   11   33    7这个堆对于5   11   33，33最大做父结点，5   33换位</p><img src="https://pic4.zhimg.com/v2-cf88501a8092e7b0c4712aa81a875f03_1440w.jpg" style="zoom:67%;" /><p>再看上面的堆100   33   8，已经满足了，那么堆就建立好了。</p><p>从最底层的堆一点点向上建立堆，对构成堆的三个节点肯定会存在一个最大值，无非就三种情况，按照大根堆还是小根堆把最大最小值换到子树根节点就行了。</p><h5 id="堆的调整"><a href="#堆的调整" class="headerlink" title="堆的调整"></a>堆的调整</h5><p>把堆顶和最后一位换位</p><img src="https://pic3.zhimg.com/v2-e96b570c470785e19936abceee95c8ca_1440w.jpg" style="zoom:80%;" /><p>自上而下调整，7   33   8对比，33   7换位</p><p><img src="https://pic4.zhimg.com/v2-5bbfec3cb200b9fa7efcf29fe71fc7dd_1440w.jpg"></p><p>7   11   5对比，11   7换位</p><p><img src="https://pic4.zhimg.com/v2-1f490e927a5d7d5e97e9609f7e99b6e5_1440w.jpg"></p><p>100的位置始终不变，其余节点已经构成堆了，3变成了末端位置，此时再将3和33换位；不断调整成堆，最终全部有序。</p><img src="https://s2.loli.net/2024/11/01/yAzLiEZRrWvIshl.jpg" alt="_20241101210203.png" style="zoom:50%;" /><p>堆的建立是从下到上修正；堆的调整是从上到下调整，记住末端位置一定不能变。</p><p>堆排序时间复杂度$$O(nlog_n)$$。</p><h4 id="6-3-7-希尔排序（不考）"><a href="#6-3-7-希尔排序（不考）" class="headerlink" title="6.3.7 希尔排序（不考）"></a>6.3.7 希尔排序（不考）</h4><p>先取一个正整数d1&lt;n作为第一个增量，将全部n个记录分成d1组，把所有相隔为d1的记录放在一组，即R[k],R[k+d1],R[k+2d1]…放在一组。</p><p>然后在各组内进行插入排序，这样分组加排序一次称为希尔排序。</p><p>取新的增量d2&lt;d1，重复分组与排序；直到所取的增量di为1为止。</p><p>例如9,13,8,2,5,13*,7,1,15,11，增量序列是5,3,1</p><p>第一次排序分组[9,13*] [13,7] [8,1] [2,15] [5,11]</p><p>排序完后：9  7  1  2  5  13*  13  8  15  11</p><p>第二次排序分组[9,2,13,11] [7,5,8] [1,13*,15]</p><p>排序完后：2  5  1  9  7  13*  11  8  15  13</p><p>第三次d3&#x3D;1，相当于直接插入排序。</p><p>排序完后：1  2  5  7  8  9  11  13*  13  15</p><p>并不是简单分割，而是有增量分割。</p><p>希尔排序的时间复杂度是其所取的增量序列的函数，并没有一个准确值。</p><p>由上面的例子可得：希尔排序不稳定。</p><p>增量序列取法：除1外都是素数，最后一个增量值必须为1。</p><h3 id="6-4-小结"><a href="#6-4-小结" class="headerlink" title="6.4 小结"></a>6.4 小结</h3><table><thead><tr><th>排序方法</th><th>时间复杂度</th><th>是否稳定</th></tr></thead><tbody><tr><td>冒牌排序</td><td>$$O(n^2）$$</td><td>稳定</td></tr><tr><td>选择排序</td><td>$$O(n^2）$$</td><td>不稳定</td></tr><tr><td>插入排序</td><td>$$O(n^2）$$</td><td>稳定</td></tr><tr><td>归并排序</td><td>$$O(nlog_n)$$</td><td>稳定</td></tr><tr><td>快速排序</td><td>$$O(nlog_n)$$</td><td>不稳定</td></tr><tr><td>堆排序</td><td>$$O(nlog_n)$$</td><td>不稳定</td></tr><tr><td>希尔排序</td><td>不是准确值</td><td>不稳定</td></tr></tbody></table><h2 id="第七章-考试相关"><a href="#第七章-考试相关" class="headerlink" title="第七章 考试相关"></a>第七章 考试相关</h2><p>划重点：</p><p>掌握逻辑结构。</p><p>四种存储方式：顺序存储，链式存储，哈希存储，索引存储（B-树那里）。</p><p>链表和顺序表：会顺序表求交并集</p><p>栈：ppt里面的一些面试题，几乎都包括在里面了，不会有新的。</p><p>队列：了解先进先出后进后出的原理，回文判断，两个栈怎么实现一个队列。</p><p>二叉树：前序，中序，后序，层序遍历。结果及实现。</p><p>哈夫曼编码：给字符及权重如何构建一个哈夫曼树和得到哈夫曼编码。</p><p>二叉搜索树，AVL树，红黑树，B-树之间关系。（在数据检索中，为了适合动态查找环境、提高查找性能，提出了二叉搜索树；但是由于二叉搜索树会有不平衡现象，极端情况下有单边现象，会降低检索效率，因此提出平衡二叉树，保证了二叉排序树的平衡；但是平衡二叉树要求全局平衡，要求较为严苛，维护代价很高，为了改善这一点提出了红黑树；红黑树只用满足局部平衡，即根节点到任何一个叶节点经过的黑色节点数数目相同，放宽了平衡的要求，不必严苛的全局平衡，出现不平衡经过简单的换色和旋转即可调整；前面的所有树都是二叉树，只适用于量很小时的检索，当对于量很大时的文件检索，效率又会很低，由此引进高度数的搜索树m叉树，降低树的高度，而为了m叉树的平衡问题又引进了m叉B-树。）</p><p>构建二叉搜索树，B-树。</p><p>（这些搜索树的删除与插入，不太一定）</p><p>哈希存储：哈希函数怎么构造（六种方法：直接选址法，平方取中法，折叠法，数字分析法，随机数法，除留余数法）遇到冲突怎么解决（两种：开放定址法（又分三种增量取值：线性探测再散列，二次探测再散列，伪随机数再散列），链地址法）</p><p>排序：快速排序，归并排序，堆排序。</p><p>时间复杂度，给出一个序列，问你走一遍排成什么样子。</p><p>栈后面题ppt原文，虽然上面也写了</p><img src="https://s2.loli.net/2024/11/01/EBulVnWOTvmzhCr.jpg" alt="_20241101214350.png" style="zoom: 67%;" /><img src="https://s2.loli.net/2024/11/01/V98bZW7stxLiHmO.jpg" alt="_20241101214442.png" style="zoom:67%;" /><p>判断回文：</p><img src="https://s2.loli.net/2024/11/01/MYXU7FzimVO35s8.jpg" alt="_20241101214549.png" style="zoom: 67%;" /><p>两个栈实现一个队列：</p><img src="https://s2.loli.net/2024/11/01/WeDYsJtSG3ZXPp6.jpg" alt="_20241101214625.png" style="zoom:67%;" /><p>交并集运算：</p><img src="https://s2.loli.net/2024/11/01/5B7AFKUpzS4Lkm3.jpg" alt="_20241101214742.png" style="zoom:67%;" /><p><img src="https://s2.loli.net/2024/11/01/Oe3bjZEuLPIipBN.jpg" alt="_20241101214816.png"></p>]]></content>
    
    
    <categories>
      
      <category>其他工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
